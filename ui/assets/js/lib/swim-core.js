(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.swim = global.swim || {}));
}(this, function (exports) { 'use strict';

    function codePointAt(index) {
        var size = this.length;
        index = index ? Number(index) : 0;
        if (index !== index) {
            index = 0;
        }
        if (index >= 0 && index < size) {
            var c1 = this.charCodeAt(index);
            if (c1 <= 0xd7ff || c1 >= 0xe000) {
                return c1;
            }
            else if (c1 <= 0xdbff && index + 1 < size) {
                var c2 = this.charCodeAt(index + 1);
                if (c2 >= 0xdc00 && c2 <= 0xdfff) {
                    return ((c1 & 0x03ff) << 10 + c2 & 0x03ff) + 0x10000;
                }
            }
        }
        return void 0;
    }
    function offsetByCodePoints(index, count) {
        if (count > 0) {
            var size = this.length;
            while (count > 0 && index < size) {
                var c1 = this.charCodeAt(index);
                if (c1 <= 0xd7ff || c1 >= 0xe000) {
                    index += 1;
                }
                else if (c1 <= 0xdbff && index + 1 < size) {
                    var c2 = this.charCodeAt(index + 1);
                    if (c2 >= 0xdc00 && c2 <= 0xdfff) {
                        index += 2;
                    }
                    else {
                        index += 1;
                    }
                }
                else {
                    index += 1;
                }
                count -= 1;
            }
        }
        else if (count < 0) {
            while (count < 0 && index > 0) {
                var c2 = this.charCodeAt(index - 1);
                if (c2 <= 0xd7ff || c2 >= 0xe000) {
                    index -= 1;
                }
                else if (c2 >= 0xdc00 && c2 <= 0xdfff && index - 1 > 0) {
                    var c1 = this.charCodeAt(index - 2);
                    if (c1 >= 0xd800 && c1 <= 0xdfff) {
                        index -= 2;
                    }
                    else {
                        index -= 1;
                    }
                }
                else {
                    index -= 1;
                }
                count -= 1;
            }
        }
        return index;
    }
    if (!String.prototype.codePointAt) {
        Object.defineProperty(String.prototype, "codePointAt", {
            value: codePointAt,
            configurable: true,
            writable: true,
        });
    }
    if (!String.prototype.offsetByCodePoints) {
        Object.defineProperty(String.prototype, "offsetByCodePoints", {
            value: offsetByCodePoints,
            configurable: true,
            writable: true,
        });
    }

    (function (ByteOrder) {
        ByteOrder["BigEndian"] = "BE";
        ByteOrder["LittleEndian"] = "LE";
    })(exports.ByteOrder || (exports.ByteOrder = {}));
    function nativeOrder() {
        var bom = new ArrayBuffer(2);
        new Uint16Array(bom)[0] = 0xfeff;
        var b = new Uint8Array(bom);
        if (b[0] === 0xfe && b[1] === 0xff) {
            return "BE";
        }
        else if (b[0] === 0xff && b[1] === 0xfe) {
            return "LE";
        }
        else {
            throw new Error();
        }
    }
    var NativeOrder = nativeOrder();

    var crypto = (typeof window !== "undefined" &&
        (window.crypto || window.msCrypto));
    function fillBytesCrypto(typedArray) {
        crypto.getRandomValues(typedArray);
    }
    function fillBytesMath(typedArray) {
        if (typedArray instanceof Int8Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 128 - Math.round(Math.random() * 256);
            }
        }
        else if (typedArray instanceof Uint8Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 256);
            }
        }
        else if (typedArray instanceof Int16Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 32768 - Math.round(Math.random() * 65536);
            }
        }
        else if (typedArray instanceof Uint16Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 65536);
            }
        }
        else if (typedArray instanceof Int32Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 2147483648 - Math.round(Math.random() * 4294967296);
            }
        }
        else if (typedArray instanceof Uint32Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 4294967296);
            }
        }
        else {
            throw new TypeError("" + typedArray);
        }
    }
    var Random = (function () {
        function Random() {
        }
        Random.fillBytes = crypto ? fillBytesCrypto : fillBytesMath;
        return Random;
    }());

    var hashArrayBuffer = new ArrayBuffer(8);
    var hashFloat64Array = new Float64Array(hashArrayBuffer);
    var hashInt32Array = new Int32Array(hashArrayBuffer);
    function rotl(value, distance) {
        return (value << distance) | (value >>> (32 - distance));
    }
    var Murmur3 = (function () {
        function Murmur3() {
        }
        Murmur3.seed = function (value) {
            if (typeof value === "object" && value) {
                if (value.constructor && typeof value.constructor.name === "string") {
                    value = value.constructor.name;
                }
                else {
                    value = value.toString();
                }
            }
            return Murmur3.hash(value);
        };
        Murmur3.hash = function (value) {
            if (value instanceof Uint8Array || typeof value === "string") {
                return Murmur3.mash(Murmur3.mix(0, value));
            }
            else if (typeof value === "number") {
                if (~~value === value) {
                    return ~~value;
                }
                hashFloat64Array[0] = value;
                return hashInt32Array[0] ^ hashInt32Array[1];
            }
            else if (typeof value === "boolean") {
                return value ? 3 : 2;
            }
            else if (value === null) {
                return 1;
            }
            else if (value === undefined) {
                return 0;
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Murmur3.mixUint8ArrayBE = function (code, array) {
            var offset = 0;
            var limit = array.length;
            while (offset + 3 < limit) {
                var word = (array[offset] & 0xff) << 24 | (array[offset + 1] & 0xff) << 16
                    | (array[offset + 2] & 0xff) << 8 | array[offset + 3] & 0xff;
                code = Murmur3.mix(code, word);
                offset += 4;
            }
            if (offset < limit) {
                var word = (array[offset] & 0xff) << 24;
                if (offset + 1 < limit) {
                    word |= (array[offset + 1] & 0xff) << 16;
                    if (offset + 2 < limit) {
                        word |= (array[offset + 2] & 0xff) << 8;
                    }
                }
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ limit;
        };
        Murmur3.mixUInt8ArrayLE = function (code, array) {
            var offset = 0;
            var limit = array.length;
            while (offset + 3 < limit) {
                var word = array[offset] & 0xff | (array[offset + 1] & 0xff) << 8
                    | (array[offset + 2] & 0xff) << 16 | (array[offset + 3] & 0xff) << 24;
                code = Murmur3.mix(code, word);
                offset += 4;
            }
            if (offset < limit) {
                var word = array[offset] & 0xff;
                if (offset + 1 < limit) {
                    word |= (array[offset + 1] & 0xff) << 8;
                    if (offset + 2 < limit) {
                        word |= (array[offset + 2] & 0xff) << 16;
                    }
                }
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ limit;
        };
        Murmur3.mixStringBE = function (code, string) {
            var word = 0;
            var k = 32;
            var i = 0;
            var n = string.length;
            var utf8Length = 0;
            while (i < n) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c >= 0 && c <= 0x7f) {
                    k -= 8;
                    word |= c << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 1;
                }
                else if (c >= 0x80 && c <= 0x7ff) {
                    k -= 8;
                    word |= (0xc0 | (c >>> 6)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 2;
                }
                else if (c >= 0x0800 && c <= 0xffff ||
                    c >= 0xe000 && c <= 0xffff) {
                    k -= 8;
                    word |= (0xe0 | (c >>> 12)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 3;
                }
                else if (c >= 0x10000 && c <= 0x10ffff) {
                    k -= 8;
                    word |= (0xf0 | (c >>> 18)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 12) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 4;
                }
                else {
                    k -= 8;
                    word |= 0xef << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= 0xbf << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= 0xbd << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 3;
                }
                i = string.offsetByCodePoints(i, 1);
            }
            if (k !== 32) {
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ utf8Length;
        };
        Murmur3.mixStringLE = function (code, string) {
            var word = 0;
            var k = 0;
            var i = 0;
            var n = string.length;
            var utf8Length = 0;
            while (i < n) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c >= 0 && c <= 0x7f) {
                    word |= c << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 1;
                }
                else if (c >= 0x80 && c <= 0x7ff) {
                    word |= (0xc0 | (c >>> 6)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 2;
                }
                else if (c >= 0x0800 && c <= 0xffff ||
                    c >= 0xe000 && c <= 0xffff) {
                    word |= (0xe0 | (c >>> 12)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 3;
                }
                else if (c >= 0x10000 && c <= 0x10ffff) {
                    word |= (0xf0 | (c >>> 18)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 12) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 4;
                }
                else {
                    word |= 0xef << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= 0xbf << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= 0xbd << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 3;
                }
                i = string.offsetByCodePoints(i, 1);
            }
            if (k !== 32) {
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ utf8Length;
        };
        Murmur3.mix = function (code, value) {
            if (typeof value === "number") {
                value = ((value & 0xffff) * 0xcc9e2d51) + (((value >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                value = rotl(value, 15);
                value = ((value & 0xffff) * 0x1b873593) + (((value >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= value;
                code = rotl(code, 13);
                code = ((code & 0xffff) * 5) + (((code >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
                code = ((code & 0xffff) + 0x6b64) + (((code >>> 16) + 0xe654 & 0xffff) << 16);
                return code;
            }
            else if (typeof value === "string") {
                if (NativeOrder === "BE") {
                    return Murmur3.mixStringBE(code, value);
                }
                else if (NativeOrder === "LE") {
                    return Murmur3.mixStringLE(code, value);
                }
            }
            else if (value instanceof Uint8Array) {
                if (NativeOrder === "BE") {
                    return Murmur3.mixUint8ArrayBE(code, value);
                }
                else if (NativeOrder === "LE") {
                    return Murmur3.mixUInt8ArrayLE(code, value);
                }
            }
            throw new TypeError("" + value);
        };
        Murmur3.mash = function (code) {
            code ^= code >>> 16;
            code = ((code & 0xffff) * 0x85ebca6b) + (((code >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
            code ^= code >>> 13;
            code = ((code & 0xffff) * 0xc2b2ae35) + (((code >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
            code ^= code >>> 16;
            return code >>> 0;
        };
        return Murmur3;
    }());

    var Objects = (function () {
        function Objects() {
        }
        Objects.compare = function (x, y) {
            if (x instanceof Date) {
                x = x.getTime();
            }
            if (y instanceof Date) {
                y = y.getTime();
            }
            if (x === void 0) {
                if (y === void 0) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else if (x === null) {
                if (y === void 0) {
                    return -1;
                }
                else if (y === null) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "number") {
                if (y === void 0 || y === null) {
                    return -1;
                }
                else if (typeof y === "number") {
                    return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "string") {
                if (y === void 0 || y === null || typeof y === "number") {
                    return -1;
                }
                else if (typeof y === "string") {
                    return x < y ? -1 : x > y ? 1 : 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "object" && typeof x.compareTo === "function") {
                var order = x.compareTo(y);
                return order < 0 ? -1 : order > 0 ? 1 : 0;
            }
            else if (Array.isArray(x)) {
                if (y === void 0 || y === null || typeof y === "number" || typeof y === "string") {
                    return -1;
                }
                else if (Array.isArray(y)) {
                    return Objects.compareArray(x, y);
                }
                else {
                    return 1;
                }
            }
            else {
                if (y === void 0 || y === null || typeof y === "number" || typeof y === "string" || Array.isArray(y)) {
                    return -1;
                }
                else {
                    return Objects.compareObject(x, y);
                }
            }
        };
        Objects.compareArray = function (x, y) {
            var p = x.length;
            var q = y.length;
            var order = 0;
            for (var i = 0, n = Math.min(p, q); i < n && order === 0; i += 1) {
                order = Objects.compare(x[i], y[i]);
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
        };
        Objects.compareObject = function (x, y) {
            var xKeys = Object.keys(x);
            var yKeys = Object.keys(y);
            var p = xKeys.length;
            var q = yKeys.length;
            var n = Math.min(p, q);
            var order = 0;
            for (var i = 0; i < n && order === 0; i += 1) {
                var xKey = xKeys[i];
                var yKey = yKeys[i];
                order = Objects.compare(xKey, yKey);
                if (order === 0) {
                    order = Objects.compare(x[xKey], y[yKey]);
                }
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
        };
        Objects.equal = function (x, y) {
            if (x instanceof Date) {
                x = x.getTime();
            }
            if (y instanceof Date) {
                y = y.getTime();
            }
            if (x === y) {
                return true;
            }
            else if (typeof x === "number") {
                if (typeof y === "number") {
                    return isNaN(x) && isNaN(y);
                }
            }
            else if (typeof x === "object" && x && typeof x.equals === "function") {
                return x.equals(y);
            }
            else if (Array.isArray(x)) {
                if (Array.isArray(y)) {
                    return Objects.equalArray(x, y);
                }
            }
            else if (typeof x === "object" && x) {
                if (typeof y === "object" && y) {
                    return Objects.equalObject(x, y);
                }
            }
            return false;
        };
        Objects.equalArray = function (x, y) {
            var n = x.length;
            if (n !== y.length) {
                return false;
            }
            for (var i = 0; i < n; i += 1) {
                if (!Objects.equal(x[i], y[i])) {
                    return false;
                }
            }
            return true;
        };
        Objects.equalObject = function (x, y) {
            var xKeys = Object.keys(x);
            var yKeys = Object.keys(y);
            var n = xKeys.length;
            if (n !== yKeys.length) {
                return false;
            }
            for (var i = 0; i < n; i += 1) {
                var key = xKeys[i];
                if (key !== yKeys[i] || !Objects.equal(x[key], y[key])) {
                    return false;
                }
            }
            return true;
        };
        Objects.hash = function (x) {
            if (x === void 0 || x === null || typeof x === "boolean"
                || typeof x === "number" || typeof x === "string") {
                return Murmur3.hash(x);
            }
            else if (typeof x === "object" && typeof x.hashCode === "function") {
                return x.hashCode();
            }
            else if (Array.isArray(x)) {
                return Objects.hashArray(x);
            }
            else if (typeof x === "object") {
                return Objects.hashObject(x);
            }
            else {
                throw new TypeError("" + x);
            }
        };
        Objects.hashArray = function (x) {
            var h = 0;
            var n = x.length;
            for (var i = 0; i < n; i += 1) {
                h = Murmur3.mix(h, Objects.hash(x[i]));
            }
            return Murmur3.mash(h);
        };
        Objects.hashObject = function (x) {
            var h = 0;
            var keys = Object.keys(x);
            var n = keys.length;
            for (var i = 0; i < n; i += 1) {
                var key = keys[i];
                h = Murmur3.mix(Murmur3.mix(h, Murmur3.hash(key)), x[key]);
            }
            return Murmur3.mash(h);
        };
        return Objects;
    }());

    var FromAny = {
        is: function (object) {
            if (typeof object === "object" && object || typeof object === "function") {
                return typeof object.fromAny === "function";
            }
            return false;
        },
    };
    var ToAny = {
        is: function (object) {
            if (typeof object === "object" && object) {
                return typeof object.toAny === "function";
            }
            return false;
        },
    };

    var Cursor = (function () {
        function Cursor() {
        }
        Cursor.prototype.set = function (newValue) {
            throw new Error("immutable");
        };
        Cursor.prototype.delete = function () {
            throw new Error("immutable");
        };
        Cursor.empty = function () {
            if (!Cursor._empty) {
                Cursor._empty = new Cursor.Empty();
            }
            return Cursor._empty;
        };
        Cursor.unary = function (value) {
            return new Cursor.Unary(value);
        };
        Cursor.array = function (array, index, limit) {
            if (index === void 0) { index = 0; }
            if (limit === void 0) { limit = array.length; }
            return new Cursor.Array(array, index, limit);
        };
        return Cursor;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var CursorEmpty = (function (_super) {
        __extends(CursorEmpty, _super);
        function CursorEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CursorEmpty.prototype.isEmpty = function () {
            return true;
        };
        CursorEmpty.prototype.head = function () {
            throw new Error("empty");
        };
        CursorEmpty.prototype.step = function () {
            throw new Error("empty");
        };
        CursorEmpty.prototype.skip = function (count) {
        };
        CursorEmpty.prototype.hasNext = function () {
            return false;
        };
        CursorEmpty.prototype.nextIndex = function () {
            return 0;
        };
        CursorEmpty.prototype.next = function () {
            return { done: true };
        };
        CursorEmpty.prototype.hasPrevious = function () {
            return false;
        };
        CursorEmpty.prototype.previousIndex = function () {
            return -1;
        };
        CursorEmpty.prototype.previous = function () {
            return { done: true };
        };
        return CursorEmpty;
    }(Cursor));
    Cursor.Empty = CursorEmpty;

    var CursorUnary = (function (_super) {
        __extends(CursorUnary, _super);
        function CursorUnary(value) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._index = 0;
            return _this;
        }
        CursorUnary.prototype.isEmpty = function () {
            return this._index !== 0;
        };
        CursorUnary.prototype.head = function () {
            if (this._index === 0) {
                return this._value;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorUnary.prototype.step = function () {
            if (this._index === 0) {
                this._index = 1;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorUnary.prototype.skip = function (count) {
            this._index = Math.min(Math.max(0, this._index + count), 1);
        };
        CursorUnary.prototype.hasNext = function () {
            return this._index === 0;
        };
        CursorUnary.prototype.nextIndex = function () {
            return this._index;
        };
        CursorUnary.prototype.next = function () {
            if (this._index === 0) {
                this._index = 1;
                return { value: this._value, done: true };
            }
            else {
                return { done: true };
            }
        };
        CursorUnary.prototype.hasPrevious = function () {
            return this._index === 1;
        };
        CursorUnary.prototype.previousIndex = function () {
            return this._index - 1;
        };
        CursorUnary.prototype.previous = function () {
            if (this._index === 1) {
                this._index = 0;
                return { value: this._value, done: true };
            }
            else {
                return { done: true };
            }
        };
        return CursorUnary;
    }(Cursor));
    Cursor.Unary = CursorUnary;

    var CursorArray = (function (_super) {
        __extends(CursorArray, _super);
        function CursorArray(array, index, limit) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._index = index;
            _this._limit = limit;
            return _this;
        }
        CursorArray.prototype.isEmpty = function () {
            return this._index >= this._limit;
        };
        CursorArray.prototype.head = function () {
            if (this._index < this._limit) {
                return this._array[this._index];
            }
            else {
                throw new Error("empty");
            }
        };
        CursorArray.prototype.step = function () {
            if (this._index < this._limit) {
                this._index = 1;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorArray.prototype.skip = function (count) {
            this._index = Math.min(this._index + count, this._limit);
        };
        CursorArray.prototype.hasNext = function () {
            return this._index < this._limit;
        };
        CursorArray.prototype.nextIndex = function () {
            return this._index;
        };
        CursorArray.prototype.next = function () {
            var index = this._index;
            if (index < this._limit) {
                this._index = index + 1;
                return { value: this._array[index], done: this._index === this._limit };
            }
            else {
                this._index = this._limit;
                return { done: true };
            }
        };
        CursorArray.prototype.hasPrevious = function () {
            return this._index > 0;
        };
        CursorArray.prototype.previousIndex = function () {
            return this._index - 1;
        };
        CursorArray.prototype.previous = function () {
            var index = this._index - 1;
            if (index >= 0) {
                this._index = index;
                return { value: this._array[index], done: index === 0 };
            }
            else {
                this._index = 0;
                return { done: true };
            }
        };
        return CursorArray;
    }(Cursor));
    Cursor.Array = CursorArray;

    var AssertException = (function (_super) {
        __extends(AssertException, _super);
        function AssertException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = AssertException.prototype;
            return _this;
        }
        return AssertException;
    }(Error));

    var assert = function (condition, message) {
        if (!condition) {
            throw new AssertException(message);
        }
    };
    assert.ok = function (condition, message) {
        if (!condition) {
            throw new AssertException(message);
        }
    };
    assert.notOk = function (condition, message) {
        if (condition) {
            throw new AssertException(message);
        }
    };
    assert.equal = function (lhs, rhs, message) {
        if (!Objects.equal(lhs, rhs)) {
            throw new AssertException(message);
        }
    };
    assert.notEqual = function (lhs, rhs, message) {
        if (Objects.equal(lhs, rhs)) {
            throw new AssertException(message);
        }
    };
    assert.identity = function (lhs, rhs, message) {
        if (lhs !== rhs) {
            throw new AssertException(message);
        }
    };
    assert.notIdentity = function (lhs, rhs, message) {
        if (lhs === rhs) {
            throw new AssertException(message);
        }
    };
    assert.compareLessThan = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) < 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotLessThan = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) < 0) {
            throw new AssertException(message);
        }
    };
    assert.compareLessThanOrEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) <= 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotLessThanOrEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) <= 0) {
            throw new AssertException(message);
        }
    };
    assert.compareEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) === 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) === 0) {
            throw new AssertException(message);
        }
    };
    assert.compareGreaterThanOrEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) >= 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotGreaterThanOrEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) >= 0) {
            throw new AssertException(message);
        }
    };
    assert.compareGreaterThan = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) > 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotGreaterThan = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) > 0) {
            throw new AssertException(message);
        }
    };

    var Severity = (function () {
        function Severity(level, label) {
            this._level = level;
            this._label = label;
        }
        Severity.prototype.level = function () {
            return this._level;
        };
        Severity.prototype.label = function (label) {
            if (label === void 0) {
                return this._label;
            }
            else {
                return Severity.create(this._level, label);
            }
        };
        Severity.prototype.isTrace = function () {
            return this._level === Severity.TRACE_LEVEL;
        };
        Severity.prototype.isDebug = function () {
            return this._level === Severity.DEBUG_LEVEL;
        };
        Severity.prototype.isInfo = function () {
            return this._level === Severity.INFO_LEVEL;
        };
        Severity.prototype.isNote = function () {
            return this._level === Severity.NOTE_LEVEL;
        };
        Severity.prototype.isWarning = function () {
            return this._level === Severity.WARNING_LEVEL;
        };
        Severity.prototype.isError = function () {
            return this._level === Severity.ERROR_LEVEL;
        };
        Severity.prototype.isAlert = function () {
            return this._level === Severity.ALERT_LEVEL;
        };
        Severity.prototype.isFatal = function () {
            return this._level === Severity.FATAL_LEVEL;
        };
        Severity.prototype.compareTo = function (that) {
            if (this === that) {
                return 0;
            }
            else if (this._level < that._level) {
                return -1;
            }
            else if (this._level > that._level) {
                return 1;
            }
            else {
                return this._label.localeCompare(that._label);
            }
        };
        Severity.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Severity) {
                return this._level === that._level && this._label === that._label;
            }
            return false;
        };
        Severity.prototype.hashCode = function () {
            if (Severity._hashSeed === void 0) {
                Severity._hashSeed = Murmur3.seed(Severity);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Severity._hashSeed, this._level), Murmur3.hash(this._label)));
        };
        Severity.prototype.toString = function () {
            return this._label;
        };
        Severity.create = function (level, label) {
            switch (level) {
                case Severity.TRACE_LEVEL: return Severity.trace(label);
                case Severity.DEBUG_LEVEL: return Severity.debug(label);
                case Severity.INFO_LEVEL: return Severity.info(label);
                case Severity.NOTE_LEVEL: return Severity.note(label);
                case Severity.WARNING_LEVEL: return Severity.warning(label);
                case Severity.ERROR_LEVEL: return Severity.error(label);
                case Severity.ALERT_LEVEL: return Severity.alert(label);
                case Severity.FATAL_LEVEL: return Severity.fatal(label);
                default: throw new Error("" + level);
            }
        };
        Severity.trace = function (label) {
            if (label === void 0) { label = "trace"; }
            if (label === "trace") {
                if (!Severity._trace) {
                    Severity._trace = new Severity(Severity.TRACE_LEVEL, label);
                }
                return Severity._trace;
            }
            else {
                return new Severity(Severity.TRACE_LEVEL, label);
            }
        };
        Severity.debug = function (label) {
            if (label === void 0) { label = "debug"; }
            if (label === "debug") {
                if (!Severity._debug) {
                    Severity._debug = new Severity(Severity.DEBUG_LEVEL, label);
                }
                return Severity._debug;
            }
            else {
                return new Severity(Severity.DEBUG_LEVEL, label);
            }
        };
        Severity.info = function (label) {
            if (label === void 0) { label = "info"; }
            if (label === "info") {
                if (!Severity._info) {
                    Severity._info = new Severity(Severity.INFO_LEVEL, label);
                }
                return Severity._info;
            }
            else {
                return new Severity(Severity.INFO_LEVEL, label);
            }
        };
        Severity.note = function (label) {
            if (label === void 0) { label = "note"; }
            if (label === "note") {
                if (!Severity._note) {
                    Severity._note = new Severity(Severity.NOTE_LEVEL, label);
                }
                return Severity._note;
            }
            else {
                return new Severity(Severity.NOTE_LEVEL, label);
            }
        };
        Severity.warning = function (label) {
            if (label === void 0) { label = "warning"; }
            if (label === "warning") {
                if (!Severity._warning) {
                    Severity._warning = new Severity(Severity.WARNING_LEVEL, label);
                }
                return Severity._warning;
            }
            else {
                return new Severity(Severity.WARNING_LEVEL, label);
            }
        };
        Severity.error = function (label) {
            if (label === void 0) { label = "error"; }
            if (label === "error") {
                if (!Severity._error) {
                    Severity._error = new Severity(Severity.ERROR_LEVEL, label);
                }
                return Severity._error;
            }
            else {
                return new Severity(Severity.ERROR_LEVEL, label);
            }
        };
        Severity.alert = function (label) {
            if (label === void 0) { label = "alert"; }
            if (label === "alert") {
                if (!Severity._alert) {
                    Severity._alert = new Severity(Severity.ALERT_LEVEL, label);
                }
                return Severity._alert;
            }
            else {
                return new Severity(Severity.ALERT_LEVEL, label);
            }
        };
        Severity.fatal = function (label) {
            if (label === void 0) { label = "fatal"; }
            if (label === "fatal") {
                if (!Severity._fatal) {
                    Severity._fatal = new Severity(Severity.FATAL_LEVEL, label);
                }
                return Severity._fatal;
            }
            else {
                return new Severity(Severity.FATAL_LEVEL, label);
            }
        };
        Severity.TRACE_LEVEL = 0;
        Severity.DEBUG_LEVEL = 1;
        Severity.INFO_LEVEL = 2;
        Severity.NOTE_LEVEL = 3;
        Severity.WARNING_LEVEL = 4;
        Severity.ERROR_LEVEL = 5;
        Severity.ALERT_LEVEL = 6;
        Severity.FATAL_LEVEL = 7;
        return Severity;
    }());

    var HashGenCacheMap = (function () {
        function HashGenCacheMap(size) {
            this._buckets = new Array(size);
            this._gen4Hits = 0;
            this._gen3Hits = 0;
            this._gen2Hits = 0;
            this._gen1Hits = 0;
            this._misses = 0;
        }
        HashGenCacheMap.prototype.get = function (key) {
            if (this._buckets.length === 0) {
                return void 0;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return void 0;
            }
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                if (gen4Val !== void 0) {
                    this._gen4Hits += 1;
                    bucket._gen4Weight++;
                    return gen4Val;
                }
                else {
                    bucket._gen4Key = void 0;
                }
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                if (gen3Val !== void 0) {
                    this._gen3Hits += 1;
                    if (bucket._gen3Weight++ > bucket._gen4Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen3Val;
                }
                else {
                    bucket._gen3Key = void 0;
                }
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                if (gen2Val !== void 0) {
                    this._gen2Hits += 1;
                    if (bucket._gen2Weight++ > bucket._gen3Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen2Val;
                }
                else {
                    bucket._gen2Key = void 0;
                }
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                if (gen1Val !== void 0) {
                    this._gen1Hits += 1;
                    if (bucket._gen1Weight++ > bucket._gen2Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight);
                    }
                    return gen1Val;
                }
                else {
                    bucket._gen1Key = void 0;
                }
            }
            this._misses += 1;
            return void 0;
        };
        HashGenCacheMap.prototype.put = function (key, value) {
            if (this._buckets.length === 0) {
                return value;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index] || new HashGenCacheMapBucket();
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                if (gen4Val !== void 0) {
                    this._gen4Hits += 1;
                    bucket._gen4Weight++;
                    return gen4Val;
                }
                else {
                    bucket._gen4Key = void 0;
                    gen4Key = void 0;
                }
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                if (gen3Val !== void 0) {
                    this._gen3Hits += 1;
                    if (bucket._gen3Weight++ > bucket._gen4Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen3Val;
                }
                else {
                    bucket._gen3Key = void 0;
                    gen3Key = void 0;
                }
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                if (gen2Val !== void 0) {
                    this._gen2Hits += 1;
                    if (bucket._gen2Weight++ > bucket._gen3Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen2Val;
                }
                else {
                    bucket._gen2Key = void 0;
                    gen2Key = void 0;
                }
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                if (gen1Val !== void 0) {
                    this._gen1Hits += 1;
                    if (bucket._gen1Weight++ > bucket._gen2Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight);
                    }
                    return gen1Val;
                }
                else {
                    bucket._gen1Key = void 0;
                    gen1Key = void 0;
                }
            }
            this._misses += 1;
            if (gen4Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen3Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen2Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen1Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, key, value, 1);
            }
            else {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight - 1, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight - 1, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            return value;
        };
        HashGenCacheMap.prototype.remove = function (key) {
            if (this._buckets.length === 0) {
                return void 0;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return void 0;
            }
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen4Val;
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen3Val;
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen2Val;
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, void 0, void 0, 0);
                return gen1Val;
            }
            return void 0;
        };
        HashGenCacheMap.prototype.clear = function () {
            for (var i = 0; i < this._buckets.length; i += 1) {
                this._buckets[i] = void 0;
            }
        };
        HashGenCacheMap.prototype.hits = function () {
            return this._gen4Hits + this._gen3Hits + this._gen2Hits + this._gen1Hits;
        };
        HashGenCacheMap.prototype.hitRatio = function () {
            var hits = this.hits();
            return hits / (hits + this._misses);
        };
        return HashGenCacheMap;
    }());
    var HashGenCacheMapBucket = (function () {
        function HashGenCacheMapBucket(gen4Key, gen4Val, gen4Weight, gen3Key, gen3Val, gen3Weight, gen2Key, gen2Val, gen2Weight, gen1Key, gen1Val, gen1Weight) {
            if (gen4Weight === void 0) { gen4Weight = 0; }
            if (gen3Weight === void 0) { gen3Weight = 0; }
            if (gen2Weight === void 0) { gen2Weight = 0; }
            if (gen1Weight === void 0) { gen1Weight = 0; }
            this._gen4Key = gen4Key;
            this._gen4Val = gen4Val;
            this._gen4Weight = gen4Weight;
            this._gen3Key = gen3Key;
            this._gen3Val = gen3Val;
            this._gen3Weight = gen3Weight;
            this._gen2Key = gen2Key;
            this._gen2Val = gen2Val;
            this._gen2Weight = gen2Weight;
            this._gen1Key = gen1Key;
            this._gen1Val = gen1Val;
            this._gen1Weight = gen1Weight;
        }
        return HashGenCacheMapBucket;
    }());

    var HashGenCacheSet = (function () {
        function HashGenCacheSet(size) {
            this._buckets = new Array(size);
            this._gen4Hits = 0;
            this._gen3Hits = 0;
            this._gen2Hits = 0;
            this._gen1Hits = 0;
            this._misses = 0;
        }
        HashGenCacheSet.prototype.put = function (value) {
            if (this._buckets.length === 0) {
                return value;
            }
            var index = Math.abs(Objects.hash(value)) % this._buckets.length;
            var bucket = this._buckets[index] || new HashGenCacheSetBucket();
            var gen4Val = bucket._gen4Val;
            if (gen4Val !== void 0 && Objects.equal(value, gen4Val)) {
                this._gen4Hits += 1;
                bucket._gen4Weight++;
                return gen4Val;
            }
            var gen3Val = bucket._gen3Val;
            if (gen3Val !== void 0 && Objects.equal(value, gen3Val)) {
                this._gen3Hits += 1;
                if (bucket._gen3Weight++ > bucket._gen4Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight);
                }
                return gen3Val;
            }
            var gen2Val = bucket._gen2Val;
            if (gen2Val !== void 0 && Objects.equal(value, gen2Val)) {
                this._gen2Hits += 1;
                if (bucket._gen2Weight++ > bucket._gen3Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight);
                }
                return gen2Val;
            }
            var gen1Val = bucket._gen1Val;
            if (gen1Val !== void 0 && Objects.equal(value, gen1Val)) {
                this._gen1Hits += 1;
                if (bucket._gen1Weight++ > bucket._gen2Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Val, bucket._gen2Weight);
                }
                return gen1Val;
            }
            this._misses += 1;
            if (gen4Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen3Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen2Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen1Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, value, 1);
            }
            else {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight - 1, bucket._gen3Val, bucket._gen3Weight - 1, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            return value;
        };
        HashGenCacheSet.prototype.remove = function (value) {
            if (this._buckets.length === 0) {
                return false;
            }
            var index = Math.abs(Objects.hash(value)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return false;
            }
            var gen4Val = bucket._gen4Val;
            if (gen4Val !== void 0 && Objects.equal(value, gen4Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen3Val = bucket._gen3Val;
            if (gen3Val !== void 0 && Objects.equal(value, gen3Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen2Val = bucket._gen2Val;
            if (gen2Val !== void 0 && Objects.equal(value, gen2Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen1Val = bucket._gen1Val;
            if (gen1Val !== void 0 && Objects.equal(value, gen1Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, void 0, 0);
                return true;
            }
            return false;
        };
        HashGenCacheSet.prototype.clear = function () {
            for (var i = 0; i < this._buckets.length; i += 1) {
                this._buckets[i] = void 0;
            }
        };
        HashGenCacheSet.prototype.hits = function () {
            return this._gen4Hits + this._gen3Hits + this._gen2Hits + this._gen1Hits;
        };
        HashGenCacheSet.prototype.hitRatio = function () {
            var hits = this.hits();
            return hits / (hits + this._misses);
        };
        return HashGenCacheSet;
    }());
    var HashGenCacheSetBucket = (function () {
        function HashGenCacheSetBucket(gen4Val, gen4Weight, gen3Val, gen3Weight, gen2Val, gen2Weight, gen1Val, gen1Weight) {
            if (gen4Weight === void 0) { gen4Weight = 0; }
            if (gen3Weight === void 0) { gen3Weight = 0; }
            if (gen2Weight === void 0) { gen2Weight = 0; }
            if (gen1Weight === void 0) { gen1Weight = 0; }
            this._gen4Val = gen4Val;
            this._gen4Weight = gen4Weight;
            this._gen3Val = gen3Val;
            this._gen3Weight = gen3Weight;
            this._gen2Val = gen2Val;
            this._gen2Weight = gen2Weight;
            this._gen1Val = gen1Val;
            this._gen1Weight = gen1Weight;
        }
        return HashGenCacheSetBucket;
    }());

    var Tag = (function () {
        function Tag() {
        }
        return Tag;
    }());

    var Mark = (function (_super) {
        __extends(Mark, _super);
        function Mark(offset, line, column, note) {
            var _this = _super.call(this) || this;
            _this._offset = offset;
            _this._line = line;
            _this._column = column;
            _this._note = note;
            return _this;
        }
        Mark.prototype.offset = function () {
            return this._offset;
        };
        Mark.prototype.line = function () {
            return this._line;
        };
        Mark.prototype.column = function () {
            return this._column;
        };
        Mark.prototype.note = function () {
            return this._note;
        };
        Mark.prototype.min = function (that) {
            if (this._offset <= that._offset) {
                return this;
            }
            else {
                return that;
            }
        };
        Mark.prototype.max = function (that) {
            if (this._offset >= that._offset) {
                return this;
            }
            else {
                return that;
            }
        };
        Mark.prototype.start = function () {
            return this;
        };
        Mark.prototype.end = function () {
            return this;
        };
        Mark.prototype.union = function (that) {
            if (that instanceof Mark) {
                if (this._offset === that._offset && this._line === that._line
                    && this._column === that._column) {
                    return this;
                }
                else {
                    return Tag.Span.from(this, that);
                }
            }
            else if (that instanceof Tag.Span) {
                var start = this.min(that._start);
                var end = this.max(that._end);
                if (start === that._start && end === that._end) {
                    return that;
                }
                else {
                    return Tag.Span.from(start, end);
                }
            }
            throw new Error(that.toString());
        };
        Mark.prototype.shift = function (mark) {
            var offset = this._offset + (this._offset - mark._offset);
            var line = this._line + (this._line - mark._line);
            var column = this._column;
            if (line === 1) {
                column += (this._column - mark._column);
            }
            if (offset === this._offset && line === this._line && column === this._column) {
                return this;
            }
            else {
                return Mark.at(offset, line, column, this._note);
            }
        };
        Mark.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Mark) {
                return this._offset === that._offset && this._line === that._line
                    && this._column === that._column && this._note === that._note;
            }
            return false;
        };
        Mark.prototype.hashCode = function () {
            if (Mark._hashSeed === void 0) {
                Mark._hashSeed = Murmur3.seed(Mark);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Mark._hashSeed, this._offset), this._line), this._column), Murmur3.hash(this._note)));
        };
        Mark.prototype.display = function (output) {
            Tag.Format.displayNumber(this._line, output);
            output = output.write(58);
            Tag.Format.displayNumber(this._column, output);
            if (this._note !== null) {
                output = output.write(58).write(32).write(this._note);
            }
        };
        Mark.prototype.debug = function (output) {
            output = output.write("Mark").write(".").write("at").write("(");
            Tag.Format.debugNumber(this._offset, output);
            output = output.write(", ");
            Tag.Format.debugNumber(this._line, output);
            output = output.write(", ");
            Tag.Format.debugNumber(this._column, output);
            if (this._note !== null) {
                output = output.write(", ");
                Tag.Format.debugString(this._note, output);
            }
            output = output.write(")");
        };
        Mark.prototype.toString = function () {
            return Tag.Format.display(this);
        };
        Mark.zero = function () {
            if (!Mark._zero) {
                Mark._zero = new Mark(0, 1, 1, null);
            }
            return Mark._zero;
        };
        Mark.at = function (offset, line, column, note) {
            if (note === void 0) { note = null; }
            return new Mark(offset, line, column, note);
        };
        return Mark;
    }(Tag));
    Tag.Mark = Mark;

    var Span = (function (_super) {
        __extends(Span, _super);
        function Span(start, end) {
            var _this = _super.call(this) || this;
            _this._start = start;
            _this._end = end;
            return _this;
        }
        Span.prototype.start = function () {
            return this._start;
        };
        Span.prototype.end = function () {
            return this._end;
        };
        Span.prototype.union = function (that) {
            if (that instanceof Tag.Mark) {
                var start = this._start.min(that);
                var end = this._end.max(that);
                if (start === this._start && end === this._end) {
                    return this;
                }
                else {
                    return Span.from(start, end);
                }
            }
            else if (that instanceof Span) {
                var start = this._start.min(that._start);
                var end = this._end.max(that._end);
                if (start === this._start && end === this._end) {
                    return this;
                }
                else {
                    return Span.from(start, end);
                }
            }
            throw new Error(that.toString());
        };
        Span.prototype.shift = function (mark) {
            var start = this._start.shift(mark);
            var end = this._end.shift(mark);
            if (start === this._start && end === this._end) {
                return this;
            }
            else {
                return Span.from(start, end);
            }
        };
        Span.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Span) {
                return this._start.equals(that._start) && this._end.equals(that._end);
            }
            return false;
        };
        Span.prototype.hashCode = function () {
            if (Span._hashSeed === void 0) {
                Span._hashSeed = Murmur3.seed(Span);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Span._hashSeed, this._start.hashCode()), this._end.hashCode()));
        };
        Span.prototype.display = function (output) {
            if (this._start._note !== null) {
                output = output.write(this._start._note).write(58).write(32);
            }
            Tag.Format.displayNumber(this._start._line, output);
            output = output.write(58);
            Tag.Format.displayNumber(this._start._column, output);
            output = output.write(45);
            Tag.Format.displayNumber(this._end._line, output);
            output = output.write(58);
            Tag.Format.displayNumber(this._end._column, output);
            if (this._end._note !== null) {
                output = output.write(58).write(32).write(this._end._note);
            }
        };
        Span.prototype.debug = function (output) {
            output = output.write("Span").write(".").write("from").write("(");
            this._start.debug(output);
            output = output.write(", ");
            this._end.debug(output);
            output = output.write(")");
        };
        Span.prototype.toString = function () {
            return Tag.Format.display(this);
        };
        Span.from = function (start, end) {
            if (start._offset > end._offset) {
                var tmp = start;
                start = end;
                end = tmp;
            }
            return new Span(start, end);
        };
        return Span;
    }(Tag));
    Tag.Span = Span;

    var InputException = (function (_super) {
        __extends(InputException, _super);
        function InputException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = InputException.prototype;
            return _this;
        }
        return InputException;
    }(Error));

    var OutputSettings = (function () {
        function OutputSettings(lineSeparator, isPretty, isStyled) {
            this._lineSeparator = lineSeparator;
            this._isPretty = isPretty;
            this._isStyled = isStyled;
        }
        OutputSettings.prototype.lineSeparator = function (lineSeparator) {
            if (lineSeparator === void 0) {
                return this._lineSeparator;
            }
            else {
                return this.copy(lineSeparator, this._isPretty, this._isStyled);
            }
        };
        OutputSettings.prototype.isPretty = function (isPretty) {
            if (isPretty === void 0) {
                return this._isPretty;
            }
            else {
                return this.copy(this._lineSeparator, isPretty, this._isStyled);
            }
        };
        OutputSettings.prototype.isStyled = function (isStyled) {
            if (isStyled === void 0) {
                return this._isStyled;
            }
            else {
                return this.copy(this._lineSeparator, this._isPretty, isStyled);
            }
        };
        OutputSettings.prototype.copy = function (lineSeparator, isPretty, isStyled) {
            return OutputSettings.create(lineSeparator, isPretty, isStyled);
        };
        OutputSettings.prototype.canEqual = function (that) {
            return that instanceof OutputSettings;
        };
        OutputSettings.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof OutputSettings) {
                return that.canEqual(this) && this._lineSeparator === that._lineSeparator
                    && this._isPretty === that._isPretty && this._isStyled === that._isStyled;
            }
            return false;
        };
        OutputSettings.prototype.hashCode = function () {
            if (OutputSettings._hashSeed === void 0) {
                OutputSettings._hashSeed = Murmur3.seed(OutputSettings);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(OutputSettings._hashSeed, Murmur3.hash(this._lineSeparator)), Murmur3.hash(this._isPretty)), Murmur3.hash(this._isStyled)));
        };
        OutputSettings.prototype.debug = function (output) {
            output = output.write("OutputSettings").write(46);
            if (!this._isPretty && !this._isStyled) {
                output = output.write("standard");
            }
            else if (this._isPretty && !this._isStyled) {
                output = output.write("pretty");
            }
            else if (!this._isPretty && this._isStyled) {
                output = output.write("styled");
            }
            else {
                output = output.write("prettyStyled");
            }
            output = output.write(40).write(41);
            if (Format.lineSeparator() !== this._lineSeparator) {
                output = output.write(46).write("lineSeparator").write(40)
                    .display(this._lineSeparator).write(41);
            }
        };
        OutputSettings.prototype.toString = function () {
            return Format.debug(this);
        };
        OutputSettings.standard = function () {
            if (!OutputSettings._standard) {
                OutputSettings._standard = new OutputSettings(Format.lineSeparator(), false, false);
            }
            return OutputSettings._standard;
        };
        OutputSettings.pretty = function () {
            if (!OutputSettings._pretty) {
                OutputSettings._pretty = new OutputSettings(Format.lineSeparator(), true, false);
            }
            return OutputSettings._pretty;
        };
        OutputSettings.styled = function () {
            if (!OutputSettings._styled) {
                OutputSettings._styled = new OutputSettings(Format.lineSeparator(), false, true);
            }
            return OutputSettings._styled;
        };
        OutputSettings.prettyStyled = function () {
            if (!OutputSettings._prettyStyled) {
                OutputSettings._prettyStyled = new OutputSettings(Format.lineSeparator(), true, true);
            }
            return OutputSettings._prettyStyled;
        };
        OutputSettings.create = function (lineSeparator, isPretty, isStyled) {
            if (typeof lineSeparator !== "string") {
                lineSeparator = Format.lineSeparator();
            }
            if (typeof isPretty !== "boolean") {
                isPretty = false;
            }
            if (typeof isStyled !== "boolean") {
                isStyled = false;
            }
            if (Format.lineSeparator() === lineSeparator) {
                if (!isPretty && !isStyled) {
                    return OutputSettings.standard();
                }
                else if (isPretty && !isStyled) {
                    return OutputSettings.pretty();
                }
                else if (!isPretty && isStyled) {
                    return OutputSettings.styled();
                }
                else {
                    return OutputSettings.prettyStyled();
                }
            }
            return new OutputSettings(lineSeparator, isPretty, isStyled);
        };
        OutputSettings.fromAny = function (settings) {
            if (settings instanceof OutputSettings) {
                return settings;
            }
            else if (typeof settings === "object" && settings) {
                return OutputSettings.create(settings.lineSeparator, settings.isPretty, settings.isStyled);
            }
            return OutputSettings.standard();
        };
        return OutputSettings;
    }());

    var OutputException = (function (_super) {
        __extends(OutputException, _super);
        function OutputException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = OutputException.prototype;
            return _this;
        }
        return OutputException;
    }(Error));

    var Output = (function () {
        function Output() {
        }
        Output.prototype.writeln = function (string) {
            if (typeof string === "string") {
                this.write(string);
            }
            return this.write(this.settings().lineSeparator());
        };
        Output.prototype.display = function (object) {
            Format.display(object, this);
            return this;
        };
        Output.prototype.debug = function (object) {
            Format.debug(object, this);
            return this;
        };
        Output.prototype.flush = function () {
            return this;
        };
        Output.prototype.push = function () {
            var tokens = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                tokens[_i] = arguments[_i];
            }
            var n = tokens.length;
            for (var i = 0; i < n; i += 1) {
                this.write(tokens[i]);
            }
        };
        Output.prototype.trap = function () {
            throw new OutputException();
        };
        Output.prototype.clone = function () {
            throw new Error();
        };
        Output.full = function (value, settings) {
            if (value === void 0) { value = null; }
            if (settings === void 0) { settings = OutputSettings.standard(); }
            if (value === null && settings === OutputSettings.standard()) {
                if (!Output._full) {
                    Output._full = new OutputFull(value, OutputSettings.standard());
                }
                return Output._full;
            }
            return new OutputFull(value, settings);
        };
        Output.done = function (value, settings) {
            if (value === void 0) { value = null; }
            if (settings === void 0) { settings = OutputSettings.standard(); }
            if (value === null && settings === OutputSettings.standard()) {
                if (!Output._done) {
                    Output._done = new OutputDone(value, OutputSettings.standard());
                }
                return Output._done;
            }
            return new OutputDone(value, settings);
        };
        Output.error = function (error, settings) {
            if (settings === void 0) { settings = OutputSettings.standard(); }
            return new OutputError(error, settings);
        };
        return Output;
    }());
    var OutputFull = (function (_super) {
        __extends(OutputFull, _super);
        function OutputFull(value, settings) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._settings = settings;
            return _this;
        }
        OutputFull.prototype.isCont = function () {
            return false;
        };
        OutputFull.prototype.isFull = function () {
            return true;
        };
        OutputFull.prototype.isDone = function () {
            return false;
        };
        OutputFull.prototype.isError = function () {
            return false;
        };
        OutputFull.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return true;
            }
            else if (isPart) {
                return Output.done(this._value, this._settings);
            }
            else {
                return this;
            }
        };
        OutputFull.prototype.write = function (tokenOrString) {
            return Output.error(new OutputException("full"), this._settings);
        };
        OutputFull.prototype.writeln = function (string) {
            return Output.error(new OutputException("full"), this._settings);
        };
        OutputFull.prototype.bind = function () {
            return this._value;
        };
        OutputFull.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Output.full(this._value, settings);
            }
        };
        OutputFull.prototype.clone = function () {
            return this;
        };
        return OutputFull;
    }(Output));
    var OutputDone = (function (_super) {
        __extends(OutputDone, _super);
        function OutputDone(value, settings) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._settings = settings;
            return _this;
        }
        OutputDone.prototype.isCont = function () {
            return false;
        };
        OutputDone.prototype.isFull = function () {
            return false;
        };
        OutputDone.prototype.isDone = function () {
            return true;
        };
        OutputDone.prototype.isError = function () {
            return false;
        };
        OutputDone.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else if (isPart) {
                return this;
            }
            else {
                return Output.full(this._value, this._settings);
            }
        };
        OutputDone.prototype.write = function (tokenOrString) {
            return Output.error(new OutputException("done"), this._settings);
        };
        OutputDone.prototype.writeln = function (string) {
            return Output.error(new OutputException("done"), this._settings);
        };
        OutputDone.prototype.bind = function () {
            return this._value;
        };
        OutputDone.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Output.done(this._value, settings);
            }
        };
        OutputDone.prototype.clone = function () {
            return this;
        };
        return OutputDone;
    }(Output));
    var OutputError = (function (_super) {
        __extends(OutputError, _super);
        function OutputError(error, settings) {
            var _this = _super.call(this) || this;
            _this._error = error;
            _this._settings = settings;
            return _this;
        }
        OutputError.prototype.isCont = function () {
            return false;
        };
        OutputError.prototype.isFull = function () {
            return false;
        };
        OutputError.prototype.isDone = function () {
            return false;
        };
        OutputError.prototype.isError = function () {
            return true;
        };
        OutputError.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        OutputError.prototype.write = function (tokenOrString) {
            return this;
        };
        OutputError.prototype.writeln = function (string) {
            return this;
        };
        OutputError.prototype.bind = function () {
            throw new OutputException();
        };
        OutputError.prototype.trap = function () {
            return this._error;
        };
        OutputError.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Output.error(this._error, settings);
            }
        };
        OutputError.prototype.clone = function () {
            return this;
        };
        return OutputError;
    }(Output));

    var Input = (function () {
        function Input() {
        }
        Input.prototype.trap = function () {
            throw new InputException();
        };
        Input.prototype.offset = function () {
            return this.mark()._offset;
        };
        Input.prototype.line = function () {
            return this.mark()._line;
        };
        Input.prototype.column = function () {
            return this.mark()._column;
        };
        Input.empty = function (id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {
                if (!Input._empty) {
                    Input._empty = new InputEmpty(null, Mark.zero(), InputSettings.standard());
                }
                return Input._empty;
            }
            return new InputEmpty(id, mark, settings);
        };
        Input.done = function (id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {
                if (!Input._done) {
                    Input._done = new InputDone(null, Mark.zero(), InputSettings.standard());
                }
                return Input._done;
            }
            return new InputDone(id, mark, settings);
        };
        Input.error = function (error, id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            return new InputError(error, id, mark, settings);
        };
        return Input;
    }());
    var InputEmpty = (function (_super) {
        __extends(InputEmpty, _super);
        function InputEmpty(id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputEmpty.prototype.isCont = function () {
            return false;
        };
        InputEmpty.prototype.isEmpty = function () {
            return true;
        };
        InputEmpty.prototype.isDone = function () {
            return false;
        };
        InputEmpty.prototype.isError = function () {
            return false;
        };
        InputEmpty.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return true;
            }
            else if (isPart) {
                return this;
            }
            else {
                return Input.done(this._id, this._mark, this._settings);
            }
        };
        InputEmpty.prototype.head = function () {
            throw new InputException();
        };
        InputEmpty.prototype.step = function () {
            var error = new InputException("empty step");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputEmpty.prototype.seek = function (mark) {
            var error = new InputException("empty seek");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputEmpty.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return Input.empty(id, this._mark, this._settings);
            }
        };
        InputEmpty.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return Input.empty(this._id, mark, this._settings);
            }
        };
        InputEmpty.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Input.empty(this._id, this._mark, settings);
            }
        };
        InputEmpty.prototype.clone = function () {
            return this;
        };
        return InputEmpty;
    }(Input));
    var InputDone = (function (_super) {
        __extends(InputDone, _super);
        function InputDone(id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputDone.prototype.isCont = function () {
            return false;
        };
        InputDone.prototype.isEmpty = function () {
            return false;
        };
        InputDone.prototype.isDone = function () {
            return true;
        };
        InputDone.prototype.isError = function () {
            return false;
        };
        InputDone.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else if (isPart) {
                return Input.empty(this._id, this._mark, this._settings);
            }
            else {
                return this;
            }
        };
        InputDone.prototype.head = function () {
            throw new InputException();
        };
        InputDone.prototype.step = function () {
            var error = new InputException("done step");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputDone.prototype.seek = function (mark) {
            var error = new InputException("empty seek");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputDone.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return Input.done(id, this._mark, this._settings);
            }
        };
        InputDone.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return Input.done(this._id, mark, this._settings);
            }
        };
        InputDone.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Input.done(this._id, this._mark, settings);
            }
        };
        InputDone.prototype.clone = function () {
            return this;
        };
        return InputDone;
    }(Input));
    var InputError = (function (_super) {
        __extends(InputError, _super);
        function InputError(error, id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._error = error;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputError.prototype.isCont = function () {
            return false;
        };
        InputError.prototype.isEmpty = function () {
            return false;
        };
        InputError.prototype.isDone = function () {
            return false;
        };
        InputError.prototype.isError = function () {
            return true;
        };
        InputError.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        InputError.prototype.head = function () {
            throw new InputException();
        };
        InputError.prototype.step = function () {
            var error = new InputException("error step");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputError.prototype.trap = function () {
            return this._error;
        };
        InputError.prototype.seek = function (mark) {
            var error = new InputException("error seek");
            return Input.error(error, this._id, this._mark, this._settings);
        };
        InputError.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return Input.error(this._error, id, this._mark, this._settings);
            }
        };
        InputError.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return Input.error(this._error, this._id, mark, this._settings);
            }
        };
        InputError.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return Input.error(this._error, this._id, this._mark, settings);
            }
        };
        InputError.prototype.clone = function () {
            return this;
        };
        return InputError;
    }(Input));

    var StringInput = (function (_super) {
        __extends(StringInput, _super);
        function StringInput(string, id, offset, line, column, settings, index, isPart) {
            if (id === void 0) { id = null; }
            if (offset === void 0) { offset = 0; }
            if (line === void 0) { line = 1; }
            if (column === void 0) { column = 1; }
            if (settings === void 0) { settings = InputSettings.standard(); }
            if (index === void 0) { index = 0; }
            if (isPart === void 0) { isPart = false; }
            var _this = _super.call(this) || this;
            _this._string = string;
            _this._id = id;
            _this._offset = offset;
            _this._line = line;
            _this._column = column;
            _this._settings = settings;
            _this._index = index;
            _this._isPart = isPart;
            return _this;
        }
        StringInput.prototype.isCont = function () {
            return this._index < this._string.length;
        };
        StringInput.prototype.isEmpty = function () {
            return this._isPart && this._index >= this._string.length;
        };
        StringInput.prototype.isDone = function () {
            return !this._isPart && this._index >= this._string.length;
        };
        StringInput.prototype.isError = function () {
            return false;
        };
        StringInput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return this._isPart;
            }
            else {
                this._isPart = isPart;
                return this;
            }
        };
        StringInput.prototype.head = function () {
            if (this._index < this._string.length) {
                var c = this._string.codePointAt(this._index);
                if (c !== void 0) {
                    return c;
                }
                else {
                    return this._string.charCodeAt(this._index);
                }
            }
            throw new InputException();
        };
        StringInput.prototype.step = function () {
            var index = this._index;
            if (index < this._string.length) {
                var c = this._string.codePointAt(index);
                this._index = this._string.offsetByCodePoints(index, 1);
                this._offset += this._index - index;
                if (c === 10) {
                    this._line += 1;
                    this._column = 1;
                }
                else {
                    this._column += 1;
                }
                return this;
            }
            else {
                var error = new InputException("invalid step");
                return Input.error(error, this._id, this.mark(), this._settings);
            }
        };
        StringInput.prototype.seek = function (mark) {
            if (mark !== void 0) {
                var index = this._index + (mark._offset - this._offset);
                if (0 <= index && index <= this._string.length) {
                    this._offset = mark._offset;
                    this._line = mark._line;
                    this._column = mark._column;
                    this._index = index;
                    return this;
                }
                else {
                    var error = new InputException("invalid seek to " + mark);
                    return Input.error(error, this._id, this.mark(), this._settings);
                }
            }
            else {
                this._offset = 0;
                this._line = 1;
                this._column = 1;
                this._index = 0;
                return this;
            }
        };
        StringInput.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                this._id = id;
                return this;
            }
        };
        StringInput.prototype.mark = function (mark) {
            if (mark === void 0) {
                return Mark.at(this._offset, this._line, this._column);
            }
            else {
                this._offset = mark._offset;
                this._line = mark._line;
                this._column = mark._column;
                return this;
            }
        };
        StringInput.prototype.offset = function () {
            return this._offset;
        };
        StringInput.prototype.line = function () {
            return this._line;
        };
        StringInput.prototype.column = function () {
            return this._column;
        };
        StringInput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = InputSettings.fromAny(settings);
                return this;
            }
        };
        StringInput.prototype.clone = function () {
            return new StringInput(this._string, this._id, this._offset, this._line, this._column, this._settings, this._index, this._isPart);
        };
        return StringInput;
    }(Input));

    var StringOutput = (function (_super) {
        __extends(StringOutput, _super);
        function StringOutput(string, settings) {
            var _this = _super.call(this) || this;
            _this._string = string;
            _this._settings = settings;
            return _this;
        }
        StringOutput.prototype.isCont = function () {
            return true;
        };
        StringOutput.prototype.isFull = function () {
            return false;
        };
        StringOutput.prototype.isDone = function () {
            return false;
        };
        StringOutput.prototype.isError = function () {
            return false;
        };
        StringOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        StringOutput.prototype.write = function (token) {
            if (typeof token === "number") {
                if ((token >= 0x0000 && token <= 0xd7ff)
                    || (token >= 0xe000 && token <= 0xffff)) {
                    token = String.fromCharCode(token);
                }
                else if (token >= 0x10000 && token <= 0x10ffff) {
                    var u = token - 0x10000;
                    token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));
                }
                else {
                    token = "\ufffd";
                }
            }
            this._string += token;
            return this;
        };
        StringOutput.prototype.writeln = function (string) {
            if (string === void 0) {
                this._string = this._string.concat(this._settings._lineSeparator);
                return this;
            }
            else {
                this._string = this._string.concat(string).concat(this._settings._lineSeparator);
                return this;
            }
        };
        StringOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = OutputSettings.fromAny(settings);
                return this;
            }
        };
        StringOutput.prototype.bind = function () {
            return this._string;
        };
        StringOutput.prototype.clone = function () {
            return new StringOutput(this._string, this._settings);
        };
        StringOutput.prototype.toString = function () {
            return this._string;
        };
        return StringOutput;
    }(Output));

    var WriterException = (function (_super) {
        __extends(WriterException, _super);
        function WriterException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = WriterException.prototype;
            return _this;
        }
        return WriterException;
    }(Error));

    var Writer = (function () {
        function Writer() {
        }
        Writer.prototype.isCont = function () {
            return true;
        };
        Writer.prototype.isDone = function () {
            return false;
        };
        Writer.prototype.isError = function () {
            return false;
        };
        Writer.prototype.feed = function (input) {
            throw new Error();
        };
        Writer.prototype.fork = function (condition) {
            return this;
        };
        Writer.prototype.bind = function () {
            throw new Error();
        };
        Writer.prototype.trap = function () {
            throw new Error();
        };
        Writer.prototype.asDone = function () {
            throw new Error();
        };
        Writer.prototype.asError = function () {
            throw new Error();
        };
        Writer.prototype.andThen = function (that) {
            return new WriterAndThen(this, that);
        };
        Writer.done = function (output) {
            if (output === void 0) {
                if (!Writer._done) {
                    Writer._done = new WriterDone(void 0);
                }
                return Writer._done;
            }
            else {
                return new WriterDone(output);
            }
        };
        Writer.error = function (error) {
            return new WriterError(error);
        };
        return Writer;
    }());
    var WriterDone = (function (_super) {
        __extends(WriterDone, _super);
        function WriterDone(output) {
            var _this = _super.call(this) || this;
            _this._output = output;
            return _this;
        }
        WriterDone.prototype.isCont = function () {
            return false;
        };
        WriterDone.prototype.isDone = function () {
            return true;
        };
        WriterDone.prototype.pull = function (output) {
            return this;
        };
        WriterDone.prototype.bind = function () {
            return this._output;
        };
        WriterDone.prototype.asDone = function () {
            return this;
        };
        WriterDone.prototype.andThen = function (that) {
            return that;
        };
        return WriterDone;
    }(Writer));
    var WriterError = (function (_super) {
        __extends(WriterError, _super);
        function WriterError(error) {
            var _this = _super.call(this) || this;
            _this._error = error;
            return _this;
        }
        WriterError.prototype.isCont = function () {
            return false;
        };
        WriterError.prototype.isError = function () {
            return true;
        };
        WriterError.prototype.pull = function (output) {
            return this;
        };
        WriterError.prototype.bind = function () {
            throw this._error;
        };
        WriterError.prototype.trap = function () {
            return this._error;
        };
        WriterError.prototype.asError = function () {
            return this;
        };
        WriterError.prototype.andThen = function (that) {
            return this;
        };
        return WriterError;
    }(Writer));
    var WriterAndThen = (function (_super) {
        __extends(WriterAndThen, _super);
        function WriterAndThen(head, tail) {
            var _this = _super.call(this) || this;
            _this._head = head;
            _this._tail = tail;
            return _this;
        }
        WriterAndThen.prototype.pull = function (output) {
            var head = this._head;
            if (head.isCont()) {
                head = head.pull(output);
            }
            if (head.isError()) {
                return head.asError();
            }
            else if (head.isDone()) {
                return this._tail.pull(output);
            }
            else {
                return new WriterAndThen(head, this._tail);
            }
        };
        return WriterAndThen;
    }(Writer));

    var StringWriter = (function (_super) {
        __extends(StringWriter, _super);
        function StringWriter(value, input, index) {
            if (index === void 0) { index = 0; }
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._input = input;
            _this._index = index;
            return _this;
        }
        StringWriter.prototype.feed = function (input) {
            return new StringWriter(input, "" + input);
        };
        StringWriter.prototype.pull = function (output) {
            return StringWriter.write(output, this._value, this._input, this._index);
        };
        StringWriter.write = function (output, value, input, index) {
            if (index === void 0) { index = 0; }
            var length = input.length;
            while (index < length && output.isCont()) {
                var c = input.codePointAt(index);
                if (c === void 0) {
                    c = input.charCodeAt(index);
                }
                output = output.write(c);
                index = input.offsetByCodePoints(index, 1);
            }
            if (index === length) {
                return Writer.done(value);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new StringWriter(value, input, index);
        };
        return StringWriter;
    }(Writer));

    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.stringInput = function (string) {
            return new StringInput(string);
        };
        Unicode.stringOutput = function (string, settings) {
            if (settings === void 0 && typeof string !== "string") {
                settings = string;
                string = "";
            }
            else if (typeof string !== "string") {
                string = "";
            }
            settings = OutputSettings.fromAny(settings);
            return new StringOutput(string, settings);
        };
        Unicode.stringWriter = function (input) {
            if (input === void 0) {
                return new StringWriter(void 0, "");
            }
            else {
                return new StringWriter(input, "" + input);
            }
        };
        Unicode.writeString = function (input, output) {
            return StringWriter.write(output, void 0, "" + input);
        };
        Unicode.isAlpha = function (c) {
            return c >= 65 && c <= 90
                || c >= 97 && c <= 122;
        };
        Unicode.isSpace = function (c) {
            return c === 0x20 || c === 0x9;
        };
        Unicode.isNewline = function (c) {
            return c === 0xa || c === 0xd;
        };
        Unicode.isWhitespace = function (c) {
            return Unicode.isSpace(c) || Unicode.isNewline(c);
        };
        return Unicode;
    }());

    var Format = (function () {
        function Format() {
        }
        Format.display = function (object, output) {
            var notOutput = !(output instanceof Output);
            if (object === void 0) {
                if (output === void 0) {
                    return "undefined";
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("undefined");
                }
            }
            else if (object === null) {
                if (output === void 0) {
                    return "null";
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("null");
                }
            }
            else if (typeof object === "number") {
                if (output === void 0) {
                    return "" + object;
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    Format.displayNumber(object, output);
                }
            }
            else if (typeof object === "string") {
                if (output === void 0) {
                    return object;
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write(object);
                }
            }
            else if (object && typeof object.display === "function") {
                if (!(output instanceof Output)) {
                    output = Unicode.stringOutput(output);
                }
                object.display(output);
            }
            else {
                if (output === void 0) {
                    return "" + object;
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("" + object);
                }
            }
            if (notOutput) {
                return output.toString();
            }
        };
        Format.debug = function (object, output) {
            var notOutput = !(output instanceof Output);
            if (object === void 0) {
                if (output === void 0) {
                    return "undefined";
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("undefined");
                }
            }
            else if (object === null) {
                if (output === void 0) {
                    return "null";
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("null");
                }
            }
            else if (typeof object === "number") {
                if (output === void 0) {
                    return "" + object;
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    Format.debugNumber(object, output);
                }
            }
            else if (typeof object === "string") {
                if (!(output instanceof Output)) {
                    output = Unicode.stringOutput(output);
                }
                Format.debugString(object, output);
            }
            else if (typeof object.debug === "function") {
                if (!(output instanceof Output)) {
                    output = Unicode.stringOutput(output);
                }
                object.debug(output);
            }
            else {
                if (output === void 0) {
                    return "" + object;
                }
                else {
                    if (!(output instanceof Output)) {
                        output = Unicode.stringOutput(output);
                    }
                    output = output.write("" + object);
                }
            }
            if (notOutput) {
                return output.toString();
            }
        };
        Format.displayNumber = function (value, output) {
            if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
                if (value < 0) {
                    output = output.write(45);
                }
                if (value > -10 && value < 10) {
                    output = output.write(48 + Math.abs(value));
                }
                else {
                    var digits = new Array(19);
                    var x = value;
                    var i = 18;
                    while (x) {
                        digits[i] = Math.abs((x % 10) | 0);
                        x = (x / 10) | 0;
                        i -= 1;
                    }
                    i += 1;
                    while (i < 19) {
                        output = output.write(48 + digits[i]);
                        i += 1;
                    }
                }
            }
            else {
                output = output.write("" + value);
            }
        };
        Format.debugNumber = function (value, output) {
            Format.displayNumber(value, output);
        };
        Format.debugChar = function (character, output) {
            output = output.write(39);
            switch (character) {
                case 8:
                    output.write(92).write(98);
                    break;
                case 9:
                    output.write(92).write(116);
                    break;
                case 10:
                    output.write(92).write(110);
                    break;
                case 12:
                    output.write(92).write(102);
                    break;
                case 13:
                    output.write(92).write(114);
                    break;
                case 34:
                    output.write(92).write(34);
                    break;
                case 39:
                    output.write(92).write(39);
                    break;
                case 92:
                    output.write(92).write(92);
                    break;
                default:
                    if (character >= 0x0000 && character <= 0x001f
                        || character >= 0x007f && character <= 0x009f) {
                        output = output.write(92).write(117)
                            .write(Format.encodeHex(character >>> 12 & 0xf))
                            .write(Format.encodeHex(character >>> 8 & 0xf))
                            .write(Format.encodeHex(character >>> 4 & 0xf))
                            .write(Format.encodeHex(character & 0xf));
                    }
                    else {
                        output = output.write(character);
                    }
            }
            output = output.write(39);
        };
        Format.debugString = function (string, output) {
            output = output.write(34);
            var input = Unicode.stringInput(string);
            while (input.isCont()) {
                var c = input.head();
                switch (c) {
                    case 8:
                        output.write(92).write(98);
                        break;
                    case 9:
                        output.write(92).write(116);
                        break;
                    case 10:
                        output.write(92).write(110);
                        break;
                    case 12:
                        output.write(92).write(102);
                        break;
                    case 13:
                        output.write(92).write(114);
                        break;
                    case 34:
                        output.write(92).write(34);
                        break;
                    case 92:
                        output.write(92).write(92);
                        break;
                    default:
                        if (c >= 0x0000 && c <= 0x001f || c >= 0x007f && c <= 0x009f) {
                            output = output.write(92).write(117)
                                .write(Format.encodeHex(c >>> 12 & 0xf))
                                .write(Format.encodeHex(c >>> 8 & 0xf))
                                .write(Format.encodeHex(c >>> 4 & 0xf))
                                .write(Format.encodeHex(c & 0xf));
                        }
                        else {
                            output = output.write(c);
                        }
                }
                input = input.step();
            }
            output = output.write(34);
        };
        Format.encodeHex = function (x) {
            if (x < 10) {
                return 48 + x;
            }
            else {
                return 65 + (x - 10);
            }
        };
        Format.lineSeparator = function () {
            if (!Format._lineSeparator) {
                if (typeof require === "function") {
                    var os = require("os");
                    if (os) {
                        Format._lineSeparator = os.EOL;
                    }
                }
                if (!Format._lineSeparator) {
                    Format._lineSeparator = "\n";
                }
            }
            return Format._lineSeparator;
        };
        return Format;
    }());
    Tag.Format = Format;

    var InputSettings = (function () {
        function InputSettings(isStripped) {
            this._isStrict = isStripped;
        }
        InputSettings.prototype.isStripped = function (isStripped) {
            if (isStripped === void 0) {
                return this._isStrict;
            }
            else {
                return this.copy(isStripped);
            }
        };
        InputSettings.prototype.copy = function (isStripped) {
            return InputSettings.create(isStripped);
        };
        InputSettings.prototype.canEqual = function (that) {
            return that instanceof InputSettings;
        };
        InputSettings.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof InputSettings) {
                return that.canEqual(this) && this._isStrict === that._isStrict;
            }
            return false;
        };
        InputSettings.prototype.hashCode = function () {
            if (InputSettings._hashSeed === void 0) {
                InputSettings._hashSeed = Murmur3.seed(InputSettings);
            }
            return Murmur3.mash(Murmur3.mix(InputSettings._hashSeed, Murmur3.hash(this._isStrict)));
        };
        InputSettings.prototype.debug = function (output) {
            output = output.write("InputSettings").write(46);
            if (!this._isStrict) {
                output = output.write("standard");
            }
            else {
                output = output.write("stripped");
            }
            output = output.write(40).write(41);
        };
        InputSettings.prototype.toString = function () {
            return Format.debug(this);
        };
        InputSettings.standard = function () {
            if (!InputSettings._standard) {
                InputSettings._standard = new InputSettings(false);
            }
            return InputSettings._standard;
        };
        InputSettings.stripped = function () {
            if (!InputSettings._stripped) {
                InputSettings._stripped = new InputSettings(false);
            }
            return InputSettings._stripped;
        };
        InputSettings.create = function (isStripped) {
            if (isStripped) {
                return InputSettings.stripped();
            }
            return InputSettings.standard();
        };
        InputSettings.fromAny = function (settings) {
            if (settings instanceof InputSettings) {
                return settings;
            }
            else if (typeof settings === "object" && settings) {
                return InputSettings.create(settings.isStripped);
            }
            else {
                return InputSettings.standard();
            }
        };
        return InputSettings;
    }());

    var InputBuffer = (function (_super) {
        __extends(InputBuffer, _super);
        function InputBuffer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InputBuffer.empty = function (id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {
                if (!InputBuffer._emptyBuffer) {
                    InputBuffer._emptyBuffer = new InputBufferEmpty(null, Mark.zero(), InputSettings.standard());
                }
                return InputBuffer._emptyBuffer;
            }
            return new InputBufferEmpty(id, mark, settings);
        };
        InputBuffer.done = function (id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {
                if (!InputBuffer._doneBuffer) {
                    InputBuffer._doneBuffer = new InputBufferDone(null, Mark.zero(), InputSettings.standard());
                }
                return InputBuffer._doneBuffer;
            }
            return new InputBufferDone(id, mark, settings);
        };
        InputBuffer.error = function (error, id, mark, settings) {
            if (id === void 0) { id = null; }
            if (mark === void 0) { mark = Mark.zero(); }
            if (settings === void 0) { settings = InputSettings.standard(); }
            return new InputBufferError(error, id, mark, settings);
        };
        return InputBuffer;
    }(Input));
    var InputBufferEmpty = (function (_super) {
        __extends(InputBufferEmpty, _super);
        function InputBufferEmpty(id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputBufferEmpty.prototype.isCont = function () {
            return false;
        };
        InputBufferEmpty.prototype.isEmpty = function () {
            return true;
        };
        InputBufferEmpty.prototype.isDone = function () {
            return false;
        };
        InputBufferEmpty.prototype.isError = function () {
            return false;
        };
        InputBufferEmpty.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return true;
            }
            else if (isPart) {
                return this;
            }
            else {
                return InputBuffer.done(this._id, this._mark, this._settings);
            }
        };
        InputBufferEmpty.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid index");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferEmpty.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid limit");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferEmpty.prototype.capacity = function () {
            return 0;
        };
        InputBufferEmpty.prototype.remaining = function () {
            return 0;
        };
        InputBufferEmpty.prototype.has = function (index) {
            return false;
        };
        InputBufferEmpty.prototype.get = function (index) {
            throw new InputException();
        };
        InputBufferEmpty.prototype.set = function (index, token) {
            throw new InputException();
        };
        InputBufferEmpty.prototype.head = function () {
            throw new InputException();
        };
        InputBufferEmpty.prototype.step = function (offset) {
            var error = new InputException("empty step");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferEmpty.prototype.seek = function (mark) {
            var error = new InputException("empty seek");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferEmpty.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return InputBuffer.empty(id, this._mark, this._settings);
            }
        };
        InputBufferEmpty.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return InputBuffer.empty(this._id, mark, this._settings);
            }
        };
        InputBufferEmpty.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return InputBuffer.empty(this._id, this._mark, settings);
            }
        };
        InputBufferEmpty.prototype.clone = function () {
            return this;
        };
        return InputBufferEmpty;
    }(InputBuffer));
    var InputBufferDone = (function (_super) {
        __extends(InputBufferDone, _super);
        function InputBufferDone(id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputBufferDone.prototype.isCont = function () {
            return false;
        };
        InputBufferDone.prototype.isEmpty = function () {
            return false;
        };
        InputBufferDone.prototype.isDone = function () {
            return true;
        };
        InputBufferDone.prototype.isError = function () {
            return false;
        };
        InputBufferDone.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else if (isPart) {
                return InputBuffer.empty(this._id, this._mark, this._settings);
            }
            else {
                return this;
            }
        };
        InputBufferDone.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid index");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferDone.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid limit");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferDone.prototype.capacity = function () {
            return 0;
        };
        InputBufferDone.prototype.remaining = function () {
            return 0;
        };
        InputBufferDone.prototype.has = function (index) {
            return false;
        };
        InputBufferDone.prototype.get = function (index) {
            throw new InputException();
        };
        InputBufferDone.prototype.set = function (index, token) {
            throw new InputException();
        };
        InputBufferDone.prototype.head = function () {
            throw new InputException();
        };
        InputBufferDone.prototype.step = function (offset) {
            var error = new InputException("done step");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferDone.prototype.seek = function (mark) {
            var error = new InputException("done seek");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferDone.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return InputBuffer.done(id, this._mark, this._settings);
            }
        };
        InputBufferDone.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return InputBuffer.done(this._id, mark, this._settings);
            }
        };
        InputBufferDone.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return InputBuffer.done(this._id, this._mark, settings);
            }
        };
        InputBufferDone.prototype.clone = function () {
            return this;
        };
        return InputBufferDone;
    }(InputBuffer));
    var InputBufferError = (function (_super) {
        __extends(InputBufferError, _super);
        function InputBufferError(error, id, mark, settings) {
            var _this = _super.call(this) || this;
            _this._error = error;
            _this._id = id;
            _this._mark = mark;
            _this._settings = settings;
            return _this;
        }
        InputBufferError.prototype.isCont = function () {
            return false;
        };
        InputBufferError.prototype.isEmpty = function () {
            return false;
        };
        InputBufferError.prototype.isDone = function () {
            return false;
        };
        InputBufferError.prototype.isError = function () {
            return true;
        };
        InputBufferError.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        InputBufferError.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid index");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferError.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                var error = new InputException("invalid limit");
                return InputBuffer.error(error, this._id, this._mark, this._settings);
            }
        };
        InputBufferError.prototype.capacity = function () {
            return 0;
        };
        InputBufferError.prototype.remaining = function () {
            return 0;
        };
        InputBufferError.prototype.has = function (index) {
            return false;
        };
        InputBufferError.prototype.get = function (index) {
            throw new InputException();
        };
        InputBufferError.prototype.set = function (index, token) {
            throw new InputException();
        };
        InputBufferError.prototype.head = function () {
            throw new InputException();
        };
        InputBufferError.prototype.step = function (offset) {
            var error = new InputException("error step");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferError.prototype.trap = function () {
            return this._error;
        };
        InputBufferError.prototype.seek = function (mark) {
            var error = new InputException("error seek");
            return InputBuffer.error(error, this._id, this._mark, this._settings);
        };
        InputBufferError.prototype.id = function (id) {
            if (id === void 0) {
                return this._id;
            }
            else {
                return InputBuffer.error(this._error, id, this._mark, this._settings);
            }
        };
        InputBufferError.prototype.mark = function (mark) {
            if (mark === void 0) {
                return this._mark;
            }
            else {
                return InputBuffer.error(this._error, this._id, mark, this._settings);
            }
        };
        InputBufferError.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return InputBuffer.error(this._error, this._id, this._mark, settings);
            }
        };
        InputBufferError.prototype.clone = function () {
            return this;
        };
        return InputBufferError;
    }(InputBuffer));

    var OutputBuffer = (function (_super) {
        __extends(OutputBuffer, _super);
        function OutputBuffer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OutputBuffer.prototype.writeln = function (string) {
            if (typeof string === "string") {
                this.write(string);
            }
            return this.write(this.settings().lineSeparator());
        };
        OutputBuffer.prototype.display = function (object) {
            Format.display(object, this);
            return this;
        };
        OutputBuffer.prototype.debug = function (object) {
            Format.debug(object, this);
            return this;
        };
        OutputBuffer.prototype.flush = function () {
            return this;
        };
        OutputBuffer.prototype.clone = function () {
            throw new Error();
        };
        OutputBuffer.full = function (value, settings) {
            if (value === void 0) { value = null; }
            if (settings === void 0) { settings = OutputSettings.standard(); }
            if (value === null && settings === OutputSettings.standard()) {
                if (!OutputBuffer._fullBuffer) {
                    OutputBuffer._fullBuffer = new OutputBufferFull(value, OutputSettings.standard());
                }
                return OutputBuffer._fullBuffer;
            }
            return new OutputBufferFull(value, settings);
        };
        OutputBuffer.done = function (value, settings) {
            if (value === void 0) { value = null; }
            if (settings === void 0) { settings = OutputSettings.standard(); }
            if (value === null && settings === OutputSettings.standard()) {
                if (!OutputBuffer._doneBuffer) {
                    OutputBuffer._doneBuffer = new OutputBufferDone(value, OutputSettings.standard());
                }
                return OutputBuffer._doneBuffer;
            }
            return new OutputBufferDone(value, settings);
        };
        OutputBuffer.error = function (error, settings) {
            if (settings === void 0) { settings = OutputSettings.standard(); }
            return new OutputBufferError(error, settings);
        };
        return OutputBuffer;
    }(Output));
    var OutputBufferFull = (function (_super) {
        __extends(OutputBufferFull, _super);
        function OutputBufferFull(value, settings) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._settings = settings;
            return _this;
        }
        OutputBufferFull.prototype.isCont = function () {
            return false;
        };
        OutputBufferFull.prototype.isFull = function () {
            return true;
        };
        OutputBufferFull.prototype.isDone = function () {
            return false;
        };
        OutputBufferFull.prototype.isError = function () {
            return false;
        };
        OutputBufferFull.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return true;
            }
            else if (isPart) {
                return OutputBuffer.done(this._value, this._settings);
            }
            else {
                return this;
            }
        };
        OutputBufferFull.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferFull.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferFull.prototype.capacity = function () {
            return 0;
        };
        OutputBufferFull.prototype.remaining = function () {
            return 0;
        };
        OutputBufferFull.prototype.has = function (index) {
            return false;
        };
        OutputBufferFull.prototype.get = function (index) {
            throw new OutputException();
        };
        OutputBufferFull.prototype.set = function (index, token) {
            throw new OutputException();
        };
        OutputBufferFull.prototype.write = function (tokenOrString) {
            return OutputBuffer.error(new OutputException("full"), this._settings);
        };
        OutputBufferFull.prototype.writeln = function (string) {
            return OutputBuffer.error(new OutputException("full"), this._settings);
        };
        OutputBufferFull.prototype.step = function (offset) {
            if (offset === void 0) { offset = 1; }
            if (offset === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid step"), this._settings);
            }
        };
        OutputBufferFull.prototype.bind = function () {
            return this._value;
        };
        OutputBufferFull.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return OutputBuffer.full(this._value, settings);
            }
        };
        OutputBufferFull.prototype.clone = function () {
            return this;
        };
        return OutputBufferFull;
    }(OutputBuffer));
    var OutputBufferDone = (function (_super) {
        __extends(OutputBufferDone, _super);
        function OutputBufferDone(value, settings) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._settings = settings;
            return _this;
        }
        OutputBufferDone.prototype.isCont = function () {
            return false;
        };
        OutputBufferDone.prototype.isFull = function () {
            return false;
        };
        OutputBufferDone.prototype.isDone = function () {
            return true;
        };
        OutputBufferDone.prototype.isError = function () {
            return false;
        };
        OutputBufferDone.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else if (isPart) {
                return this;
            }
            else {
                return OutputBuffer.full(this._value, this._settings);
            }
        };
        OutputBufferDone.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferDone.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferDone.prototype.capacity = function () {
            return 0;
        };
        OutputBufferDone.prototype.remaining = function () {
            return 0;
        };
        OutputBufferDone.prototype.has = function (index) {
            return false;
        };
        OutputBufferDone.prototype.get = function (index) {
            throw new OutputException();
        };
        OutputBufferDone.prototype.set = function (index, token) {
            throw new OutputException();
        };
        OutputBufferDone.prototype.write = function (tokenOrString) {
            return OutputBuffer.error(new OutputException("done"), this._settings);
        };
        OutputBufferDone.prototype.writeln = function (string) {
            return OutputBuffer.error(new OutputException("done"), this._settings);
        };
        OutputBufferDone.prototype.step = function (offset) {
            if (offset === void 0) { offset = 1; }
            if (offset === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid step"), this._settings);
            }
        };
        OutputBufferDone.prototype.bind = function () {
            return this._value;
        };
        OutputBufferDone.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return OutputBuffer.done(this._value, settings);
            }
        };
        OutputBufferDone.prototype.clone = function () {
            return this;
        };
        return OutputBufferDone;
    }(OutputBuffer));
    var OutputBufferError = (function (_super) {
        __extends(OutputBufferError, _super);
        function OutputBufferError(error, settings) {
            var _this = _super.call(this) || this;
            _this._error = error;
            _this._settings = settings;
            return _this;
        }
        OutputBufferError.prototype.isCont = function () {
            return false;
        };
        OutputBufferError.prototype.isFull = function () {
            return false;
        };
        OutputBufferError.prototype.isDone = function () {
            return false;
        };
        OutputBufferError.prototype.isError = function () {
            return true;
        };
        OutputBufferError.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        OutputBufferError.prototype.index = function (index) {
            if (index === void 0) {
                return 0;
            }
            else if (index === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferError.prototype.limit = function (limit) {
            if (limit === void 0) {
                return 0;
            }
            else if (limit === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        OutputBufferError.prototype.capacity = function () {
            return 0;
        };
        OutputBufferError.prototype.remaining = function () {
            return 0;
        };
        OutputBufferError.prototype.has = function (index) {
            return false;
        };
        OutputBufferError.prototype.get = function (index) {
            throw new OutputException();
        };
        OutputBufferError.prototype.set = function (index, token) {
            throw new OutputException();
        };
        OutputBufferError.prototype.write = function (tokenOrString) {
            return this;
        };
        OutputBufferError.prototype.writeln = function (string) {
            return this;
        };
        OutputBufferError.prototype.step = function (offset) {
            if (offset === void 0) { offset = 1; }
            if (offset === 0) {
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid step"), this._settings);
            }
        };
        OutputBufferError.prototype.bind = function () {
            throw new OutputException();
        };
        OutputBufferError.prototype.trap = function () {
            return this._error;
        };
        OutputBufferError.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                return OutputBuffer.error(this._error, settings);
            }
        };
        OutputBufferError.prototype.clone = function () {
            return this;
        };
        return OutputBufferError;
    }(OutputBuffer));

    var OutputStyle = (function () {
        function OutputStyle() {
        }
        OutputStyle.reset = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(109);
            }
        };
        OutputStyle.bold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(109);
            }
        };
        OutputStyle.faint = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(50).write(109);
            }
        };
        OutputStyle.black = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(48).write(109);
            }
        };
        OutputStyle.red = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(49).write(109);
            }
        };
        OutputStyle.green = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(50).write(109);
            }
        };
        OutputStyle.yellow = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(51).write(109);
            }
        };
        OutputStyle.blue = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(52).write(109);
            }
        };
        OutputStyle.magenta = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(53).write(109);
            }
        };
        OutputStyle.cyan = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(54).write(109);
            }
        };
        OutputStyle.gray = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(48).write(59)
                    .write(51).write(55).write(109);
            }
        };
        OutputStyle.blackBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(48).write(109);
            }
        };
        OutputStyle.redBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(49).write(109);
            }
        };
        OutputStyle.greenBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(50).write(109);
            }
        };
        OutputStyle.yellowBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(51).write(109);
            }
        };
        OutputStyle.blueBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(52).write(109);
            }
        };
        OutputStyle.magentaBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(53).write(109);
            }
        };
        OutputStyle.cyanBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(54).write(109);
            }
        };
        OutputStyle.grayBold = function (output) {
            if (output.settings().isStyled()) {
                output = output.write(27).write(91).write(49).write(59)
                    .write(51).write(55).write(109);
            }
        };
        return OutputStyle;
    }());

    var Base10 = (function () {
        function Base10() {
        }
        Base10.isDigit = function (c) {
            return c >= 48 && c <= 57;
        };
        Base10.decodeDigit = function (c) {
            if (c >= 48 && c <= 57) {
                return c - 48;
            }
            else {
                var message = Unicode.stringOutput();
                message.write("Invalid base-10 digit: ");
                Format.debugChar(c, message);
                throw new Error(message.bind());
            }
        };
        Base10.encodeDigit = function (b) {
            if (b >= 0 && b <= 9) {
                return 48 + b;
            }
            else {
                throw new Error("" + b);
            }
        };
        Base10.countDigits = function (value) {
            var size = 0;
            do {
                size += 1;
                value = (value / 10) | 0;
            } while (value);
            return size;
        };
        Base10.integerParser = function () {
            return new Base10.NumberParser(void 0, void 0, 0);
        };
        Base10.parseInteger = function (input) {
            return Base10.NumberParser.parse(input, void 0, void 0, 0);
        };
        Base10.decimalParser = function () {
            return new Base10.NumberParser(void 0, void 0, 1);
        };
        Base10.parseDecimal = function (input) {
            return Base10.NumberParser.parse(input, void 0, void 0, 1);
        };
        Base10.numberParser = function () {
            return new Base10.NumberParser();
        };
        Base10.parseNumber = function (input) {
            return Base10.NumberParser.parse(input);
        };
        Base10.integerWriter = function (input) {
            if (input === void 0) {
                return new Base10.IntegerWriter(void 0, 0);
            }
            else {
                return new Base10.IntegerWriter(void 0, input);
            }
        };
        Base10.writeInteger = function (input, output) {
            return Base10.IntegerWriter.write(output, void 0, input);
        };
        return Base10;
    }());

    var Diagnostic = (function () {
        function Diagnostic(input, tag, severity, message, note, cause) {
            this._input = input;
            this._tag = tag;
            this._severity = severity;
            this._message = message;
            this._note = note;
            this._cause = cause;
        }
        Diagnostic.prototype.input = function () {
            return this._input.clone();
        };
        Diagnostic.prototype.tag = function () {
            return this._tag;
        };
        Diagnostic.prototype.severity = function () {
            return this._severity;
        };
        Diagnostic.prototype.message = function () {
            return this._message;
        };
        Diagnostic.prototype.note = function () {
            return this._note;
        };
        Diagnostic.prototype.cause = function () {
            return this._cause;
        };
        Diagnostic.prototype.lineDigits = function () {
            var digits = Base10.countDigits(this._tag.end().line());
            if (this._cause !== null) {
                digits = Math.max(digits, this._cause.lineDigits());
            }
            return digits;
        };
        Diagnostic.prototype.display = function (output) {
            var input = this._input.clone();
            var start = this._tag.start();
            var end = this._tag.end();
            var severity = this._severity;
            var message = this._message;
            var note = this._note;
            var cause = this._cause;
            var contextLines = 2;
            var lineDigits = this.lineDigits();
            Diagnostic.displayDiagnostic(input, start, end, severity, message, note, cause, contextLines, lineDigits, output);
        };
        Diagnostic.prototype.toString = function (settings) {
            return Format.display(this, settings);
        };
        Diagnostic.from = function (input, tag, severity, message, note, cause) {
            if (message instanceof Diagnostic) {
                cause = message;
                note = null;
                message = null;
            }
            else if (note instanceof Diagnostic) {
                cause = note;
                note = null;
            }
            input = input.clone();
            if (message === void 0) {
                message = null;
            }
            if (note === void 0) {
                note = null;
            }
            if (cause === void 0) {
                cause = null;
            }
            return new Diagnostic(input, tag, severity, message, note, cause);
        };
        Diagnostic.message = function (message, input, severity, note, cause) {
            if (severity === null || severity instanceof Diagnostic) {
                cause = severity;
                severity = void 0;
            }
            else if (typeof severity === "string") {
                note = severity;
                severity = void 0;
            }
            if (note === null || note instanceof Diagnostic) {
                cause = note;
                note = void 0;
            }
            if (note === void 0) {
                note = null;
            }
            if (severity === void 0) {
                severity = Severity.error();
            }
            var mark = input.mark();
            var source = input.clone();
            source.seek();
            return Diagnostic.from(source, mark, severity, message, note, cause);
        };
        Diagnostic.unexpected = function (input, severity, note, cause) {
            if (severity === null || severity instanceof Diagnostic) {
                cause = severity;
                severity = void 0;
            }
            else if (typeof severity === "string") {
                note = severity;
                severity = void 0;
            }
            if (note === null || note instanceof Diagnostic) {
                cause = note;
                note = void 0;
            }
            if (note === void 0) {
                note = null;
            }
            if (severity === void 0) {
                severity = Severity.error();
            }
            var message;
            if (input.isCont()) {
                var output = Unicode.stringOutput().write("unexpected").write(32);
                Format.debugChar(input.head(), output);
                message = output.bind();
            }
            else {
                message = "unexpected end of input";
            }
            var mark = input.mark();
            var source = input.clone();
            source.seek();
            return Diagnostic.from(source, mark, severity, message, note, cause);
        };
        Diagnostic.expected = function (expected, input, severity, note, cause) {
            if (severity === null || severity instanceof Diagnostic) {
                cause = severity;
                severity = void 0;
            }
            else if (typeof severity === "string") {
                note = severity;
                severity = void 0;
            }
            if (note === null || note instanceof Diagnostic) {
                cause = note;
                note = void 0;
            }
            if (note === void 0) {
                note = null;
            }
            if (severity === void 0) {
                severity = Severity.error();
            }
            var output = Unicode.stringOutput().write("expected").write(32);
            if (typeof expected === "number") {
                Format.debugChar(expected, output);
            }
            else {
                output = output.write(expected);
            }
            output = output.write(44).write(32).write("but found").write(32);
            if (input.isCont()) {
                Format.debugChar(input.head(), output);
            }
            else {
                output = output.write("end of input");
            }
            var message = output.bind();
            var mark = input.mark();
            var source = input.clone();
            source.seek();
            return Diagnostic.from(source, mark, severity, message, note, cause);
        };
        Diagnostic.displayDiagnostic = function (input, start, end, severity, message, note, cause, contextLines, lineDigits, output) {
            do {
                if (message !== null) {
                    Diagnostic.displayMessage(severity, message, output);
                    output = output.writeln();
                }
                Diagnostic.displayAnchor(input, start, lineDigits, output);
                output = output.writeln();
                var next = Diagnostic.displayContext(input, start, end, severity, note, cause, contextLines, lineDigits, output);
                if (next !== null) {
                    output = output.writeln();
                    input = next._input.clone();
                    start = next._tag.start();
                    end = next._tag.end();
                    severity = next._severity;
                    message = next._message;
                    note = next._note;
                    cause = next._cause;
                }
                else {
                    break;
                }
            } while (true);
        };
        Diagnostic.displayMessage = function (severity, message, output) {
            Diagnostic.formatSeverity(severity, output);
            output = output.write(severity.label());
            OutputStyle.reset(output);
            OutputStyle.bold(output);
            output = output.write(58);
            if (message !== null) {
                output = output.write(32).write(message);
            }
            OutputStyle.reset(output);
        };
        Diagnostic.displayAnchor = function (input, start, lineDigits, output) {
            Diagnostic.displayLineLeadArrow(lineDigits, output);
            output = output.write(32);
            var id = input.id();
            if (id !== null) {
                Format.display(id, output);
            }
            output = output.write(58);
            Format.displayNumber(start._line, output);
            output = output.write(58);
            Format.displayNumber(start._column, output);
            output = output.writeln();
            Diagnostic.displayLineLead(lineDigits, output);
        };
        Diagnostic.displayCause = function (cause, contextLines, lineDigits, output) {
            var input = cause._input.clone();
            var start = cause._tag.start();
            var end = cause._tag.end();
            var severity = cause._severity;
            var note = cause._note;
            var next = cause._cause;
            return Diagnostic.displayContext(input, start, end, severity, note, next, contextLines, lineDigits, output);
        };
        Diagnostic.displayContext = function (input, start, end, severity, note, cause, contextLines, lineDigits, output) {
            var next = cause;
            var sameCause = cause !== null && cause._message === null
                && Objects.equal(input.id(), cause._input.id());
            var causeOrder = sameCause ? (start._offset <= cause._tag.start()._offset ? -1 : 1) : 0;
            if (causeOrder === 1) {
                next = Diagnostic.displayCause(cause, contextLines, lineDigits, output);
                output = output.writeln();
                Diagnostic.displayLineLeadEllipsis(lineDigits, output);
                output = output.writeln();
            }
            Diagnostic.displayLines(input, start, end, severity, contextLines, lineDigits, output);
            if (note !== null) {
                Diagnostic.displayNote(note, lineDigits, output);
            }
            if (causeOrder === -1) {
                output = output.writeln();
                Diagnostic.displayLineLeadEllipsis(lineDigits, output);
                output = output.writeln();
                next = Diagnostic.displayCause(cause, contextLines, lineDigits, output);
            }
            return next;
        };
        Diagnostic.displayLines = function (input, start, end, severity, contextLines, lineDigits, output) {
            var startLine = start.line();
            var endLine = end.line();
            var line = input.line();
            while (line < startLine) {
                Diagnostic.consumeLineText(input, line);
                line += 1;
            }
            if (endLine - startLine > 2 * contextLines + 2) {
                while (line <= startLine + contextLines) {
                    Diagnostic.displayLine(input, start, end, severity, line, lineDigits, output);
                    line += 1;
                }
                Diagnostic.displayLineLeadEllipsis(lineDigits, output);
                output = output.write(32);
                Diagnostic.formatSeverity(severity, output);
                output = output.write(124);
                OutputStyle.reset(output);
                output = output.writeln();
                while (line < endLine - contextLines) {
                    Diagnostic.consumeLineText(input, line);
                    line += 1;
                }
            }
            while (line <= endLine) {
                Diagnostic.displayLine(input, start, end, severity, line, lineDigits, output);
                line += 1;
            }
        };
        Diagnostic.displayNote = function (note, lineDigits, output) {
            output = output.writeln();
            Diagnostic.displayLineLead(lineDigits, output);
            output = output.writeln();
            Diagnostic.displayLineComment('note', note, lineDigits, output);
        };
        Diagnostic.displayLine = function (input, start, end, severity, line, lineDigits, output) {
            if (start._line === line && end._line === line) {
                Diagnostic.displaySingleLine(input, start, end, severity, line, lineDigits, output);
            }
            else if (start._line === line) {
                Diagnostic.displayStartLine(input, start, severity, line, lineDigits, output);
            }
            else if (end._line === line) {
                Diagnostic.displayEndLine(input, end, severity, line, lineDigits, output);
            }
            else {
                Diagnostic.displayMidLine(input, severity, line, lineDigits, output);
            }
        };
        Diagnostic.displaySingleLine = function (input, start, end, severity, line, lineDigits, output) {
            Diagnostic.displayLineLeadNumber(line, lineDigits, output);
            output = output.write(32);
            for (var i_1 = 1; i_1 < input.column(); i_1 += 1) {
                output = output.write(32);
            }
            Diagnostic.displayLineText(input, line, output);
            Diagnostic.displayLineLead(lineDigits, output);
            output = output.write(32);
            var i = 1;
            while (i < start._column) {
                output = output.write(32);
                i += 1;
            }
            Diagnostic.formatSeverity(severity, output);
            while (i <= end._column) {
                output = output.write(94);
                i += 1;
            }
            if (end._note !== null) {
                output = output.write(32).write(end._note);
            }
            OutputStyle.reset(output);
        };
        Diagnostic.displayStartLine = function (input, start, severity, line, lineDigits, output) {
            Diagnostic.displayLineLeadNumber(line, lineDigits, output);
            output = output.write(32).write(32).write(32);
            for (var i_2 = 1; i_2 < input.column(); i_2 += 1) {
                output = output.write(32);
            }
            Diagnostic.displayLineText(input, line, output);
            Diagnostic.displayLineLead(lineDigits, output);
            output = output.write(32).write(32);
            Diagnostic.formatSeverity(severity, output);
            output = output.write(95);
            var i = 1;
            while (i < start._column) {
                output = output.write(95);
                i += 1;
            }
            output = output.write(94);
            if (start._note !== null) {
                output = output.write(32).write(start._note);
            }
            OutputStyle.reset(output);
            output = output.writeln();
        };
        Diagnostic.displayEndLine = function (input, end, severity, line, lineDigits, output) {
            Diagnostic.displayLineLeadNumber(line, lineDigits, output);
            output = output.write(32);
            Diagnostic.formatSeverity(severity, output);
            output = output.write(124);
            OutputStyle.reset(output);
            output = output.write(32);
            Diagnostic.displayLineText(input, line, output);
            Diagnostic.displayLineLead(lineDigits, output);
            output = output.write(32);
            Diagnostic.formatSeverity(severity, output);
            output = output.write(124).write(95);
            var i = 1;
            while (i < end._column) {
                output = output.write(95);
                i += 1;
            }
            output = output.write(94);
            if (end._note !== null) {
                output = output.write(32).write(end._note);
            }
            OutputStyle.reset(output);
        };
        Diagnostic.displayMidLine = function (input, severity, line, lineDigits, output) {
            Diagnostic.displayLineLeadNumber(line, lineDigits, output);
            output = output.write(32);
            Diagnostic.formatSeverity(severity, output);
            output = output.write(124);
            OutputStyle.reset(output);
            output = output.write(32);
            Diagnostic.displayLineText(input, line, output);
        };
        Diagnostic.displayLineComment = function (label, comment, lineDigits, output) {
            Diagnostic.displayLineLeadComment(lineDigits, output);
            output = output.write(32);
            OutputStyle.bold(output);
            output = output.write(label).write(58);
            OutputStyle.reset(output);
            if (comment != null) {
                output = output.write(32).write(comment);
            }
        };
        Diagnostic.displayLineLead = function (lineDigits, output) {
            OutputStyle.blueBold(output);
            var padding = 1 + lineDigits;
            for (var i = 0; i < padding; i += 1) {
                output = output.write(32);
            }
            output = output.write(124);
            OutputStyle.reset(output);
        };
        Diagnostic.displayLineLeadComment = function (lineDigits, output) {
            OutputStyle.blueBold(output);
            var padding = 1 + lineDigits;
            for (var i = 0; i < padding; i += 1) {
                output = output.write(32);
            }
            output = output.write(61);
            OutputStyle.reset(output);
        };
        Diagnostic.displayLineLeadArrow = function (lineDigits, output) {
            for (var i = 0; i < lineDigits; i += 1) {
                output = output.write(32);
            }
            OutputStyle.blueBold(output);
            output = output.write(45).write(45).write(62);
            OutputStyle.reset(output);
        };
        Diagnostic.displayLineLeadEllipsis = function (lineDigits, output) {
            OutputStyle.blueBold(output);
            for (var i = 0; i < lineDigits; i += 1) {
                output = output.write(46);
            }
            OutputStyle.reset(output);
            output = output.write(32).write(32);
        };
        Diagnostic.displayLineLeadNumber = function (line, lineDigits, output) {
            var padding = lineDigits - Base10.countDigits(line);
            for (var i = 0; i < padding; i += 1) {
                output = output.write(32);
            }
            OutputStyle.blueBold(output);
            Format.displayNumber(line, output);
            output = output.write(32).write(124);
            OutputStyle.reset(output);
        };
        Diagnostic.displayLineText = function (input, line, output) {
            while (input.isCont() && input.line() === line) {
                output = output.write(input.head());
                input = input.step();
            }
            if (input.line() === line) {
                output = output.writeln();
            }
        };
        Diagnostic.consumeLineText = function (input, line) {
            while (input.isCont() && input.line() === line) {
                input = input.step();
            }
        };
        Diagnostic.formatSeverity = function (severity, output) {
            switch (severity.level()) {
                case Severity.FATAL_LEVEL:
                case Severity.ALERT_LEVEL:
                case Severity.ERROR_LEVEL:
                    OutputStyle.redBold(output);
                    break;
                case Severity.WARNING_LEVEL:
                    OutputStyle.yellowBold(output);
                    break;
                case Severity.NOTE_LEVEL:
                    OutputStyle.greenBold(output);
                    break;
                case Severity.INFO_LEVEL:
                    OutputStyle.cyanBold(output);
                    break;
                case Severity.DEBUG_LEVEL:
                case Severity.TRACE_LEVEL:
                default:
                    OutputStyle.magentaBold(output);
            }
        };
        return Diagnostic;
    }());

    var ParserException = (function (_super) {
        __extends(ParserException, _super);
        function ParserException(message) {
            var _this = _super.call(this, message instanceof Diagnostic ? message.message() || void 0 : message) || this;
            if (message instanceof Diagnostic) {
                _this.diagnostic = message;
            }
            _this.__proto__ = ParserException.prototype;
            return _this;
        }
        ParserException.prototype.toString = function () {
            if (this.diagnostic) {
                return this.diagnostic.toString();
            }
            else {
                return _super.prototype.toString.call(this);
            }
        };
        return ParserException;
    }(Error));

    var Parser = (function () {
        function Parser() {
        }
        Parser.prototype.isCont = function () {
            return true;
        };
        Parser.prototype.isDone = function () {
            return false;
        };
        Parser.prototype.isError = function () {
            return false;
        };
        Parser.prototype.fork = function (condition) {
            return this;
        };
        Parser.prototype.bind = function () {
            throw new Error();
        };
        Parser.prototype.trap = function () {
            throw new Error();
        };
        Parser.prototype.asError = function () {
            throw new Error();
        };
        Parser.done = function (output) {
            if (output === void 0) {
                if (!Parser._done) {
                    Parser._done = new ParserDone(void 0);
                }
                return Parser._done;
            }
            else {
                return new ParserDone(output);
            }
        };
        Parser.error = function (error) {
            if (error instanceof Error) {
                return new ParserError(error);
            }
            else {
                return new ParserError(new ParserException(error));
            }
        };
        return Parser;
    }());
    var ParserDone = (function (_super) {
        __extends(ParserDone, _super);
        function ParserDone(output) {
            var _this = _super.call(this) || this;
            _this._output = output;
            return _this;
        }
        ParserDone.prototype.isCont = function () {
            return false;
        };
        ParserDone.prototype.isDone = function () {
            return true;
        };
        ParserDone.prototype.feed = function (input) {
            return this;
        };
        ParserDone.prototype.bind = function () {
            return this._output;
        };
        return ParserDone;
    }(Parser));
    var ParserError = (function (_super) {
        __extends(ParserError, _super);
        function ParserError(error) {
            var _this = _super.call(this) || this;
            _this._error = error;
            return _this;
        }
        ParserError.prototype.isCont = function () {
            return false;
        };
        ParserError.prototype.isError = function () {
            return true;
        };
        ParserError.prototype.feed = function (input) {
            return this;
        };
        ParserError.prototype.bind = function () {
            throw this._error;
        };
        ParserError.prototype.trap = function () {
            return this._error;
        };
        ParserError.prototype.asError = function () {
            return this;
        };
        return ParserError;
    }(Parser));

    var UtfErrorMode = (function () {
        function UtfErrorMode() {
        }
        UtfErrorMode.prototype.isFatal = function () {
            return false;
        };
        UtfErrorMode.prototype.isReplacement = function () {
            return false;
        };
        UtfErrorMode.prototype.replacementChar = function () {
            return 0xfffd;
        };
        UtfErrorMode.prototype.toString = function () {
            return Format.debug(this);
        };
        UtfErrorMode.fatal = function () {
            if (!UtfErrorMode._fatal) {
                UtfErrorMode._fatal = new UtfFatalErrorMode(false);
            }
            return UtfErrorMode._fatal;
        };
        UtfErrorMode.fatalNonZero = function () {
            if (!UtfErrorMode._fatalNonZero) {
                UtfErrorMode._fatalNonZero = new UtfFatalErrorMode(true);
            }
            return UtfErrorMode._fatalNonZero;
        };
        UtfErrorMode.replacement = function (replacementChar) {
            if (replacementChar === void 0 || replacementChar === 0xfffd) {
                if (!UtfErrorMode._replacement) {
                    UtfErrorMode._replacement = new UtfReplacementErrorMode(0xfffd, false);
                }
                return UtfErrorMode._replacement;
            }
            else {
                return new UtfReplacementErrorMode(replacementChar, false);
            }
        };
        UtfErrorMode.replacementNonZero = function (replacementChar) {
            if (replacementChar === void 0 || replacementChar === 0xfffd) {
                if (!UtfErrorMode._replacementNonZero) {
                    UtfErrorMode._replacementNonZero = new UtfReplacementErrorMode(0xfffd, true);
                }
                return UtfErrorMode._replacementNonZero;
            }
            else {
                return new UtfReplacementErrorMode(replacementChar, true);
            }
        };
        return UtfErrorMode;
    }());
    var UtfFatalErrorMode = (function (_super) {
        __extends(UtfFatalErrorMode, _super);
        function UtfFatalErrorMode(isNonZero) {
            var _this = _super.call(this) || this;
            _this._isNonZero = isNonZero;
            return _this;
        }
        UtfFatalErrorMode.prototype.isFatal = function () {
            return true;
        };
        UtfFatalErrorMode.prototype.isNonZero = function (isNonZero) {
            if (isNonZero === void 0) {
                return this._isNonZero;
            }
            else if (isNonZero) {
                return UtfErrorMode.fatalNonZero();
            }
            else {
                return UtfErrorMode.fatal();
            }
        };
        UtfFatalErrorMode.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UtfFatalErrorMode) {
                return this._isNonZero === that._isNonZero;
            }
            return false;
        };
        UtfFatalErrorMode.prototype.hashCode = function () {
            if (UtfFatalErrorMode._hashSeed === void 0) {
                UtfFatalErrorMode._hashSeed = Murmur3.seed(UtfFatalErrorMode);
            }
            return Murmur3.mash(Murmur3.mix(UtfFatalErrorMode._hashSeed, Murmur3.hash(this._isNonZero)));
        };
        UtfFatalErrorMode.prototype.debug = function (output) {
            output = output.write("UtfErrorMode").write(46)
                .write(this.isNonZero ? "fatalNonZero" : "fatal")
                .write(40).write(41);
        };
        return UtfFatalErrorMode;
    }(UtfErrorMode));
    var UtfReplacementErrorMode = (function (_super) {
        __extends(UtfReplacementErrorMode, _super);
        function UtfReplacementErrorMode(replacementChar, isNonZero) {
            var _this = _super.call(this) || this;
            _this._replacementChar = replacementChar;
            _this._isNonZero = isNonZero;
            return _this;
        }
        UtfReplacementErrorMode.prototype.isReplacement = function () {
            return true;
        };
        UtfReplacementErrorMode.prototype.replacementChar = function () {
            return this._replacementChar;
        };
        UtfReplacementErrorMode.prototype.isNonZero = function (isNonZero) {
            if (isNonZero === void 0) {
                return this._isNonZero;
            }
            else if (this._replacementChar === 0xfffd) {
                if (isNonZero) {
                    return UtfErrorMode.replacementNonZero();
                }
                else {
                    return UtfErrorMode.replacement();
                }
            }
            else {
                return new UtfReplacementErrorMode(this._replacementChar, isNonZero);
            }
        };
        UtfReplacementErrorMode.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UtfReplacementErrorMode) {
                return this.replacementChar === that.replacementChar
                    && this.isNonZero === that.isNonZero;
            }
            return false;
        };
        UtfReplacementErrorMode.prototype.hashCode = function () {
            if (UtfReplacementErrorMode._hashSeed === void 0) {
                UtfReplacementErrorMode._hashSeed = Murmur3.seed(UtfReplacementErrorMode);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(UtfReplacementErrorMode._hashSeed, this._replacementChar), Murmur3.hash(this._isNonZero)));
        };
        UtfReplacementErrorMode.prototype.debug = function (output) {
            output = output.write("UtfErrorMode").write(46)
                .write(this._isNonZero ? "replacementNonZero" : "replacement")
                .write(40);
            if (this._replacementChar !== 0xfffd) {
                Format.debugChar(this._replacementChar, output);
            }
            output = output.write(41);
        };
        return UtfReplacementErrorMode;
    }(UtfErrorMode));

    var Uint8ArrayOutput = (function (_super) {
        __extends(Uint8ArrayOutput, _super);
        function Uint8ArrayOutput(array, index, limit, settings, isPart) {
            if (settings === void 0) { settings = OutputSettings.standard(); }
            if (isPart === void 0) { isPart = false; }
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._index = index;
            _this._limit = limit;
            _this._settings = settings;
            _this._isPart = isPart;
            return _this;
        }
        Uint8ArrayOutput.prototype.isCont = function () {
            return this._index < this._limit;
        };
        Uint8ArrayOutput.prototype.isFull = function () {
            return this._isPart && this._index >= this._limit;
        };
        Uint8ArrayOutput.prototype.isDone = function () {
            return !this._isPart && this._index >= this._limit;
        };
        Uint8ArrayOutput.prototype.isError = function () {
            return false;
        };
        Uint8ArrayOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return this._isPart;
            }
            else {
                this._isPart = isPart;
                return this;
            }
        };
        Uint8ArrayOutput.prototype.index = function (index) {
            if (index === void 0) {
                return this._index;
            }
            else if (0 <= index && index <= this._limit) {
                this._index = index;
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid index"), this._settings);
            }
        };
        Uint8ArrayOutput.prototype.limit = function (limit) {
            if (limit === void 0) {
                return this._limit;
            }
            else if (0 <= limit && limit <= this._array.length) {
                this._limit = limit;
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid limit"), this._settings);
            }
        };
        Uint8ArrayOutput.prototype.capacity = function () {
            return this._array.length;
        };
        Uint8ArrayOutput.prototype.remaining = function () {
            return this._limit - this._index;
        };
        Uint8ArrayOutput.prototype.has = function (index) {
            return 0 <= index && index < this._limit;
        };
        Uint8ArrayOutput.prototype.get = function (index) {
            if (0 <= index && index < this._limit) {
                return this._array[index];
            }
            else {
                throw new OutputException();
            }
        };
        Uint8ArrayOutput.prototype.set = function (index, token) {
            if (0 <= index && index < this._limit) {
                this._array[index] = token;
            }
            else {
                throw new OutputException();
            }
        };
        Uint8ArrayOutput.prototype.write = function (token) {
            if (typeof token === "number") {
                var index = this._index;
                if (index < this._limit) {
                    this._array[index] = token;
                    this._index = index + 1;
                    return this;
                }
                else {
                    return OutputBuffer.error(new OutputException("full"), this._settings);
                }
            }
            else {
                return OutputBuffer.error(new OutputException("binary output"), this._settings);
            }
        };
        Uint8ArrayOutput.prototype.writeln = function (string) {
            return OutputBuffer.error(new OutputException("binary output"), this._settings);
        };
        Uint8ArrayOutput.prototype.step = function (offset) {
            var index = this._index + offset;
            if (0 <= index && index <= this._limit) {
                this._index = index;
                return this;
            }
            else {
                return OutputBuffer.error(new OutputException("invalid step"), this._settings);
            }
        };
        Uint8ArrayOutput.prototype.bind = function () {
            return new Uint8Array(this._array.buffer, 0, this._index);
        };
        Uint8ArrayOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = OutputSettings.fromAny(settings);
                return this;
            }
        };
        Uint8ArrayOutput.prototype.clone = function () {
            return new Uint8ArrayOutput(this._array, this._index, this._limit, this._settings, this._isPart);
        };
        return Uint8ArrayOutput;
    }(OutputBuffer));

    var ByteOutput = (function (_super) {
        __extends(ByteOutput, _super);
        function ByteOutput(array, size, settings) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._size = size;
            _this._settings = settings;
            return _this;
        }
        ByteOutput.prototype.isCont = function () {
            return true;
        };
        ByteOutput.prototype.isFull = function () {
            return false;
        };
        ByteOutput.prototype.isDone = function () {
            return false;
        };
        ByteOutput.prototype.isError = function () {
            return false;
        };
        ByteOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        ByteOutput.prototype.write = function (b) {
            if (typeof b === "number") {
                var n = this._size;
                var oldArray = this._array;
                var newArray = void 0;
                if (oldArray === null || n + 1 > oldArray.length) {
                    newArray = new Uint8Array(ByteOutput.expand(n + 1));
                    if (oldArray !== null) {
                        newArray.set(oldArray, 0);
                    }
                    this._array = newArray;
                }
                else {
                    newArray = oldArray;
                }
                newArray[n] = b;
                this._size = n + 1;
                return this;
            }
            else {
                throw new TypeError("" + b);
            }
        };
        ByteOutput.prototype.writeln = function (string) {
            throw new TypeError("" + string);
        };
        ByteOutput.prototype.toUint8Array = function () {
            var n = this._size;
            var oldArray = this._array;
            if (oldArray !== null && n === oldArray.length) {
                return oldArray;
            }
            else {
                var newArray = new Uint8Array(n);
                if (oldArray !== null) {
                    newArray.set(oldArray.slice(0, n), 0);
                }
                this._array = newArray;
                return newArray;
            }
        };
        ByteOutput.prototype.cloneArray = function () {
            var oldArray = this._array;
            if (oldArray !== null) {
                return oldArray.slice(0, this._size);
            }
            else {
                return null;
            }
        };
        ByteOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = OutputSettings.fromAny(settings);
                return this;
            }
        };
        ByteOutput.expand = function (n) {
            n = Math.max(32, n) - 1;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        };
        return ByteOutput;
    }(Output));

    var ByteOutputUint8Array = (function (_super) {
        __extends(ByteOutputUint8Array, _super);
        function ByteOutputUint8Array(array, size, settings) {
            return _super.call(this, array, size, settings) || this;
        }
        ByteOutputUint8Array.prototype.bind = function () {
            return this.toUint8Array();
        };
        ByteOutputUint8Array.prototype.clone = function () {
            return new ByteOutputUint8Array(this.cloneArray(), this._size, this._settings);
        };
        return ByteOutputUint8Array;
    }(ByteOutput));

    var Binary = (function () {
        function Binary() {
        }
        Binary.outputBuffer = function (array, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = array.length; }
            return new Uint8ArrayOutput(array, offset, offset + length);
        };
        Binary.uint8ArrayOutput = function (initialCapacity, settings) {
            if (settings === void 0 && typeof initialCapacity !== "number") {
                settings = initialCapacity;
                initialCapacity = void 0;
            }
            else if (typeof initialCapacity !== "number") {
                initialCapacity = void 0;
            }
            var array;
            if (typeof initialCapacity === "number") {
                array = new Uint8Array(initialCapacity);
            }
            else {
                array = null;
            }
            settings = OutputSettings.fromAny(settings);
            return new ByteOutputUint8Array(array, 0, settings);
        };
        return Binary;
    }());

    var Base16 = (function () {
        function Base16(alphabet) {
            this._alphabet = alphabet;
        }
        Base16.prototype.alphabet = function () {
            return this._alphabet;
        };
        Base16.prototype.encodeDigit = function (b) {
            return this._alphabet.charCodeAt(b);
        };
        Base16.prototype.uint8ArrayWriter = function (input) {
            if (input === void 0) {
                return new Base16.Writer(void 0, void 0, this);
            }
            else {
                return new Base16.Writer(input, input, this);
            }
        };
        Base16.prototype.writeUint8Array = function (input, output) {
            return Base16.Writer.write(output, void 0, input, this);
        };
        Base16.prototype.writeInteger = function (input, output, width) {
            if (width === void 0) { width = 0; }
            return Base16.IntegerWriter.write(output, void 0, input, width, this);
        };
        Base16.prototype.writeIntegerLiteral = function (input, output, width) {
            if (width === void 0) { width = 0; }
            return Base16.IntegerWriter.writeLiteral(output, void 0, input, width, this);
        };
        Base16.lowercase = function () {
            if (!Base16._lowercase) {
                Base16._lowercase = new Base16("0123456789abcdef");
            }
            return Base16._lowercase;
        };
        Base16.uppercase = function () {
            if (!Base16._uppercase) {
                Base16._uppercase = new Base16("0123456789ABCDEF");
            }
            return Base16._uppercase;
        };
        Base16.isDigit = function (c) {
            return c >= 48 && c <= 57
                || c >= 65 && c <= 70
                || c >= 97 && c <= 102;
        };
        Base16.decodeDigit = function (c) {
            if (c >= 48 && c <= 57) {
                return c - 48;
            }
            else if (c >= 65 && c <= 70) {
                return 10 + (c - 65);
            }
            else if (c >= 97 && c <= 102) {
                return 10 + (c - 97);
            }
            else {
                var message = Unicode.stringOutput();
                message.write("Invalid base-16 digit: ");
                Format.debugChar(c, message);
                throw new Error(message.bind());
            }
        };
        Base16.writeQuantum = function (c1, c2, output) {
            var x = Base16.decodeDigit(c1);
            var y = Base16.decodeDigit(c2);
            output = output.write(x << 4 | y);
        };
        Base16.parser = function (output) {
            return new Base16.Parser(output);
        };
        Base16.parse = function (input, output) {
            return Base16.Parser.parse(input, output);
        };
        Base16.parseUint8Array = function (input) {
            return Base16.Parser.parse(input, Binary.uint8ArrayOutput());
        };
        return Base16;
    }());

    var Utf8DecodedOutput = (function (_super) {
        __extends(Utf8DecodedOutput, _super);
        function Utf8DecodedOutput(output, errorMode, c1, c2, c3, have) {
            if (c1 === void 0) { c1 = -1; }
            if (c2 === void 0) { c2 = -1; }
            if (c3 === void 0) { c3 = -1; }
            if (have === void 0) { have = 0; }
            var _this = _super.call(this) || this;
            _this._output = output;
            _this._errorMode = errorMode;
            _this._c1 = c1;
            _this._c2 = c2;
            _this._c3 = c3;
            _this._have = have;
            return _this;
        }
        Utf8DecodedOutput.prototype.isCont = function () {
            return this._output.isCont();
        };
        Utf8DecodedOutput.prototype.isFull = function () {
            return this._output.isFull();
        };
        Utf8DecodedOutput.prototype.isDone = function () {
            return this._output.isDone();
        };
        Utf8DecodedOutput.prototype.isError = function () {
            return this._output.isError();
        };
        Utf8DecodedOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return this._output.isPart();
            }
            else {
                this._output = this._output.isPart(isPart);
                return this;
            }
        };
        Utf8DecodedOutput.prototype.write = function (token) {
            if (typeof token === "number") {
                var c1 = this._c1;
                var c2 = this._c2;
                var c3 = this._c3;
                var c4 = -1;
                var have = this._have;
                if (token >= 0) {
                    switch (have) {
                        case 0:
                            c1 = token & 0xff;
                            have = 1;
                            break;
                        case 1:
                            c2 = token & 0xff;
                            have = 2;
                            break;
                        case 2:
                            c3 = token & 0xff;
                            have = 3;
                            break;
                        case 3:
                            c4 = token & 0xff;
                            have = 4;
                            break;
                        default:
                            throw new Error("unreachable");
                    }
                }
                if (c1 === 0 && this._errorMode.isNonZero()) {
                    return Output.error(new OutputException("unexpected NUL byte"));
                }
                else if (c1 >= 0 && c1 <= 0x7f) {
                    this._output = this._output.write(c1);
                    this._have = 0;
                }
                else if (c1 >= 0xc2 && c1 <= 0xf4) {
                    if (c1 >= 0xc2 && c1 <= 0xdf && c2 >= 0x80 && c2 <= 0xbf) {
                        this._output = this._output.write((c1 & 0x1f) << 6 | c2 & 0x3f);
                        this._c1 = -1;
                        this._have = 0;
                    }
                    else if (c1 === 0xe0 && c2 >= 0xa0 && c2 <= 0xbf
                        || c1 >= 0xe1 && c1 <= 0xec && c2 >= 0x80 && c2 <= 0xbf
                        || c1 === 0xed && c2 >= 0x80 && c2 <= 0x9f
                        || c1 >= 0xee && c1 <= 0xef && c2 >= 0x80 && c2 <= 0xbf) {
                        if (c3 >= 0x80 && c3 <= 0xbf) {
                            this._output = this._output.write((c1 & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f);
                            this._c1 = -1;
                            this._c2 = -1;
                            this._have = 0;
                        }
                        else if (c3 >= 0) {
                            if (this._errorMode.isFatal()) {
                                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
                            }
                            this._output = this._output.write(this._errorMode.replacementChar());
                            this._c1 = c3;
                            this._c2 = -1;
                            this._have = 1;
                        }
                        else if (token < 0 || this._output.isDone()) {
                            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
                        }
                        else {
                            this._c2 = c2;
                            this._have = 2;
                        }
                    }
                    else if (c1 === 0xf0 && c2 >= 0x90 && c2 <= 0xbf
                        || c1 >= 0xf1 && c1 <= 0xf3 && c2 >= 0x80 && c2 <= 0xbf
                        || c1 === 0xf4 && c2 >= 0x80 && c2 <= 0x8f) {
                        if (c3 >= 0x80 && c3 <= 0xbf) {
                            if (c4 >= 0x80 && c4 <= 0xbf) {
                                this._have = 4;
                                this._output = this._output.write((c1 & 0x07) << 18 | (c2 & 0x3f) << 12 | (c3 & 0x3f) << 6 | c4 & 0x3f);
                                this._c1 = -1;
                                this._c2 = -1;
                                this._c3 = -1;
                                this._have = 0;
                            }
                            else if (c4 >= 0) {
                                if (this._errorMode.isFatal()) {
                                    return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3, c4)));
                                }
                                this._output = this._output.write(this._errorMode.replacementChar());
                                this._c1 = c4;
                                this._c2 = -1;
                                this._c3 = -1;
                                this._have = 1;
                            }
                            else if (token < 0 || this._output.isDone()) {
                                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
                            }
                            else {
                                this._c3 = c3;
                                this._have = 3;
                            }
                        }
                        else if (c3 >= 0) {
                            if (this._errorMode.isFatal()) {
                                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
                            }
                            this._output = this._output.write(this._errorMode.replacementChar());
                            this._c1 = c3;
                            this._c2 = -1;
                            this._have = 1;
                        }
                        else if (token < 0 || this._output.isDone()) {
                            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
                        }
                        else {
                            this._c2 = c2;
                            this._have = 2;
                        }
                    }
                    else if (c2 >= 0) {
                        if (this._errorMode.isFatal()) {
                            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
                        }
                        this._output = this._output.write(this._errorMode.replacementChar());
                        this._c1 = c2;
                        this._have = 1;
                    }
                    else if (token < 0 || this._output.isDone()) {
                        return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));
                    }
                    else {
                        this._c1 = c1;
                        this._have = 1;
                    }
                }
                else if (c1 >= 0) {
                    if (this._errorMode.isFatal()) {
                        return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));
                    }
                    this._output = this._output.write(this._errorMode.replacementChar());
                    this._have = 0;
                }
                if (this._output.isError()) {
                    return this._output;
                }
                return this;
            }
            else if (typeof token === "string") {
                this._output.write(token);
                return this;
            }
            else {
                throw new TypeError("" + token);
            }
        };
        Utf8DecodedOutput.invalid = function (c1, c2, c3, c4) {
            var output = Unicode.stringOutput();
            output = output.write("invalid UTF-8 code unit sequence: ");
            Base16.uppercase().writeIntegerLiteral(c1, output, 2);
            if (c2 !== void 0) {
                output = output.write(' ');
                Base16.uppercase().writeIntegerLiteral(c2, output, 2);
                if (c3 !== void 0) {
                    output = output.write(' ');
                    Base16.uppercase().writeIntegerLiteral(c3, output, 2);
                    if (c4 !== void 0) {
                        output = output.write(' ');
                        Base16.uppercase().writeIntegerLiteral(c4, output, 2);
                    }
                }
            }
            return output.bind();
        };
        Utf8DecodedOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._output.settings();
            }
            else {
                this._output.settings(settings);
                return this;
            }
        };
        Utf8DecodedOutput.prototype.bind = function () {
            if (this._have === 0) {
                return this._output.bind();
            }
            else {
                return this.write(-1).bind();
            }
        };
        Utf8DecodedOutput.prototype.trap = function () {
            return this._output.trap();
        };
        Utf8DecodedOutput.prototype.clone = function () {
            return new Utf8DecodedOutput(this._output.clone(), this._errorMode, this._c1, this._c2, this._c3, this._have);
        };
        return Utf8DecodedOutput;
    }(Output));

    var Utf8EncodedOutput = (function (_super) {
        __extends(Utf8EncodedOutput, _super);
        function Utf8EncodedOutput(output, errorMode, c2, c3, c4, index) {
            if (c2 === void 0) { c2 = 0; }
            if (c3 === void 0) { c3 = 0; }
            if (c4 === void 0) { c4 = 0; }
            if (index === void 0) { index = 4; }
            var _this = _super.call(this) || this;
            _this._output = output;
            _this._errorMode = errorMode;
            _this._c2 = c2;
            _this._c3 = c3;
            _this._c4 = c4;
            _this._index = index;
            return _this;
        }
        Utf8EncodedOutput.prototype.isCont = function () {
            return this._output.isCont();
        };
        Utf8EncodedOutput.prototype.isFull = function () {
            return this._output.isFull();
        };
        Utf8EncodedOutput.prototype.isDone = function () {
            return this._output.isDone();
        };
        Utf8EncodedOutput.prototype.isError = function () {
            return false;
        };
        Utf8EncodedOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return this._output.isPart();
            }
            else {
                this._output = this._output.isPart(isPart);
                return this;
            }
        };
        Utf8EncodedOutput.prototype.write = function (token) {
            if (typeof token === "number") {
                var c1 = 0;
                var c2 = this._c2;
                var c3 = this._c3;
                var c4 = this._c4;
                var index = this._index;
                while (index < 4) {
                    if (this._output.isCont()) {
                        switch (index) {
                            case 1:
                                this._output = this._output.write(c2);
                                this._c2 = 0;
                                break;
                            case 2:
                                this._output = this._output.write(c3);
                                this._c3 = 0;
                                break;
                            case 3:
                                this._output = this._output.write(c4);
                                this._c4 = 0;
                                break;
                            default: throw new Error("unreachable");
                        }
                        index += 1;
                    }
                    else {
                        return Output.error(new OutputException("unable to flush buffered code units"));
                    }
                }
                if (token >= 0 && token <= 0x7f) {
                    c4 = token;
                    index = 3;
                }
                else if (token >= 0x80 && token <= 0x7ff) {
                    c3 = 0xc0 | (token >>> 6);
                    c4 = 0x80 | (token & 0x3f);
                    index = 2;
                }
                else if (token >= 0x0800 && token <= 0xffff ||
                    token >= 0xe000 && token <= 0xffff) {
                    c2 = 0xe0 | (token >>> 12);
                    c3 = 0x80 | ((token >>> 6) & 0x3f);
                    c4 = 0x80 | (token & 0x3f);
                    index = 1;
                }
                else if (token >= 0x10000 && token <= 0x10ffff) {
                    c1 = 0xf0 | (token >>> 18);
                    c2 = 0x80 | ((token >>> 12) & 0x3f);
                    c3 = 0x80 | ((token >>> 6) & 0x3f);
                    c4 = 0x80 | (token & 0x3f);
                    index = 0;
                }
                else {
                    if (this._errorMode.isFatal()) {
                        return Output.error(new OutputException("invalid code point: " + token));
                    }
                    else {
                        return this.write(this._errorMode.replacementChar());
                    }
                }
                do {
                    switch (index) {
                        case 0:
                            this._output = this._output.write(c1);
                            break;
                        case 1:
                            this._output = this._output.write(c2);
                            this._c2 = 0;
                            break;
                        case 2:
                            this._output = this._output.write(c3);
                            this._c3 = 0;
                            break;
                        case 3:
                            this._output = this._output.write(c4);
                            this._c4 = 0;
                            break;
                        default: throw new Error("unreachable");
                    }
                    index += 1;
                } while (index < 4 && this._output.isCont());
                if (index < 4) {
                    if (index < 3) {
                        if (index < 2) {
                            this._c2 = c2;
                        }
                        this._c3 = c3;
                    }
                    this._c4 = c4;
                }
                this._index = index;
                return this;
            }
            else if (typeof token === "string") {
                this._output.write(token);
                return this;
            }
            else {
                throw new TypeError("" + token);
            }
        };
        Utf8EncodedOutput.prototype.flush = function () {
            var index = this._index;
            while (index < 4) {
                if (this._output.isCont()) {
                    switch (index) {
                        case 1:
                            this._output = this._output.write(this._c2);
                            this._c2 = 0;
                            break;
                        case 2:
                            this._output = this._output.write(this._c3);
                            this._c3 = 0;
                            break;
                        case 3:
                            this._output = this._output.write(this._c4);
                            this._c4 = 0;
                            break;
                        default: throw new Error("unreachable");
                    }
                    index += 1;
                }
                else {
                    return Output.error(new OutputException("unable to flush buffered code units"));
                }
            }
            this._index = index;
            return this;
        };
        Utf8EncodedOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._output.settings();
            }
            else {
                this._output.settings(settings);
                return this;
            }
        };
        Utf8EncodedOutput.prototype.bind = function () {
            return this._output.bind();
        };
        Utf8EncodedOutput.prototype.clone = function () {
            return new Utf8EncodedOutput(this._output.clone(), this._errorMode, this._c2, this._c3, this._c4, this._index);
        };
        return Utf8EncodedOutput;
    }(Output));

    var Utf8 = (function () {
        function Utf8() {
        }
        Utf8.sizeOf = function (u, errorMode) {
            if (typeof u === "number" || u === void 0) {
                if (typeof u === "number") {
                    if (u === 0x0000 && errorMode !== void 0 && errorMode.isNonZero()) {
                        return 2;
                    }
                    else if (u >= 0x0000 && u <= 0x007F) {
                        return 1;
                    }
                    else if (u >= 0x0080 && u <= 0x07FF) {
                        return 2;
                    }
                    else if (u >= 0x0800 && u <= 0xFFFF ||
                        u >= 0xE000 && u <= 0xFFFF) {
                        return 3;
                    }
                    else if (u >= 0x10000 && u <= 0x10FFFF) {
                        return 4;
                    }
                }
                if (errorMode === void 0) {
                    return 3;
                }
                else if (errorMode.isReplacement()) {
                    return Utf8.sizeOf(errorMode.replacementChar());
                }
                else {
                    return 0;
                }
            }
            else if (typeof u === "string") {
                var size = 0;
                for (var i = 0, n = u.length; i < n; i = u.offsetByCodePoints(i, 1)) {
                    size += Utf8.sizeOf(u.charCodeAt(i), errorMode);
                }
                return size;
            }
            else {
                throw new TypeError("" + u);
            }
        };
        Utf8.decodedOutput = function (output, errorMode) {
            if (errorMode === void 0) { errorMode = UtfErrorMode.fatal(); }
            return new Utf8DecodedOutput(output, errorMode);
        };
        Utf8.encodedOutput = function (output, errorMode) {
            if (errorMode === void 0) { errorMode = UtfErrorMode.fatal(); }
            return new Utf8EncodedOutput(output, errorMode);
        };
        Utf8.decodedString = function () {
            return Utf8.decodedOutput(Unicode.stringOutput());
        };
        return Utf8;
    }());

    var Base10NumberParser = (function (_super) {
        __extends(Base10NumberParser, _super);
        function Base10NumberParser(sign, value, mode, step) {
            var _this = _super.call(this) || this;
            _this._sign = sign;
            _this._value = value;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        Base10NumberParser.prototype.feed = function (input) {
            return Base10NumberParser.parse(input, this._sign, this._value, this._mode, this._step);
        };
        Base10NumberParser.parse = function (input, sign, value, mode, step) {
            if (sign === void 0) { sign = 1; }
            if (value === void 0) { value = 0; }
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 45) {
                        input = input.step();
                        sign = -1;
                    }
                    step = 2;
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("number", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 48) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c >= 49 && c <= 57) {
                        input = input.step();
                        value = sign * (c - 48);
                        step = 3;
                    }
                    else if (mode > 0 && c === 46) {
                        var output = Unicode.stringOutput();
                        if (sign < 0) {
                            output = output.write(45);
                        }
                        return Base10DecimalParser.parse(input, output, mode);
                    }
                    else {
                        return Parser.error(Diagnostic.expected("number", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("number", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        var newValue = 10 * value + sign * (c - 48);
                        if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {
                            value = newValue;
                            input = input.step();
                        }
                        else {
                            return Parser.error(Diagnostic.message("integer overflow", input));
                        }
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    step = 4;
                }
                else if (input.isDone()) {
                    return Parser.done(value);
                }
            }
            if (step === 4) {
                if (input.isCont()) {
                    c = input.head();
                    if (mode > 0 && c === 46 || mode > 1 && (c === 69 || c === 101)) {
                        var output = Unicode.stringOutput();
                        if (sign < 0 && value === 0) {
                            output = output.write(45).write(48);
                        }
                        else {
                            output = output.write("" + value);
                        }
                        return Base10DecimalParser.parse(input, output, mode);
                    }
                    else {
                        return Parser.done(value);
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(value);
                }
            }
            return new Base10NumberParser(sign, value, mode, step);
        };
        return Base10NumberParser;
    }(Parser));
    Base10.NumberParser = Base10NumberParser;
    var Base10DecimalParser = (function (_super) {
        __extends(Base10DecimalParser, _super);
        function Base10DecimalParser(output, mode, step) {
            var _this = _super.call(this) || this;
            _this._output = output;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        Base10DecimalParser.prototype.feed = function (input) {
            return Base10DecimalParser.parse(input, this._output, this._mode, this._step);
        };
        Base10DecimalParser.parse = function (input, output, mode, step) {
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 46) {
                        input = input.step();
                        output = output.write(c);
                        step = 2;
                    }
                    else if (mode > 1 && (c === 69 || c === 101)) {
                        input = input.step();
                        output = output.write(c);
                        step = 5;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("decimal or exponent", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("decimal or exponent", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 3;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("digit", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    if (mode > 1) {
                        step = 4;
                    }
                    else {
                        return Parser.done(+output.bind());
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(+output.bind());
                }
            }
            if (step === 4) {
                c = input.head();
                if (c === 69 || c === 101) {
                    input = input.step();
                    output = output.write(c);
                    step = 5;
                }
                else {
                    return Parser.done(+output.bind());
                }
            }
            if (step === 5) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 43 || c === 45) {
                        input = input.step();
                        output = output.write(c);
                    }
                    step = 6;
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 6) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 7;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("digit", input));
                }
            }
            if (step === 7) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (!input.isEmpty()) {
                    return Parser.done(+output.bind());
                }
            }
            return new Base10DecimalParser(output, mode, step);
        };
        return Base10DecimalParser;
    }(Parser));

    var Base10IntegerWriter = (function (_super) {
        __extends(Base10IntegerWriter, _super);
        function Base10IntegerWriter(value, input, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._input = input;
            _this._index = index;
            _this._step = step;
            return _this;
        }
        Base10IntegerWriter.prototype.pull = function (output) {
            return Base10IntegerWriter.write(output, this._value, this._input, this._index, this._step);
        };
        Base10IntegerWriter.write = function (output, value, input, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            if (step === 0) {
                return Writer.done();
            }
            if (step === 1) {
                if (input < 0) {
                    if (output.isCont()) {
                        output = output.write(45);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (input > -10 && input < 10) {
                    if (output.isCont()) {
                        output = output.write(Base10.encodeDigit(Math.abs(input | 0)));
                        return Writer.done(value);
                    }
                }
                else {
                    var digits = new Array(19);
                    var x = input;
                    var i = 18;
                    while (x) {
                        digits[i] = Math.abs((x % 10) | 0);
                        x = (x / 10) | 0;
                        i -= 1;
                    }
                    i += 1 + index;
                    while (i < 19 && output.isCont()) {
                        output = output.write(Base10.encodeDigit(digits[i]));
                        index += 1;
                        i += 1;
                    }
                    if (i === 19) {
                        return Writer.done(value);
                    }
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new Base10IntegerWriter(value, input, index, step);
        };
        return Base10IntegerWriter;
    }(Writer));
    Base10.IntegerWriter = Base10IntegerWriter;

    var Base16Parser = (function (_super) {
        __extends(Base16Parser, _super);
        function Base16Parser(output, p, step) {
            if (p === void 0) { p = 0; }
            if (step === void 0) { step = 1; }
            var _this = _super.call(this) || this;
            _this._output = output;
            _this._p = p;
            _this._step = step;
            return _this;
        }
        Base16Parser.prototype.feed = function (input) {
            return Base16Parser.parse(input, this._output.clone(), this._p, this._step);
        };
        Base16Parser.parse = function (input, output, p, step) {
            if (p === void 0) { p = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            while (!input.isEmpty()) {
                if (step === 1) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        p = c;
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(output.bind());
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        Base16.writeQuantum(p, c, output);
                        p = 0;
                        step = 1;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("base16 digit", input));
                    }
                }
            }
            return new Base16Parser(output, p, step);
        };
        return Base16Parser;
    }(Parser));
    Base16.Parser = Base16Parser;

    var Base16Writer = (function (_super) {
        __extends(Base16Writer, _super);
        function Base16Writer(value, input, base16, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._input = input;
            _this._base16 = base16;
            _this._index = index;
            _this._step = step;
            return _this;
        }
        Base16Writer.prototype.feed = function (value) {
            if (value instanceof Uint8Array) {
                return new Base16Writer(undefined, value, this._base16);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Base16Writer.prototype.pull = function (output) {
            return Base16Writer.write(output, this._value, this._input, this._base16, this._index, this._step);
        };
        Base16Writer.write = function (output, value, input, base16, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            while (index < input.length) {
                var x = input[index];
                if (step === 1 && output.isCont()) {
                    output = output.write(base16.encodeDigit(x >>> 4));
                    step = 2;
                }
                if (step === 2 && output.isCont()) {
                    output = output.write(base16.encodeDigit(x & 0x0f));
                    index += 1;
                    step = 1;
                }
            }
            if (index === input.length) {
                return Writer.done(value);
            }
            else if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new Base16Writer(value, input, base16, index, step);
        };
        return Base16Writer;
    }(Writer));
    Base16.Writer = Base16Writer;

    var Base16IntegerWriter = (function (_super) {
        __extends(Base16IntegerWriter, _super);
        function Base16IntegerWriter(value, input, width, base16, index, step) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._input = input;
            _this._width = width;
            _this._base16 = base16;
            _this._index = index;
            _this._step = step;
            return _this;
        }
        Base16IntegerWriter.prototype.pull = function (output) {
            return Base16IntegerWriter.write(output, this._value, this._input, this._width, this._base16, this._index, this._step);
        };
        Base16IntegerWriter.write = function (output, value, input, width, base16, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 3; }
            if (step <= 0) {
                return Writer.done();
            }
            if (step === 1 && output.isCont()) {
                output = output.write(48);
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(120);
                step = 3;
            }
            if (step === 3) {
                if (input >= 0 && input < 16 && width <= 1) {
                    if (output.isCont()) {
                        output = output.write(base16.encodeDigit(input));
                        return Writer.done(value);
                    }
                }
                else {
                    var i = 15;
                    var digits = new Array(16);
                    var x = input;
                    while (x !== 0 || i >= 16 - width) {
                        digits[i] = x & 0xf;
                        x >>>= 4;
                        i -= 1;
                    }
                    i += 1 + index;
                    while (i < 16 && output.isCont()) {
                        output = output.write(base16.encodeDigit(digits[i]));
                        index += 1;
                        i += 1;
                    }
                    if (i === 16) {
                        return Writer.done(value);
                    }
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new Base16IntegerWriter(value, input, width, base16, index, step);
        };
        Base16IntegerWriter.writeLiteral = function (output, value, input, width, base16) {
            return Base16IntegerWriter.write(output, value, input, width, base16, 0, 1);
        };
        return Base16IntegerWriter;
    }(Writer));
    Base16.IntegerWriter = Base16IntegerWriter;

    var Base64 = (function () {
        function Base64() {
        }
        Base64.prototype.decodeDigit = function (c) {
            if (c >= 65 && c <= 90) {
                return c - 65;
            }
            else if (c >= 97 && c <= 122) {
                return c + (26 - 97);
            }
            else if (c >= 48 && c <= 57) {
                return c + (52 - 48);
            }
            else if (c === 43 || c === 45) {
                return 62;
            }
            else if (c === 47 || c === 95) {
                return 63;
            }
            else {
                var message = Unicode.stringOutput();
                message.write("Invalid base-64 digit: ");
                Format.debugChar(c, message);
                throw new Error(message.bind());
            }
        };
        Base64.prototype.encodeDigit = function (b) {
            return this.alphabet().charCodeAt(b);
        };
        Base64.prototype.writeQuantum = function (c1, c2, c3, c4, output) {
            var x = this.decodeDigit(c1);
            var y = this.decodeDigit(c2);
            if (c3 !== 61) {
                var z = this.decodeDigit(c3);
                if (c4 !== 61) {
                    var w = this.decodeDigit(c4);
                    output = output.write((x << 2) | (y >>> 4));
                    output = output.write((y << 4) | (z >>> 2));
                    output = output.write((z << 6) | w);
                }
                else {
                    output = output.write((x << 2) | (y >>> 4));
                    output = output.write((y << 4) | (z >>> 2));
                }
            }
            else {
                if (c4 !== 61) {
                    throw new Error("Improperly padded base-64");
                }
                output = output.write((x << 2) | (y >>> 4));
            }
        };
        Base64.prototype.parser = function (output) {
            return new Base64.Parser(output, this);
        };
        Base64.prototype.parse = function (input, output) {
            return Base64.Parser.parse(input, output, this);
        };
        Base64.prototype.parseUint8Array = function (input) {
            return Base64.Parser.parse(input, Binary.uint8ArrayOutput(), this);
        };
        Base64.prototype.uint8ArrayWriter = function (input) {
            if (input === void 0) {
                return new Base64.Writer(void 0, void 0, this);
            }
            else {
                return new Base64.Writer(input, input, this);
            }
        };
        Base64.prototype.writeUint8Array = function (input, output) {
            return Base64.Writer.write(output, void 0, input, this);
        };
        Base64.standard = function (isPadded) {
            if (isPadded === void 0) { isPadded = true; }
            if (isPadded) {
                if (!Base64._standard) {
                    Base64._standard = new Base64Standard(true);
                }
                return Base64._standard;
            }
            else {
                if (!Base64._standardUnpadded) {
                    Base64._standardUnpadded = new Base64Standard(true);
                }
                return Base64._standardUnpadded;
            }
        };
        Base64.url = function (isPadded) {
            if (isPadded === void 0) { isPadded = true; }
            if (isPadded) {
                if (!Base64._url) {
                    Base64._url = new Base64Url(true);
                }
                return Base64._url;
            }
            else {
                if (!Base64._urlUnpadded) {
                    Base64._urlUnpadded = new Base64Url(false);
                }
                return Base64._urlUnpadded;
            }
        };
        return Base64;
    }());
    var Base64Standard = (function (_super) {
        __extends(Base64Standard, _super);
        function Base64Standard(isPadded) {
            var _this = _super.call(this) || this;
            _this._isPadded = isPadded;
            return _this;
        }
        Base64Standard.prototype.alphabet = function () {
            return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        };
        Base64Standard.prototype.isPadded = function (isPadded) {
            if (isPadded === void 0) {
                return this._isPadded;
            }
            else {
                if (isPadded === this._isPadded) {
                    return this;
                }
                else {
                    return Base64.standard(isPadded);
                }
            }
        };
        Base64Standard.prototype.isDigit = function (c) {
            return c >= 48 && c <= 57
                || c >= 65 && c <= 90
                || c >= 97 && c <= 122
                || c === 43 || c === 47;
        };
        return Base64Standard;
    }(Base64));
    var Base64Url = (function (_super) {
        __extends(Base64Url, _super);
        function Base64Url(isPadded) {
            var _this = _super.call(this) || this;
            _this._isPadded = isPadded;
            return _this;
        }
        Base64Url.prototype.alphabet = function () {
            return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
        };
        Base64Url.prototype.isPadded = function (isPadded) {
            if (isPadded === void 0) {
                return this._isPadded;
            }
            else {
                if (isPadded === this._isPadded) {
                    return this;
                }
                else {
                    return Base64.url(isPadded);
                }
            }
        };
        Base64Url.prototype.isDigit = function (c) {
            return c >= 48 && c <= 57
                || c >= 65 && c <= 90
                || c >= 97 && c <= 122
                || c === 45 || c === 95;
        };
        return Base64Url;
    }(Base64));

    var Base64Parser = (function (_super) {
        __extends(Base64Parser, _super);
        function Base64Parser(output, base64, p, q, r, step) {
            if (p === void 0) { p = 0; }
            if (q === void 0) { q = 0; }
            if (r === void 0) { r = 0; }
            if (step === void 0) { step = 1; }
            var _this = _super.call(this) || this;
            _this._output = output;
            _this._base64 = base64;
            _this._p = p;
            _this._q = q;
            _this._r = r;
            _this._step = step;
            return _this;
        }
        Base64Parser.prototype.feed = function (input) {
            return Base64Parser.parse(input, this._output.clone(), this._base64, this._p, this._q, this._r, this._step);
        };
        Base64Parser.parse = function (input, output, base64, p, q, r, step) {
            if (p === void 0) { p = 0; }
            if (q === void 0) { q = 0; }
            if (r === void 0) { r = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            while (!input.isEmpty()) {
                if (step === 1) {
                    if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
                        input = input.step();
                        p = c;
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(output.bind());
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
                        input = input.step();
                        q = c;
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("base64 digit", input));
                    }
                }
                if (step === 3) {
                    if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
                        input = input.step();
                        r = c;
                        if (c !== 61) {
                            step = 4;
                        }
                        else {
                            step = 5;
                        }
                    }
                    else if (!input.isEmpty()) {
                        if (!base64.isPadded()) {
                            base64.writeQuantum(p, q, 61, 61, output);
                            return Parser.done(output.bind());
                        }
                        else {
                            return Parser.error(Diagnostic.unexpected(input));
                        }
                    }
                }
                if (step === 4) {
                    if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
                        input = input.step();
                        base64.writeQuantum(p, q, r, c, output);
                        r = 0;
                        q = 0;
                        p = 0;
                        if (c !== 61) {
                            step = 1;
                        }
                        else {
                            return Parser.done(output.bind());
                        }
                    }
                    else if (!input.isEmpty()) {
                        if (!base64.isPadded()) {
                            base64.writeQuantum(p, q, r, 61, output);
                            return Parser.done(output.bind());
                        }
                        else {
                            return Parser.error(Diagnostic.unexpected(input));
                        }
                    }
                }
                else if (step === 5) {
                    if (input.isCont() && (c = input.head(), c === 61)) {
                        input = input.step();
                        base64.writeQuantum(p, q, r, c, output);
                        r = 0;
                        q = 0;
                        p = 0;
                        return Parser.done(output.bind());
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected(61, input));
                    }
                }
            }
            return new Base64Parser(output, base64, p, q, r, step);
        };
        return Base64Parser;
    }(Parser));
    Base64.Parser = Base64Parser;

    var Base64Writer = (function (_super) {
        __extends(Base64Writer, _super);
        function Base64Writer(value, input, base64, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._input = input;
            _this._base64 = base64;
            _this._index = index;
            _this._step = step;
            return _this;
        }
        Base64Writer.prototype.feed = function (value) {
            if (value instanceof Uint8Array) {
                return new Base64Writer(undefined, value, this._base64);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Base64Writer.prototype.pull = function (output) {
            return Base64Writer.write(output, this._value, this._input, this._base64, this._index, this._step);
        };
        Base64Writer.write = function (output, value, input, base64, index, step) {
            if (index === void 0) { index = 0; }
            if (step === void 0) { step = 1; }
            while (index + 2 < input.length && output.isCont()) {
                var x = input[index];
                var y = input[index + 1];
                var z = input[index + 2];
                if (step === 1 && output.isCont()) {
                    output = output.write(base64.encodeDigit(x >>> 2));
                    step = 2;
                }
                if (step === 2 && output.isCont()) {
                    output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));
                    step = 3;
                }
                if (step === 3 && output.isCont()) {
                    output = output.write(base64.encodeDigit(((y << 2) | (z >>> 6)) & 0x3f));
                    step = 4;
                }
                if (step === 4 && output.isCont()) {
                    output = output.write(base64.encodeDigit(z & 0x3f));
                    index += 3;
                    step = 1;
                }
            }
            if (index + 1 < input.length && output.isCont()) {
                var x = input[index];
                var y = input[index + 1];
                if (step === 1 && output.isCont()) {
                    output = output.write(base64.encodeDigit(x >>> 2));
                    step = 2;
                }
                if (step === 2 && output.isCont()) {
                    output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));
                    step = 3;
                }
                if (step === 3 && output.isCont()) {
                    output = output.write(base64.encodeDigit((y << 2) & 0x3f));
                    step = 4;
                }
                if (step === 4) {
                    if (!base64.isPadded()) {
                        index += 2;
                    }
                    else if (output.isCont()) {
                        output = output.write(61);
                        index += 2;
                    }
                }
            }
            else if (index < input.length && output.isCont()) {
                var x = input[index];
                if (step === 1 && output.isCont()) {
                    output = output.write(base64.encodeDigit(x >>> 2));
                    step = 2;
                }
                if (step === 2 && output.isCont()) {
                    output = output.write(base64.encodeDigit((x << 4) & 0x3f));
                    step = 3;
                }
                if (step === 3) {
                    if (!base64.isPadded()) {
                        index += 1;
                    }
                    else if (output.isCont()) {
                        output = output.write(61);
                        step = 4;
                    }
                }
                if (step === 4 && output.isCont()) {
                    output = output.write(61);
                    index += 1;
                }
            }
            if (index === input.length) {
                return Writer.done(value);
            }
            else if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new Base64Writer(value, input, base64, index, step);
        };
        return Base64Writer;
    }(Writer));
    Base64.Writer = Base64Writer;

    var KeysCursor = (function (_super) {
        __extends(KeysCursor, _super);
        function KeysCursor(cursor) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            return _this;
        }
        KeysCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        KeysCursor.prototype.head = function () {
            return this._cursor.head()[0];
        };
        KeysCursor.prototype.step = function () {
            this._cursor.step();
        };
        KeysCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        KeysCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        KeysCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        KeysCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value[0], done: done };
        };
        KeysCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        KeysCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        KeysCursor.prototype.previous = function () {
            var _a = this._cursor.previous(), value = _a.value, done = _a.done;
            return { value: value && value[0], done: done };
        };
        KeysCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return KeysCursor;
    }(Cursor));

    var ValuesCursor = (function (_super) {
        __extends(ValuesCursor, _super);
        function ValuesCursor(cursor) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            return _this;
        }
        ValuesCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        ValuesCursor.prototype.head = function () {
            return this._cursor.head()[1];
        };
        ValuesCursor.prototype.step = function () {
            this._cursor.step();
        };
        ValuesCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        ValuesCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        ValuesCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        ValuesCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value[1], done: done };
        };
        ValuesCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        ValuesCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        ValuesCursor.prototype.previous = function () {
            var _a = this._cursor.previous(), value = _a.value, done = _a.done;
            return { value: value && value[1], done: done };
        };
        ValuesCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return ValuesCursor;
    }(Cursor));

    var NodeCursor = (function (_super) {
        __extends(NodeCursor, _super);
        function NodeCursor(pages, index, pageIndex, pageCursor) {
            if (index === void 0) { index = 0; }
            if (pageIndex === void 0) { pageIndex = 0; }
            var _this = _super.call(this) || this;
            _this._pages = pages;
            _this._index = index;
            _this._pageIndex = pageIndex;
            _this._pageCursor = pageCursor;
            return _this;
        }
        NodeCursor.prototype.isEmpty = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        return false;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                    this._pageIndex += 1;
                }
                else {
                    this._pageIndex = this._pages.length;
                    return true;
                }
            } while (true);
        };
        NodeCursor.prototype.head = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        return this._pageCursor.head();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        throw new Error("empty");
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.step = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        this._index += 1;
                        return;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        throw new Error("empty");
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.skip = function (count) {
            while (count > 0) {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        this._index += 1;
                        count -= 1;
                        this._pageCursor.next();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    var page = this._pages[this._pageIndex];
                    var pageSize = this.pageSize(page);
                    this._pageIndex += 1;
                    if (pageSize < count) {
                        this._pageCursor = this.pageCursor(page);
                        if (count > 0) {
                            this._index += count;
                            this._pageCursor.skip(count);
                            count = 0;
                        }
                        break;
                    }
                    else {
                        this._index += pageSize;
                        count -= pageSize;
                    }
                }
                else {
                    break;
                }
            }
        };
        NodeCursor.prototype.hasNext = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        return true;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                    this._pageIndex += 1;
                }
                else {
                    this._pageIndex = this._pages.length;
                    return false;
                }
            } while (true);
        };
        NodeCursor.prototype.nextIndex = function () {
            return this._index;
        };
        NodeCursor.prototype.next = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        this._index += 1;
                        return this._pageCursor.next();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        return { done: true };
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.hasPrevious = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasPrevious()) {
                        return true;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex > 0) {
                    this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);
                    this._pageIndex -= 1;
                }
                else {
                    this._pageIndex = 0;
                    return false;
                }
            } while (true);
        };
        NodeCursor.prototype.previousIndex = function () {
            return this._index - 1;
        };
        NodeCursor.prototype.previous = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasPrevious()) {
                        this._index -= 1;
                        return this._pageCursor.previous();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex > 0) {
                    this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);
                    this._pageIndex -= 1;
                }
                else {
                    this._pageIndex = 0;
                    return { done: true };
                }
            } while (true);
        };
        NodeCursor.prototype.set = function (newValue) {
            this._pageCursor.set(newValue);
        };
        NodeCursor.prototype.delete = function () {
            this._pageCursor.delete();
        };
        return NodeCursor;
    }(Cursor));

    var BTreeContext = (function () {
        function BTreeContext() {
        }
        BTreeContext.prototype.compare = function (x, y) {
            return Objects.compare(x, y);
        };
        BTreeContext.prototype.pageShouldSplit = function (page) {
            return page.arity > this.pageSplitSize;
        };
        BTreeContext.prototype.pageShouldMerge = function (page) {
            return page.arity < this.pageSplitSize >>> 1;
        };
        return BTreeContext;
    }());
    BTreeContext.prototype.pageSplitSize = 32;

    var BTree = (function (_super) {
        __extends(BTree, _super);
        function BTree(root) {
            if (root === void 0) { root = BTree.Page.empty(); }
            var _this = _super.call(this) || this;
            _this.root = root;
            return _this;
        }
        Object.defineProperty(BTree.prototype, "size", {
            get: function () {
                return this.root.size;
            },
            enumerable: true,
            configurable: true
        });
        BTree.prototype.isEmpty = function () {
            return this.root.isEmpty();
        };
        BTree.prototype.has = function (key) {
            return this.root.has(key, this);
        };
        BTree.prototype.get = function (key) {
            return this.root.get(key, this);
        };
        BTree.prototype.getEntry = function (index) {
            return this.root.getEntry(index);
        };
        BTree.prototype.firstKey = function () {
            var entry = this.root.firstEntry();
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.firstValue = function () {
            var entry = this.root.firstEntry();
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.firstEntry = function () {
            return this.root.firstEntry();
        };
        BTree.prototype.lastKey = function () {
            var entry = this.root.lastEntry();
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.lastValue = function () {
            var entry = this.root.lastEntry();
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.lastEntry = function () {
            return this.root.lastEntry();
        };
        BTree.prototype.nextKey = function (key) {
            var entry = this.root.nextEntry(key, this);
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.nextValue = function (key) {
            var entry = this.root.nextEntry(key, this);
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.nextEntry = function (key) {
            return this.root.nextEntry(key, this);
        };
        BTree.prototype.previousKey = function (key) {
            var entry = this.root.previousEntry(key, this);
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.previousValue = function (key) {
            var entry = this.root.previousEntry(key, this);
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.previousEntry = function (key) {
            return this.root.previousEntry(key, this);
        };
        BTree.prototype.set = function (key, newValue) {
            var oldRoot = this.root;
            var newRoot = this.root.updated(key, newValue, this);
            if (oldRoot !== newRoot) {
                if (newRoot.size > oldRoot.size) {
                    newRoot = newRoot.balanced(this);
                }
                this.root = newRoot;
            }
            return this;
        };
        BTree.prototype.delete = function (key) {
            var oldRoot = this.root;
            var newRoot = this.root.removed(key, this);
            if (oldRoot !== newRoot) {
                this.root = newRoot;
                return true;
            }
            else {
                return false;
            }
        };
        BTree.prototype.drop = function (lower) {
            if (lower > 0 && this.root.size > 0) {
                if (lower < this.root.size) {
                    this.root = this.root.drop(lower, this);
                }
                else {
                    this.root = BTree.Page.empty();
                }
            }
            return this;
        };
        BTree.prototype.take = function (upper) {
            if (upper < this.root.size && this.root.size > 0) {
                if (upper > 0) {
                    this.root = this.root.take(upper, this);
                }
                else {
                    this.root = BTree.Page.empty();
                }
            }
            return this;
        };
        BTree.prototype.clear = function () {
            this.root = BTree.Page.empty();
        };
        BTree.prototype.updated = function (key, newValue) {
            var oldRoot = this.root;
            var newRoot = oldRoot.updated(key, newValue, this);
            if (oldRoot !== newRoot) {
                if (newRoot.size > oldRoot.size) {
                    newRoot = newRoot.balanced(this);
                }
                return this.copy(newRoot);
            }
            else {
                return this;
            }
        };
        BTree.prototype.removed = function (key) {
            var oldRoot = this.root;
            var newRoot = oldRoot.removed(key, this);
            if (oldRoot !== newRoot) {
                return this.copy(newRoot);
            }
            else {
                return this;
            }
        };
        BTree.prototype.cleared = function () {
            if (!this.root.isEmpty()) {
                return this.copy(BTree.Page.empty());
            }
            else {
                return this;
            }
        };
        BTree.prototype.reduced = function (identity, accumulator, combiner) {
            var oldRoot = this.root;
            var newRoot = oldRoot.reduced(identity, accumulator, combiner);
            if (oldRoot !== newRoot) {
                this.root = newRoot;
            }
            return newRoot.fold();
        };
        BTree.prototype.forEach = function (callback, thisArg) {
            return this.root.forEach(callback, thisArg, this);
        };
        BTree.prototype.keys = function () {
            return this.root.keys();
        };
        BTree.prototype.values = function () {
            return this.root.values();
        };
        BTree.prototype.entries = function () {
            return this.root.entries();
        };
        BTree.prototype.reverseKeys = function () {
            return this.root.reverseKeys();
        };
        BTree.prototype.reverseValues = function () {
            return this.root.reverseValues();
        };
        BTree.prototype.reverseEntries = function () {
            return this.root.reverseEntries();
        };
        BTree.prototype.clone = function () {
            return this.copy(this.root);
        };
        BTree.prototype.copy = function (root) {
            var tree = new BTree(root);
            if (tree.compare !== this.compare) {
                tree.compare = this.compare;
            }
            if (tree.pageSplitSize !== this.pageSplitSize) {
                tree.pageSplitSize = this.pageSplitSize;
            }
            return tree;
        };
        return BTree;
    }(BTreeContext));

    var BTreePage = (function () {
        function BTreePage() {
        }
        BTreePage.prototype.keys = function () {
            return new KeysCursor(this.entries());
        };
        BTreePage.prototype.values = function () {
            return new ValuesCursor(this.entries());
        };
        BTreePage.prototype.reverseKeys = function () {
            return new KeysCursor(this.reverseEntries());
        };
        BTreePage.prototype.reverseValues = function () {
            return new ValuesCursor(this.reverseEntries());
        };
        BTreePage.empty = function () {
            if (!BTreePage._empty) {
                BTreePage._empty = new BTree.Leaf([], void 0);
            }
            return BTreePage._empty;
        };
        return BTreePage;
    }());
    BTree.Page = BTreePage;

    var BTreeLeaf = (function (_super) {
        __extends(BTreeLeaf, _super);
        function BTreeLeaf(slots, fold) {
            var _this = _super.call(this) || this;
            _this._slots = slots;
            _this._fold = fold;
            return _this;
        }
        Object.defineProperty(BTreeLeaf.prototype, "arity", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BTreeLeaf.prototype, "size", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        BTreeLeaf.prototype.isEmpty = function () {
            return this._slots.length === 0;
        };
        BTreeLeaf.prototype.fold = function () {
            return this._fold;
        };
        BTreeLeaf.prototype.minKey = function () {
            return this._slots[0][0];
        };
        BTreeLeaf.prototype.maxKey = function () {
            return this._slots[this._slots.length - 1][0];
        };
        BTreeLeaf.prototype.has = function (key, tree) {
            return this.lookup(key, tree) >= 0;
        };
        BTreeLeaf.prototype.get = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                return this._slots[x][1];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.getEntry = function (index) {
            return this._slots[index];
        };
        BTreeLeaf.prototype.firstEntry = function () {
            if (this._slots.length) {
                return this._slots[0];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.lastEntry = function () {
            if (this._slots.length) {
                return this._slots[this._slots.length - 1];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.nextEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            return this._slots[x];
        };
        BTreeLeaf.prototype.previousEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x -= 1;
            }
            else {
                x = -(x + 2);
            }
            return this._slots[x];
        };
        BTreeLeaf.prototype.updated = function (key, newValue, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                return this.updatedSlot(x, key, newValue);
            }
            else {
                x = -(x + 1);
                return this.insertedSlot(x, key, newValue);
            }
        };
        BTreeLeaf.prototype.updatedSlot = function (x, key, newValue) {
            var oldSlots = this._slots;
            if (newValue !== oldSlots[x][1]) {
                var newSlots = oldSlots.slice(0);
                newSlots[x] = [key, newValue];
                return this.newLeaf(newSlots, void 0);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.insertedSlot = function (x, key, newValue) {
            var oldSlots = this._slots;
            var n = oldSlots.length + 1;
            var newSlots = new Array(n);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            newSlots[x] = [key, newValue];
            for (var i = x; i < n - 1; i += 1) {
                newSlots[i + 1] = oldSlots[i];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.removed = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                if (this._slots.length > 1) {
                    return this.removedSlot(x);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.removedSlot = function (x) {
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length - 1);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            for (var i = x; i < newSlots.length; i += 1) {
                newSlots[i] = oldSlots[i + 1];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                var oldSlots = this._slots;
                if (lower < oldSlots.length) {
                    var size = oldSlots.length - lower;
                    var newSlots = new Array(size);
                    for (var i = 0; i < size; i += 1) {
                        newSlots[i] = oldSlots[i + lower];
                    }
                    return this.newLeaf(newSlots, void 0);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.take = function (upper, tree) {
            var oldSlots = this._slots;
            if (upper < oldSlots.length) {
                if (upper > 0) {
                    var newSlots = new Array(upper);
                    for (var i = 0; i < upper; i += 1) {
                        newSlots[i] = oldSlots[i];
                    }
                    return this.newLeaf(newSlots, void 0);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.balanced = function (tree) {
            var n = this._slots.length;
            if (n > 1 && tree.pageShouldSplit(this)) {
                var x = n >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newRightPage.minKey();
            return this.newNode(newPages, newKnots, void 0, this._slots.length);
        };
        BTreeLeaf.prototype.splitLeft = function (x) {
            var oldSlots = this._slots;
            var newSlots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.splitRight = function (x) {
            var oldSlots = this._slots;
            var y = oldSlots.length - x;
            var newSlots = new Array(y);
            for (var i = 0; i < y; i += 1) {
                newSlots[i] = oldSlots[i + x];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.reduced = function (identity, accumulator, combiner) {
            if (this._fold === void 0) {
                var slots = this._slots;
                var fold = identity;
                for (var i = 0, n = slots.length; i < n; i += 1) {
                    fold = accumulator(fold, slots[i][1]);
                }
                return this.newLeaf(slots, fold);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.forEach = function (callback, thisArg, tree) {
            var slots = this._slots;
            for (var i = 0, n = slots.length; i < n; i += 1) {
                var slot = slots[i];
                var result = callback.call(thisArg, slot[0], slot[1], tree);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        BTreeLeaf.prototype.entries = function () {
            return Cursor.array(this._slots);
        };
        BTreeLeaf.prototype.reverseEntries = function () {
            return Cursor.array(this._slots, this._slots.length);
        };
        BTreeLeaf.prototype.lookup = function (key, tree) {
            var lo = 0;
            var hi = this._slots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                var order = tree.compare(key, this._slots[mid][0]);
                if (order > 0) {
                    lo = mid + 1;
                }
                else if (order < 0) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        BTreeLeaf.prototype.newLeaf = function (slots, fold) {
            return new BTreeLeaf(slots, fold);
        };
        BTreeLeaf.prototype.newNode = function (pages, knots, fold, size) {
            return new BTree.Node(pages, knots, fold, size);
        };
        return BTreeLeaf;
    }(BTreePage));
    BTree.Leaf = BTreeLeaf;

    var BTreeNode = (function (_super) {
        __extends(BTreeNode, _super);
        function BTreeNode(pages, knots, fold, size) {
            var _this = _super.call(this) || this;
            _this._pages = pages;
            _this._knots = knots;
            _this._fold = fold;
            _this._size = size;
            return _this;
        }
        Object.defineProperty(BTreeNode.prototype, "arity", {
            get: function () {
                return this._pages.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BTreeNode.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        BTreeNode.prototype.isEmpty = function () {
            return this._size === 0;
        };
        BTreeNode.prototype.fold = function () {
            return this._fold;
        };
        BTreeNode.prototype.minKey = function () {
            return this._pages[0].minKey();
        };
        BTreeNode.prototype.maxKey = function () {
            return this._pages[this._pages.length - 1].maxKey();
        };
        BTreeNode.prototype.has = function (key, tree) {
            var xx = this.lookup(key, tree);
            if (xx > 0) {
                xx += 1;
            }
            else if (xx < 0) {
                xx = -(xx + 1);
            }
            else {
                return true;
            }
            return this._pages[xx].has(key, tree);
        };
        BTreeNode.prototype.get = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            return this._pages[x].get(key, tree);
        };
        BTreeNode.prototype.getEntry = function (x) {
            var pages = this._pages;
            for (var i = 0, n = pages.length; i < n; i += 1) {
                var page = pages[i];
                if (x < page.size) {
                    return page.getEntry(x);
                }
                else {
                    x -= page.size;
                }
            }
            return void 0;
        };
        BTreeNode.prototype.firstEntry = function () {
            var pages = this._pages;
            if (pages.length) {
                return pages[0].firstEntry();
            }
            else {
                return void 0;
            }
        };
        BTreeNode.prototype.lastEntry = function () {
            var pages = this._pages;
            if (pages.length) {
                return pages[pages.length - 1].lastEntry();
            }
            else {
                return void 0;
            }
        };
        BTreeNode.prototype.nextEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var pages = this._pages;
            var entry = pages[x].nextEntry(key, tree);
            if (entry === void 0 && x + 1 < pages.length) {
                entry = pages[x + 1].nextEntry(key, tree);
            }
            return entry;
        };
        BTreeNode.prototype.previousEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var pages = this._pages;
            var entry = pages[x].previousEntry(key, tree);
            if (entry === void 0 && x > 0) {
                entry = pages[x - 1].previousEntry(key, tree);
            }
            return entry;
        };
        BTreeNode.prototype.updated = function (key, newValue, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var oldPage = this._pages[x];
            var newPage = oldPage.updated(key, newValue, tree);
            if (oldPage !== newPage) {
                if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.updatedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = oldPages.slice(0);
            newPages[x] = newPage;
            var oldKnots = this._knots;
            var newKnots;
            if (oldKnots.length > 0) {
                newKnots = oldKnots.slice(0);
                if (x > 0) {
                    newKnots[x - 1] = newPage.minKey();
                }
            }
            else {
                newKnots = [];
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.updatedPageSplit = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length + 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            var newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
            var newRightPage = newPage.splitRight(newPage.arity >>> 1);
            newPages[x] = newLeftPage;
            newPages[x + 1] = newRightPage;
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldPages.length);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newKnots[x - 1] = newLeftPage.minKey();
                newKnots[x] = newRightPage.minKey();
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i + 1] = oldKnots[i];
                }
            }
            else {
                newKnots[0] = newRightPage.minKey();
                for (var i = 0; i < oldKnots.length; i += 1) {
                    newKnots[i + 1] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.updatedPageMerge = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var midPages = newPage._pages;
            var newPages = new Array(oldPages.length + midPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = 0; i < midPages.length; i += 1) {
                newPages[i + x] = midPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + midPages.length - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var midKnots = newPage._knots;
            var newKnots = new Array(newPages.length - 1);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newKnots[x - 1] = midPages[0].minKey();
                for (var i = 0; i < midKnots.length; i += 1) {
                    newKnots[i + x] = midKnots[i];
                }
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i + midKnots.length] = oldKnots[i];
                }
            }
            else {
                for (var i = 0; i < midKnots.length; i += 1) {
                    newKnots[i] = midKnots[i];
                }
                newKnots[midKnots.length] = oldPages[1].minKey();
                for (var i = 1; i < oldKnots.length; i += 1) {
                    newKnots[i + midKnots.length] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.removed = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var oldPage = this._pages[x];
            var newPage = oldPage.removed(key, tree);
            if (oldPage !== newPage) {
                return this.replacedPage(x, newPage, oldPage, tree);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.replacedPage = function (x, newPage, oldPage, tree) {
            if (!newPage.isEmpty()) {
                if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {
                    return this.updatedPageMerge(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else if (this._pages.length > 2) {
                return this.removedPage(x, newPage, oldPage);
            }
            else if (this._pages.length > 1) {
                if (x === 0) {
                    return this._pages[1];
                }
                else {
                    return this._pages[0];
                }
            }
            else {
                return BTreePage.empty();
            }
        };
        BTreeNode.prototype.removedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldKnots.length - 1);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i - 1] = oldKnots[i];
                }
            }
            else {
                for (var i = 1; i < oldKnots.length; i += 1) {
                    newKnots[i - 1] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                var newSize = this._size;
                if (lower < newSize) {
                    var oldPages = this._pages;
                    var x = 0;
                    while (x < oldPages.length) {
                        var size = oldPages[x].size;
                        if (size <= lower) {
                            newSize -= size;
                            lower -= size;
                            x += 1;
                        }
                        else {
                            break;
                        }
                    }
                    var newArity = oldPages.length - x;
                    if (newArity > 1) {
                        var newNode = void 0;
                        if (x > 0) {
                            var newPages = new Array(newArity);
                            for (var i = 0; i < newArity; i += 1) {
                                newPages[i] = oldPages[i + x];
                            }
                            var newKnots = new Array(newArity - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i + x];
                            }
                            newNode = this.newNode(newPages, newKnots, void 0, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (lower > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.drop(lower, tree);
                            return newNode.replacedPage(0, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else {
                        return oldPages[x].drop(lower, tree);
                    }
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.take = function (upper, tree) {
            if (upper < this._size) {
                if (upper > 0) {
                    var oldPages = this._pages;
                    var x = 0;
                    var newSize = 0;
                    while (x < oldPages.length && upper > 0) {
                        var size = oldPages[x].size;
                        newSize += size;
                        x += 1;
                        if (size <= upper) {
                            upper -= size;
                        }
                        else {
                            break;
                        }
                    }
                    var newArity = upper === 0 ? x : x + 1;
                    if (newArity > 1) {
                        var newNode = void 0;
                        if (x < oldPages.length) {
                            var newPages = new Array(newArity);
                            for (var i = 0; i < newArity; i += 1) {
                                newPages[i] = oldPages[i];
                            }
                            var newKnots = new Array(newArity - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i];
                            }
                            newNode = this.newNode(newPages, newKnots, void 0, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (upper > 0) {
                            var oldPage = oldPages[x - 1];
                            var newPage = oldPage.take(upper, tree);
                            return newNode.replacedPage(x - 1, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else if (upper > 0) {
                        return oldPages[0].take(upper, tree);
                    }
                    else {
                        return oldPages[0];
                    }
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.balanced = function (tree) {
            if (this._pages.length > 1 && tree.pageShouldSplit(this)) {
                var x = this._knots.length >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newRightPage.minKey();
            return this.newNode(newPages, newKnots, void 0, this._size);
        };
        BTreeNode.prototype.splitLeft = function (x) {
            var oldPages = this._pages;
            var newPages = new Array(x + 1);
            for (var i = 0; i < x + 1; i += 1) {
                newPages[i] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            var newSize = 0;
            for (var i = 0; i <= x; i += 1) {
                newSize += newPages[i].size;
            }
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.splitRight = function (x) {
            var oldPages = this._pages;
            var newArity = oldPages.length - (x + 1);
            var newPages = new Array(newArity);
            for (var i = 0; i < newArity; i += 1) {
                newPages[i] = oldPages[i + (x + 1)];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(newArity - 1);
            for (var i = 0; i < newKnots.length; i += 1) {
                newKnots[i] = oldKnots[i + (x + 1)];
            }
            var newSize = 0;
            for (var i = 0; i < newArity; i += 1) {
                newSize += newPages[i].size;
            }
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.reduced = function (identity, accumulator, combiner) {
            if (this._fold === void 0) {
                var oldPages = this._pages;
                var n = oldPages.length;
                var newPages = new Array(n);
                for (var i = 0; i < n; i += 1) {
                    newPages[i] = oldPages[i].reduced(identity, accumulator, combiner);
                }
                var fold = newPages[0].fold();
                for (var i = 1; i < n; i += 1) {
                    fold = combiner(fold, newPages[i].fold());
                }
                return this.newNode(newPages, this._knots, fold, this._size);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.forEach = function (callback, thisArg, tree) {
            var pages = this._pages;
            for (var i = 0, n = pages.length; i < n; i += 1) {
                var result = pages[i].forEach(callback, thisArg, tree);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        BTreeNode.prototype.entries = function () {
            return new BTree.NodeCursor(this._pages);
        };
        BTreeNode.prototype.reverseEntries = function () {
            return new BTree.NodeCursor(this._pages, this._size, this._pages.length);
        };
        BTreeNode.prototype.lookup = function (key, tree) {
            var lo = 0;
            var hi = this._knots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                var order = tree.compare(key, this._knots[mid]);
                if (order > 0) {
                    lo = mid + 1;
                }
                else if (order < 0) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        BTreeNode.prototype.newNode = function (pages, knots, fold, size) {
            return new BTreeNode(pages, knots, fold, size);
        };
        return BTreeNode;
    }(BTreePage));
    BTree.Node = BTreeNode;

    var BTreeNodeCursor = (function (_super) {
        __extends(BTreeNodeCursor, _super);
        function BTreeNodeCursor(pages, index, pageIndex, subCursor) {
            return _super.call(this, pages, index, pageIndex, subCursor) || this;
        }
        BTreeNodeCursor.prototype.pageSize = function (page) {
            return page.size;
        };
        BTreeNodeCursor.prototype.pageCursor = function (page) {
            return page.entries();
        };
        BTreeNodeCursor.prototype.reversePageCursor = function (page) {
            return page.reverseEntries();
        };
        return BTreeNodeCursor;
    }(NodeCursor));
    BTree.NodeCursor = BTreeNodeCursor;

    var STreeContext = (function () {
        function STreeContext() {
        }
        STreeContext.prototype.identify = function (value) {
            var id = new Uint8Array(6);
            Random.fillBytes(id);
            return id;
        };
        STreeContext.prototype.compare = function (x, y) {
            return Objects.compare(x, y);
        };
        STreeContext.prototype.pageShouldSplit = function (page) {
            return page.arity > this.pageSplitSize;
        };
        STreeContext.prototype.pageShouldMerge = function (page) {
            return page.arity < this.pageSplitSize >>> 1;
        };
        return STreeContext;
    }());
    STreeContext.prototype.pageSplitSize = 32;

    var STree = (function (_super) {
        __extends(STree, _super);
        function STree(root) {
            if (root === void 0) { root = STree.Page.empty(); }
            var _this = _super.call(this) || this;
            _this.root = root;
            return _this;
        }
        Object.defineProperty(STree.prototype, "length", {
            get: function () {
                return this.root.size;
            },
            enumerable: true,
            configurable: true
        });
        STree.prototype.isEmpty = function () {
            return this.root.isEmpty();
        };
        STree.prototype.get = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    return void 0;
                }
            }
            return this.root.get(index);
        };
        STree.prototype.getEntry = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    return void 0;
                }
            }
            return this.root.getEntry(index);
        };
        STree.prototype.set = function (index, newValue, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (index < 0 || index >= oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.updated(index, newValue, this);
            return this;
        };
        STree.prototype.insert = function (index, newValue, id) {
            var oldRoot = this.root;
            if (index < 0 || index > oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.inserted(index, newValue, id, this).balanced(this);
            return this;
        };
        STree.prototype.remove = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (index < 0 || index > oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.removed(index, this);
            return this;
        };
        STree.prototype.push = function () {
            var newValues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newValues[_i] = arguments[_i];
            }
            var newRoot = this.root;
            for (var i = 0; i < newValues.length; i += 1) {
                newRoot = newRoot.inserted(newRoot.size, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return newRoot.size;
        };
        STree.prototype.pop = function () {
            var oldRoot = this.root;
            var index = oldRoot.size - 1;
            if (index >= 0) {
                var oldValue = oldRoot.get(index);
                this.root = oldRoot.removed(index, this);
                return oldValue;
            }
            else {
                return void 0;
            }
        };
        STree.prototype.unshift = function () {
            var newValues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newValues[_i] = arguments[_i];
            }
            var newRoot = this.root;
            for (var i = newValues.length - 1; i >= 0; i -= 1) {
                newRoot = newRoot.inserted(0, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return newRoot.size;
        };
        STree.prototype.shift = function () {
            var oldRoot = this.root;
            if (oldRoot.size > 0) {
                var oldValue = oldRoot.get(0);
                this.root = oldRoot.removed(0, this);
                return oldValue;
            }
            else {
                return void 0;
            }
        };
        STree.prototype.move = function (fromIndex, toIndex, id) {
            if (id !== void 0) {
                fromIndex = this.lookup(id, fromIndex);
                if (fromIndex < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (fromIndex < 0 || fromIndex >= oldRoot.size) {
                throw new RangeError("" + fromIndex);
            }
            if (toIndex < 0 || toIndex >= oldRoot.size) {
                throw new RangeError("" + toIndex);
            }
            if (fromIndex !== toIndex) {
                var entry = oldRoot.getEntry(fromIndex);
                this.root = oldRoot.removed(fromIndex, this)
                    .inserted(toIndex, entry[1], entry[0], this)
                    .balanced(this);
            }
            return this;
        };
        STree.prototype.splice = function (start, deleteCount) {
            var newValues = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newValues[_i - 2] = arguments[_i];
            }
            var newRoot = this.root;
            if (start < 0) {
                start = newRoot.size + start;
            }
            start = Math.min(Math.max(0, start), newRoot.size);
            if (deleteCount === void 0) {
                deleteCount = newRoot.size - start;
            }
            var deleted = [];
            for (var i = start, n = start + deleteCount; i < n; i += 1) {
                deleted.push(newRoot.get(start));
                newRoot = newRoot.removed(start, this);
            }
            for (var i = 0; i < newValues.length; i += 1) {
                newRoot = newRoot.inserted(start + i, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return deleted;
        };
        STree.prototype.drop = function (lower) {
            var oldRoot = this.root;
            if (lower > 0 && oldRoot.size > 0) {
                if (lower < oldRoot.size) {
                    this.root = oldRoot.drop(lower, this);
                }
                else {
                    this.root = STree.Page.empty();
                }
            }
            return this;
        };
        STree.prototype.take = function (upper) {
            var oldRoot = this.root;
            if (upper < oldRoot.size && oldRoot.size > 0) {
                if (upper > 0) {
                    this.root = oldRoot.take(upper, this);
                }
                else {
                    this.root = STree.Page.empty();
                }
            }
            return this;
        };
        STree.prototype.clear = function () {
            this.root = STree.Page.empty();
        };
        STree.prototype.forEach = function (callback, thisArg) {
            return this.root.forEach(callback, thisArg, 0, this);
        };
        STree.prototype.keys = function () {
            return this.root.keys();
        };
        STree.prototype.values = function () {
            return this.root.values();
        };
        STree.prototype.entries = function () {
            return this.root.entries();
        };
        STree.prototype.reverseKeys = function () {
            return this.root.reverseKeys();
        };
        STree.prototype.reverseValues = function () {
            return this.root.reverseValues();
        };
        STree.prototype.reverseEntries = function () {
            return this.root.reverseEntries();
        };
        STree.prototype.clone = function () {
            return this.copy(this.root);
        };
        STree.prototype.copy = function (root) {
            var tree = new STree(root);
            if (tree.identify !== this.identify) {
                tree.identify = this.identify;
            }
            if (tree.compare !== this.compare) {
                tree.compare = this.compare;
            }
            if (tree.pageSplitSize !== this.pageSplitSize) {
                tree.pageSplitSize = this.pageSplitSize;
            }
            return tree;
        };
        STree.prototype.lookup = function (id, start) {
            if (start === void 0) { start = 0; }
            var root = this.root;
            start = Math.min(Math.max(0, start), root.size - 1);
            var index = start;
            do {
                var entry = root.getEntry(index);
                if (entry && this.compare(entry[0], id) === 0) {
                    return index;
                }
                index = (index + 1) % root.size;
            } while (isFinite(index) && index !== start);
            return -1;
        };
        return STree;
    }(STreeContext));
    STree.prototype.pageSplitSize = 32;

    var STreePage = (function () {
        function STreePage() {
        }
        STreePage.prototype.keys = function () {
            return new KeysCursor(this.entries());
        };
        STreePage.prototype.values = function () {
            return new ValuesCursor(this.entries());
        };
        STreePage.prototype.reverseKeys = function () {
            return new KeysCursor(this.reverseEntries());
        };
        STreePage.prototype.reverseValues = function () {
            return new ValuesCursor(this.reverseEntries());
        };
        STreePage.empty = function () {
            if (!STreePage._empty) {
                STreePage._empty = new STree.Leaf([]);
            }
            return STreePage._empty;
        };
        return STreePage;
    }());
    STree.Page = STreePage;

    var STreeLeaf = (function (_super) {
        __extends(STreeLeaf, _super);
        function STreeLeaf(slots) {
            var _this = _super.call(this) || this;
            _this._slots = slots;
            return _this;
        }
        Object.defineProperty(STreeLeaf.prototype, "arity", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(STreeLeaf.prototype, "size", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        STreeLeaf.prototype.isEmpty = function () {
            return this._slots.length === 0;
        };
        STreeLeaf.prototype.get = function (index) {
            var slot = this._slots[index];
            if (slot) {
                return slot[1];
            }
            else {
                return void 0;
            }
        };
        STreeLeaf.prototype.getEntry = function (index) {
            return this._slots[index];
        };
        STreeLeaf.prototype.updated = function (index, newValue, tree) {
            if (index < 0 || index >= this._slots.length) {
                throw new RangeError("" + index);
            }
            return this.updatedItem(index, newValue);
        };
        STreeLeaf.prototype.updatedItem = function (index, newValue) {
            var oldItems = this._slots;
            var oldSlot = oldItems[index];
            if (newValue !== oldSlot[1]) {
                var newValues = oldItems.slice(0);
                newValues[index] = [oldSlot[0], newValue];
                return new STreeLeaf(newValues);
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.inserted = function (index, newValue, id, tree) {
            if (index < 0 || index > this._slots.length) {
                throw new RangeError("" + index);
            }
            return this.insertedItem(index, newValue, id, tree);
        };
        STreeLeaf.prototype.insertedItem = function (index, newValue, id, tree) {
            if (id === void 0) {
                id = tree.identify(newValue);
            }
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length + 1);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            newSlots[index] = [id, newValue];
            for (var i = index; i < oldSlots.length; i += 1) {
                newSlots[i + 1] = oldSlots[i];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.removed = function (index, tree) {
            if (index < 0 || index >= this._slots.length) {
                throw new RangeError("" + index);
            }
            if (this._slots.length > 1) {
                return this.removedSlot(index);
            }
            else {
                return STreePage.empty();
            }
        };
        STreeLeaf.prototype.removedSlot = function (index) {
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length - 1);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            for (var i = index; i < newSlots.length; i += 1) {
                newSlots[i] = oldSlots[i + 1];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.drop = function (lower, tree) {
            var oldSlots = this._slots;
            if (lower > 0 && oldSlots.length > 0) {
                if (lower < oldSlots.length) {
                    var size = oldSlots.length - lower;
                    var newSlots = new Array(size);
                    for (var i = 0; i < size; i += 1) {
                        newSlots[i] = oldSlots[i + lower];
                    }
                    return new STreeLeaf(newSlots);
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.take = function (upper, tree) {
            var oldSlots = this._slots;
            if (upper < oldSlots.length && oldSlots.length > 0) {
                if (upper > 0) {
                    var newSlots = new Array(upper);
                    for (var i = 0; i < upper; i += 1) {
                        newSlots[i] = oldSlots[i];
                    }
                    return new STreeLeaf(newSlots);
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.balanced = function (tree) {
            var size = this._slots.length;
            if (size > 1 && tree.pageShouldSplit(this)) {
                return this.split(size >>> 1);
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.split = function (index) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(index);
            var newRightPage = this.splitRight(index);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = index;
            return new STree.Node(newPages, newKnots, this._slots.length);
        };
        STreeLeaf.prototype.splitLeft = function (index) {
            var oldSlots = this._slots;
            var newSlots = new Array(index);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.splitRight = function (index) {
            var oldSlots = this._slots;
            var newSize = oldSlots.length - index;
            var newSlots = new Array(newSize);
            for (var i = 0; i < newSize; i += 1) {
                newSlots[i] = oldSlots[i + index];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.forEach = function (callback, thisArg, offset, tree) {
            for (var i = 0; i < this._slots.length; i += 1) {
                var slot = this._slots[i];
                var result = callback.call(thisArg, slot[1], offset + i, tree, slot[0]);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        STreeLeaf.prototype.entries = function () {
            return Cursor.array(this._slots);
        };
        STreeLeaf.prototype.reverseEntries = function () {
            return Cursor.array(this._slots, this._slots.length);
        };
        return STreeLeaf;
    }(STreePage));
    STree.Leaf = STreeLeaf;

    var STreeNode = (function (_super) {
        __extends(STreeNode, _super);
        function STreeNode(pages, knots, size) {
            var _this = _super.call(this) || this;
            _this._pages = pages;
            if (knots === void 0 || size === void 0) {
                knots = new Array(pages.length - 1);
                size = 0;
                for (var i = 0, n = knots.length; i < n; i += 1) {
                    size += pages[i].size;
                    knots[i] = size;
                }
                size += pages[knots.length].size;
            }
            _this._knots = knots;
            _this._size = size;
            return _this;
        }
        Object.defineProperty(STreeNode.prototype, "arity", {
            get: function () {
                return this._pages.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(STreeNode.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        STreeNode.prototype.isEmpty = function () {
            return this._size === 0;
        };
        STreeNode.prototype.get = function (index) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            return this._pages[x].get(i);
        };
        STreeNode.prototype.getEntry = function (index) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            return this._pages[x].getEntry(i);
        };
        STreeNode.prototype.updated = function (index, newValue, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.updated(i, newValue, tree);
            if (oldPage !== newPage) {
                if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.updatedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = oldPages.slice(0);
            newPages[x] = newPage;
            var oldKnots = this._knots;
            var newKnots;
            var newSize;
            if (oldPages.length - 1 > 0) {
                newKnots = oldKnots.slice(0);
                if (x > 0) {
                    newSize = oldKnots[x - 1];
                }
                else {
                    newSize = 0;
                }
                for (var i = x; i < newKnots.length; i += 1) {
                    newSize += newPages[i].size;
                    newKnots[i] = newSize;
                }
                newSize += newPages[newKnots.length].size;
            }
            else {
                newKnots = [];
                newSize = 0;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.updatedPageSplit = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length + 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            var newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
            var newRightPage = newPage.splitRight(newPage.arity >>> 1);
            newPages[x] = newLeftPage;
            newPages[x + 1] = newRightPage;
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + 1] = oldPages[i];
            }
            return new STreeNode(newPages);
        };
        STreeNode.prototype.updatedPageMerge = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var midPages = newPage._pages;
            var newPages = new Array(oldPages.length + midPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = 0; i < midPages.length; i += 1) {
                newPages[i + x] = midPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + midPages.length - 1] = oldPages[i];
            }
            return new STreeNode(newPages);
        };
        STreeNode.prototype.inserted = function (index, newValue, id, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var subIndex = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.inserted(subIndex, newValue, id, tree);
            if (oldPage !== newPage) {
                if (tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.removed = function (index, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var subIndex = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.removed(subIndex, tree);
            if (oldPage !== newPage) {
                return this.replacedPage(x, newPage, oldPage, tree);
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.replacedPage = function (x, newPage, oldPage, tree) {
            if (!newPage.isEmpty()) {
                if (newPage instanceof STreeNode && tree.pageShouldMerge(newPage)) {
                    return this.updatedPageMerge(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else if (this._pages.length > 2) {
                return this.removedPage(x, newPage, oldPage);
            }
            else if (this._pages.length > 1) {
                if (x === 0) {
                    return this._pages[1];
                }
                else {
                    return this._pages[0];
                }
            }
            else {
                return STreePage.empty();
            }
        };
        STreeNode.prototype.removedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldKnots.length - 1);
            var newSize;
            if (x > 0) {
                for (var i = 0; i < x; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newSize = oldKnots[x - 1];
            }
            else {
                newSize = 0;
            }
            for (var i = x; i < newKnots.length; i += 1) {
                newSize += newPages[i].size;
                newKnots[i] = newSize;
            }
            newSize += newPages[newKnots.length].size;
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                if (lower < this._size) {
                    var x = this.lookup(lower);
                    if (x >= 0) {
                        x += 1;
                    }
                    else {
                        x = -(x + 1);
                    }
                    lower = x === 0 ? lower : lower - this._knots[x - 1];
                    var oldPages = this._pages;
                    var n = oldPages.length - x;
                    if (n > 1) {
                        var newNode = void 0;
                        if (x > 0) {
                            var newPages = new Array(n);
                            for (var i = 0; i < n; i += 1) {
                                newPages[i] = oldPages[i + x];
                            }
                            newNode = new STreeNode(newPages);
                        }
                        else {
                            newNode = this;
                        }
                        if (lower > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.drop(lower, tree);
                            return newNode.replacedPage(0, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else {
                        return oldPages[x].drop(lower, tree);
                    }
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.take = function (upper, tree) {
            if (upper < this._size) {
                if (upper > 0) {
                    var x = this.lookup(upper);
                    if (x >= 0) {
                        x += 1;
                    }
                    else {
                        x = -(x + 1);
                    }
                    upper = x === 0 ? upper : upper - this._knots[x - 1];
                    var oldPages = this._pages;
                    var n = upper === 0 ? x : x + 1;
                    if (n > 1) {
                        var newNode = void 0;
                        if (x < oldPages.length) {
                            var newPages = new Array(n);
                            for (var i = 0; i < n; i += 1) {
                                newPages[i] = oldPages[i];
                            }
                            var newKnots = new Array(n - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i];
                            }
                            var newSize = newKnots[n - 2] + newPages[n - 1].size;
                            newNode = new STreeNode(newPages, newKnots, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (upper > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.take(upper, tree);
                            return newNode.replacedPage(x, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else if (upper > 0) {
                        return oldPages[0].take(upper, tree);
                    }
                    else {
                        return oldPages[0];
                    }
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.balanced = function (tree) {
            if (this._pages.length > 1 && tree.pageShouldSplit(this)) {
                var x = this._knots.length >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newLeftPage._size;
            return new STreeNode(newPages, newKnots, this._size);
        };
        STreeNode.prototype.splitLeft = function (x) {
            var oldPages = this._pages;
            var newPages = new Array(x + 1);
            for (var i = 0; i < x + 1; i += 1) {
                newPages[i] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            var newSize = 0;
            for (var i = 0; i <= x; i += 1) {
                newSize += newPages[i].size;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.splitRight = function (x) {
            var oldPages = this._pages;
            var y = oldPages.length - (x + 1);
            var newPages = new Array(y);
            for (var i = 0; i < y; i += 1) {
                newPages[i] = oldPages[i + (x + 1)];
            }
            var newKnots = new Array(y - 1);
            var newSize;
            if (y > 0) {
                newSize = newPages[0].size;
                for (var i = 1; i < y; i += 1) {
                    newKnots[i - 1] = newSize;
                    newSize += newPages[i].size;
                }
            }
            else {
                newSize = 0;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.forEach = function (callback, thisArg, offset, tree) {
            for (var i = 0; i < this._pages.length; i += 1) {
                var page = this._pages[i];
                var result = page.forEach(callback, thisArg, offset, tree);
                if (result !== void 0) {
                    return result;
                }
                offset += page.size;
            }
            return void 0;
        };
        STreeNode.prototype.entries = function () {
            return new STree.NodeCursor(this._pages);
        };
        STreeNode.prototype.reverseEntries = function () {
            return new STree.NodeCursor(this._pages, this._size, this._pages.length);
        };
        STreeNode.prototype.lookup = function (index) {
            var lo = 0;
            var hi = this._knots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                if (index > this._knots[mid]) {
                    lo = mid + 1;
                }
                else if (index < this._knots[mid]) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        return STreeNode;
    }(STreePage));
    STree.Node = STreeNode;

    var STreeNodeCursor = (function (_super) {
        __extends(STreeNodeCursor, _super);
        function STreeNodeCursor(pages, index, pageIndex, subCursor) {
            return _super.call(this, pages, index, pageIndex, subCursor) || this;
        }
        STreeNodeCursor.prototype.pageSize = function (page) {
            return page.size;
        };
        STreeNodeCursor.prototype.pageCursor = function (page) {
            return page.entries();
        };
        STreeNodeCursor.prototype.reversePageCursor = function (page) {
            return page.reverseEntries();
        };
        return STreeNodeCursor;
    }(NodeCursor));
    STree.NodeCursor = STreeNodeCursor;

    var Item = (function () {
        function Item() {
        }
        Item.prototype.updated = function (key, value) {
            var record = Item.Record.create(2);
            record.push(this);
            record.set(key, value);
            return record;
        };
        Item.prototype.updatedAttr = function (key, value) {
            var record = Item.Record.create(2);
            record.push(this);
            record.setAttr(key, value);
            return record;
        };
        Item.prototype.updatedSlot = function (key, value) {
            var record = Item.Record.create(2);
            record.push(this);
            record.setSlot(key, value);
            return record;
        };
        Item.prototype.appended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = Item.Record.create(1 + arguments.length);
            record.push(this);
            record.push.apply(record, arguments);
            return record;
        };
        Item.prototype.prepended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = Item.Record.create(arguments.length + 1);
            record.push.apply(record, arguments);
            record.push(this);
            return record;
        };
        Item.prototype.concat = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = Item.Record.create();
            record.push(this);
            for (var i = 0, n = arguments.length; i < n; i += 1) {
                Item.fromAny(arguments[i]).forEach(function (item) {
                    record.push(item);
                });
            }
            return record;
        };
        Item.prototype.lt = function (that) {
            that = Item.fromAny(that);
            return this.compareTo(that) < 0 ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.le = function (that) {
            that = Item.fromAny(that);
            return this.compareTo(that) <= 0 ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.eq = function (that) {
            that = Item.fromAny(that);
            return this.equals(that) ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.ne = function (that) {
            that = Item.fromAny(that);
            return !this.equals(that) ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.ge = function (that) {
            that = Item.fromAny(that);
            return this.compareTo(that) >= 0 ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.gt = function (that) {
            that = Item.fromAny(that);
            return this.compareTo(that) > 0 ? Item.Bool.from(true) : Item.absent();
        };
        Item.prototype.invoke = function (args) {
            return Item.absent();
        };
        Item.prototype.filter = function (predicate) {
            var selector = Item.Selector.literal(this);
            return selector.filter.apply(selector, arguments);
        };
        Item.prototype.max = function (that) {
            return this.compareTo(that) >= 0 ? this : that;
        };
        Item.prototype.min = function (that) {
            return this.compareTo(that) <= 0 ? this : that;
        };
        Item.prototype.evaluate = function (interpreter) {
            return this;
        };
        Item.prototype.substitute = function (interpreter) {
            return this;
        };
        Item.prototype.cast = function (form, orElse) {
            var object = form.cast(this);
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        Item.prototype.coerce = function (form, orElse) {
            var object = form.cast(this);
            if (object === void 0) {
                object = form.unit();
            }
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        Item.prototype.precedence = function () {
            return 11;
        };
        Item.prototype.forEach = function (callback, thisArg) {
            return callback.call(thisArg, this, 0);
        };
        Item.prototype.iterator = function () {
            return Cursor.unary(this);
        };
        Item.prototype.display = function (output) {
            this.debug(output);
        };
        Item.prototype.toString = function () {
            return Format.debug(this);
        };
        Item.empty = function () {
            return Item.Record.empty();
        };
        Item.extant = function () {
            return Item.Extant.extant();
        };
        Item.absent = function () {
            return Item.Absent.absent();
        };
        Item.fromAny = function (item) {
            if (item instanceof Item) {
                return item;
            }
            else {
                return Item.Value.fromAny(item);
            }
        };
        Item.globalScope = function () {
            if (!Item._globalScope) {
                Item._globalScope = Item.Record.create(1)
                    .slot("math", Item.MathModule.scope())
                    .commit();
            }
            return Item._globalScope;
        };
        return Item;
    }());

    var Field = (function (_super) {
        __extends(Field, _super);
        function Field() {
            return _super.call(this) || this;
        }
        Field.prototype.isDefined = function () {
            return true;
        };
        Field.prototype.isDistinct = function () {
            return true;
        };
        Field.prototype.toValue = function () {
            return this.value;
        };
        Field.prototype.tag = function () {
            return void 0;
        };
        Field.prototype.target = function () {
            return this.value;
        };
        Field.prototype.flattened = function () {
            return Item.Value.absent();
        };
        Field.prototype.unflattened = function () {
            return Item.Record.of(this);
        };
        Field.prototype.header = function (tag) {
            return Item.Value.absent();
        };
        Field.prototype.headers = function (tag) {
            return void 0;
        };
        Field.prototype.head = function () {
            return Item.absent();
        };
        Field.prototype.tail = function () {
            return Item.Record.empty();
        };
        Field.prototype.body = function () {
            return Item.Value.absent();
        };
        Object.defineProperty(Field.prototype, "length", {
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Field.prototype.has = function (key) {
            return false;
        };
        Field.prototype.get = function (key) {
            return Item.Value.absent();
        };
        Field.prototype.getAttr = function (key) {
            return Item.Value.absent();
        };
        Field.prototype.getSlot = function (key) {
            return Item.Value.absent();
        };
        Field.prototype.getField = function (key) {
            return void 0;
        };
        Field.prototype.getItem = function (index) {
            return Item.absent();
        };
        Field.prototype.deleted = function (key) {
            return this;
        };
        Field.prototype.conditional = function (thenTerm, elseTerm) {
            thenTerm = Item.fromAny(thenTerm);
            return thenTerm;
        };
        Field.prototype.or = function (that) {
            return this;
        };
        Field.prototype.and = function (that) {
            that = Item.fromAny(that);
            return that;
        };
        Field.prototype.lambda = function (template) {
            return Item.Value.absent();
        };
        Field.prototype.stringValue = function (orElse) {
            return this.value.stringValue(orElse);
        };
        Field.prototype.numberValue = function (orElse) {
            return this.value.numberValue(orElse);
        };
        Field.prototype.booleanValue = function (orElse) {
            return this.value.booleanValue(orElse);
        };
        Field.of = function (key, value) {
            var name;
            if (typeof key === "string") {
                name = key;
            }
            else if (key instanceof Item.Text) {
                name = key.value;
            }
            if (name !== void 0 && name.charCodeAt(0) === 64) {
                arguments[0] = name.slice(1);
                return Item.Attr.of.apply(undefined, arguments);
            }
            else {
                return Item.Slot.of.apply(undefined, arguments);
            }
        };
        Field.fromAny = function (field) {
            if (field instanceof Field) {
                return field;
            }
            else if (field && typeof field === "object") {
                if (field.$key !== void 0) {
                    return Field.of(field.$key, field.$value);
                }
                else {
                    for (var key in field) {
                        return Field.of(key, field[key]);
                    }
                }
            }
            throw new TypeError("" + field);
        };
        Field.IMMUTABLE = 1 << 0;
        return Field;
    }(Item));
    Item.Field = Field;

    var InterpreterException = (function (_super) {
        __extends(InterpreterException, _super);
        function InterpreterException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = InterpreterException.prototype;
            return _this;
        }
        return InterpreterException;
    }(Error));

    var InterpreterSettings = (function () {
        function InterpreterSettings(maxScopeDepth) {
            this._maxScopeDepth = maxScopeDepth;
        }
        InterpreterSettings.prototype.maxScopeDepth = function (maxScopeDepth) {
            if (maxScopeDepth === void 0) {
                return this._maxScopeDepth;
            }
            else {
                return this.copy(maxScopeDepth);
            }
        };
        InterpreterSettings.prototype.copy = function (maxScopeDepth) {
            return new InterpreterSettings(maxScopeDepth);
        };
        InterpreterSettings.prototype.canEqual = function (that) {
            return that instanceof InterpreterSettings;
        };
        InterpreterSettings.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof InterpreterSettings) {
                return that.canEqual(this) && this._maxScopeDepth === that._maxScopeDepth;
            }
            return false;
        };
        InterpreterSettings.prototype.hashCode = function () {
            if (InterpreterSettings._hashSeed === void 0) {
                InterpreterSettings._hashSeed = Murmur3.seed(InterpreterSettings);
            }
            return Murmur3.mash(Murmur3.mix(InterpreterSettings._hashSeed, this._maxScopeDepth));
        };
        InterpreterSettings.prototype.debug = function (output) {
            output = output.write("new").write(32).write("InterpreterSettings")
                .write(40).debug(this._maxScopeDepth).write(41);
        };
        InterpreterSettings.prototype.toString = function () {
            return Format.debug(this);
        };
        InterpreterSettings.standard = function () {
            if (!InterpreterSettings._standard) {
                var maxScopeDepth = 1024;
                InterpreterSettings._standard = new InterpreterSettings(maxScopeDepth);
            }
            return InterpreterSettings._standard;
        };
        return InterpreterSettings;
    }());

    var Interpreter = (function () {
        function Interpreter(settings, scopeStack, scopeDepth) {
            if (settings === void 0) { settings = InterpreterSettings.standard(); }
            if (scopeStack === void 0) { scopeStack = null; }
            if (scopeDepth === void 0) { scopeDepth = 0; }
            this._settings = settings;
            this._scopeStack = scopeStack;
            this._scopeDepth = scopeDepth;
        }
        Interpreter.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = settings;
                return this;
            }
        };
        Interpreter.prototype.scopeDepth = function () {
            return this._scopeDepth;
        };
        Interpreter.prototype.peekScope = function () {
            var scopeDepth = this._scopeDepth;
            if (scopeDepth <= 0) {
                throw new InterpreterException("scope stack empty");
            }
            return this._scopeStack[scopeDepth - 1];
        };
        Interpreter.prototype.getScope = function (index) {
            if (index < 0 || index >= this._scopeDepth) {
                throw new RangeError("" + index);
            }
            return this._scopeStack[index];
        };
        Interpreter.prototype.pushScope = function (scope) {
            var scopeDepth = this._scopeDepth;
            if (scopeDepth >= this._settings._maxScopeDepth) {
                throw new InterpreterException("scope stack overflow");
            }
            var oldScopeStack = this._scopeStack;
            var newScopeStack;
            if (oldScopeStack === null || scopeDepth + 1 > oldScopeStack.length) {
                newScopeStack = new Array(Interpreter.expand(scopeDepth + 1));
                if (oldScopeStack != null) {
                    for (var i = 0; i < scopeDepth; i += 1) {
                        newScopeStack[i] = oldScopeStack[i];
                    }
                }
                this._scopeStack = newScopeStack;
            }
            else {
                newScopeStack = oldScopeStack;
            }
            newScopeStack[scopeDepth] = scope;
            this._scopeDepth = scopeDepth + 1;
        };
        Interpreter.prototype.popScope = function () {
            var scopeDepth = this._scopeDepth;
            if (scopeDepth <= 0) {
                throw new InterpreterException("scope stack empty");
            }
            var scopeStack = this._scopeStack;
            var scope = scopeStack[scopeDepth - 1];
            scopeStack[scopeDepth - 1] = void 0;
            this._scopeDepth = scopeDepth - 1;
            return scope;
        };
        Interpreter.prototype.swapScope = function (newScope) {
            var scopeDepth = this._scopeDepth;
            if (scopeDepth <= 0) {
                throw new InterpreterException("scope stack empty");
            }
            var scopeStack = this._scopeStack;
            var oldScope = scopeStack[scopeDepth - 1];
            scopeStack[scopeDepth - 1] = newScope;
            return oldScope;
        };
        Interpreter.prototype.willOperate = function (operator) {
        };
        Interpreter.prototype.didOperate = function (operator, result) {
        };
        Interpreter.prototype.willSelect = function (selector) {
        };
        Interpreter.prototype.didSelect = function (selector, result) {
        };
        Interpreter.prototype.willTransform = function (selector) {
        };
        Interpreter.prototype.didTransform = function (selector, result) {
        };
        Interpreter.of = function () {
            var objects = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                objects[_i] = arguments[_i];
            }
            var n = arguments.length;
            var scopes = new Array(Interpreter.expand(n));
            for (var i = 0; i < n; i += 1) {
                var scope = Item.fromAny(arguments[i]);
                scopes[i] = scope;
            }
            return new Interpreter(InterpreterSettings.standard(), scopes, n);
        };
        Interpreter.fromAny = function (interpreter, globalScope) {
            if (globalScope === void 0) { globalScope = Item.globalScope(); }
            if (!(interpreter instanceof Interpreter)) {
                var scope = interpreter;
                interpreter = new Interpreter();
                if (globalScope) {
                    interpreter.pushScope(globalScope);
                }
                if (scope !== void 0) {
                    interpreter.pushScope(Item.fromAny(scope));
                }
            }
            return interpreter;
        };
        Interpreter.expand = function (n) {
            n = Math.max(32, n) - 1;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        };
        return Interpreter;
    }());

    var Attr = (function (_super) {
        __extends(Attr, _super);
        function Attr(key, value, flags) {
            if (value === void 0) { value = Item.Value.extant(); }
            if (flags === void 0) { flags = 0; }
            var _this = _super.call(this) || this;
            _this._key = key;
            _this._value = value;
            _this._flags = flags;
            return _this;
        }
        Attr.prototype.isConstant = function () {
            return this._key.isConstant() && this._value.isConstant();
        };
        Object.defineProperty(Attr.prototype, "name", {
            get: function () {
                return this._key.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attr.prototype, "key", {
            get: function () {
                return this._key;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attr.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Attr.prototype.setValue = function (newValue) {
            if ((this._flags & Field.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            var oldValue = this._value;
            this._value = newValue;
            return oldValue;
        };
        Attr.prototype.updatedValue = function (value) {
            return new Attr(this._key, value);
        };
        Attr.prototype.bitwiseOr = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseOrOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.bitwiseOr(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseOr(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.bitwiseXor = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseXorOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.bitwiseXor(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseXor(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.bitwiseAnd = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseAndOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.bitwiseAnd(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseAnd(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.plus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.PlusOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.plus(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.plus(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.minus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.MinusOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.minus(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.minus(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.times = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.TimesOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.times(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.times(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.divide = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.DivideOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.divide(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.divide(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.modulo = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.ModuloOperator(this, that);
            }
            var newValue;
            if (that instanceof Attr && this._key.equals(that._key)) {
                newValue = this._value.modulo(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.modulo(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.not = function () {
            var newValue = this._value.not();
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.bitwiseNot = function () {
            var newValue = this._value.bitwiseNot();
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.negative = function () {
            var newValue = this._value.negative();
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.positive = function () {
            var newValue = this._value.positive();
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.inverse = function () {
            var newValue = this._value.inverse();
            if (newValue.isDefined()) {
                return new Attr(this._key, newValue);
            }
            return Item.absent();
        };
        Attr.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key.evaluate(interpreter).toValue();
            var value = this._value.evaluate(interpreter).toValue();
            if (key === this._key && value === this._value) {
                return this;
            }
            else if (key.isDefined() && value.isDefined()) {
                if (key instanceof Item.Text) {
                    return new Attr(key, value);
                }
                else {
                    return new Item.Slot(key, value);
                }
            }
            return Item.absent();
        };
        Attr.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key.substitute(interpreter).toValue();
            var value = this._value.substitute(interpreter).toValue();
            if (key === this._key && value === this._value) {
                return this;
            }
            else if (key.isDefined() && value.isDefined()) {
                if (key instanceof Item.Text) {
                    return new Attr(key, value);
                }
                else {
                    return new Item.Slot(key, value);
                }
            }
            return Item.absent();
        };
        Attr.prototype.toAny = function () {
            var field = {};
            field["@" + this._key.value] = this._value.toAny();
            return field;
        };
        Attr.prototype.isAliased = function () {
            return false;
        };
        Attr.prototype.isMutable = function () {
            return (this._flags & Field.IMMUTABLE) === 0;
        };
        Attr.prototype.alias = function () {
            this._flags |= Field.IMMUTABLE;
        };
        Attr.prototype.branch = function () {
            if ((this._flags & Field.IMMUTABLE) !== 0) {
                return new Attr(this._key, this._value, this._flags & ~Field.IMMUTABLE);
            }
            else {
                return this;
            }
        };
        Attr.prototype.clone = function () {
            return new Attr(this._key.clone(), this._value.clone());
        };
        Attr.prototype.commit = function () {
            if ((this._flags & Field.IMMUTABLE) === 0) {
                this._flags |= Field.IMMUTABLE;
                this._value.commit();
            }
            return this;
        };
        Attr.prototype.typeOrder = function () {
            return 1;
        };
        Attr.prototype.compareTo = function (that) {
            if (that instanceof Attr) {
                var order = this._key.compareTo(that._key);
                if (order === 0) {
                    order = this._value.compareTo(that._value);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Attr.prototype.keyEquals = function (key) {
            if (typeof key === "string") {
                return this._key.value === key;
            }
            else if (key instanceof Field) {
                return this._key.equals(key.key);
            }
            else {
                return this._key.equals(key);
            }
        };
        Attr.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Attr) {
                return this._key.equals(that._key) && this._value.equals(that._value);
            }
            return false;
        };
        Attr.prototype.hashCode = function () {
            if (Attr._hashSeed === void 0) {
                Attr._hashSeed = Murmur3.seed(Attr);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Attr._hashSeed, this._key.hashCode()), this._value.hashCode()));
        };
        Attr.prototype.debug = function (output) {
            output = output.write("Attr").write(46).write("of").write(40).display(this.key);
            if (!(this.value instanceof Item.Extant)) {
                output = output.write(44).write(32).display(this.value);
            }
            output = output.write(41);
        };
        Attr.prototype.display = function (output) {
            this.debug(output);
        };
        Attr.of = function (key, value) {
            key = Item.Text.fromAny(key);
            value = (arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant());
            return new Attr(key, value);
        };
        return Attr;
    }(Field));
    Item.Attr = Attr;

    var Slot = (function (_super) {
        __extends(Slot, _super);
        function Slot(key, value, flags) {
            if (value === void 0) { value = Item.Value.extant(); }
            if (flags === void 0) { flags = 0; }
            var _this = _super.call(this) || this;
            _this._key = key.commit();
            _this._value = value;
            _this._flags = flags;
            return _this;
        }
        Object.defineProperty(Slot.prototype, "key", {
            get: function () {
                return this._key;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Slot.prototype.isConstant = function () {
            return this._key.isConstant() && this._value.isConstant();
        };
        Slot.prototype.setValue = function (newValue) {
            if ((this._flags & Field.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            var oldValue = this._value;
            this._value = newValue;
            return oldValue;
        };
        Slot.prototype.updatedValue = function (value) {
            return new Slot(this._key, value);
        };
        Slot.prototype.bitwiseOr = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseOrOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.bitwiseOr(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseOr(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.bitwiseXor = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseXorOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.bitwiseXor(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseXor(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.bitwiseAnd = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseAndOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.bitwiseAnd(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.bitwiseAnd(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.plus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.PlusOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.plus(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.plus(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.minus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.MinusOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.minus(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.minus(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.times = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.TimesOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.times(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.times(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.divide = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.DivideOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.divide(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.divide(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.modulo = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.ModuloOperator(this, that);
            }
            var newValue;
            if (that instanceof Slot && this._key.equals(that._key)) {
                newValue = this._value.modulo(that._value);
            }
            else if (that instanceof Item.Value) {
                newValue = this._value.modulo(that);
            }
            else {
                newValue = Item.Value.absent();
            }
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.not = function () {
            var newValue = this._value.not();
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.bitwiseNot = function () {
            var newValue = this._value.bitwiseNot();
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.negative = function () {
            var newValue = this._value.negative();
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.positive = function () {
            var newValue = this._value.positive();
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.inverse = function () {
            var newValue = this._value.inverse();
            if (newValue.isDefined()) {
                return new Slot(this._key, newValue);
            }
            return Item.absent();
        };
        Slot.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key.evaluate(interpreter).toValue();
            var value = this._value.evaluate(interpreter).toValue();
            if (key === this._key && value === this._value) {
                return this;
            }
            else if (key.isDefined() && value.isDefined()) {
                return new Slot(key, value);
            }
            return Item.absent();
        };
        Slot.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key.substitute(interpreter).toValue();
            var value = this._value.substitute(interpreter).toValue();
            if (key === this._key && value === this._value) {
                return this;
            }
            else if (key.isDefined() && value.isDefined()) {
                return new Slot(key, value);
            }
            return Item.absent();
        };
        Slot.prototype.toAny = function () {
            var field = {};
            if (this._key instanceof Item.Text) {
                field[this._key.value] = this._value.toAny();
            }
            else {
                field.$key = this._key.toAny();
                field.$value = this._value.toAny();
            }
            return field;
        };
        Slot.prototype.isAliased = function () {
            return false;
        };
        Slot.prototype.isMutable = function () {
            return (this._flags & Field.IMMUTABLE) === 0;
        };
        Slot.prototype.alias = function () {
            this._flags |= Field.IMMUTABLE;
        };
        Slot.prototype.branch = function () {
            if ((this._flags & Field.IMMUTABLE) !== 0) {
                return new Slot(this._key, this._value, this._flags & ~Field.IMMUTABLE);
            }
            else {
                return this;
            }
        };
        Slot.prototype.clone = function () {
            return new Slot(this._key.clone(), this._value.clone());
        };
        Slot.prototype.commit = function () {
            if ((this._flags & Field.IMMUTABLE) === 0) {
                this._flags |= Field.IMMUTABLE;
                this._value.commit();
            }
            return this;
        };
        Slot.prototype.typeOrder = function () {
            return 2;
        };
        Slot.prototype.compareTo = function (that) {
            if (that instanceof Slot) {
                var order = this._key.compareTo(that._key);
                if (order === 0) {
                    order = this._value.compareTo(that._value);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Slot.prototype.keyEquals = function (key) {
            if (typeof key === "string" && this._key instanceof Item.Text) {
                return this._key.value === key;
            }
            else if (key instanceof Field) {
                return this._key.equals(key.key);
            }
            else {
                return this._key.equals(key);
            }
        };
        Slot.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Slot) {
                return this._key.equals(that._key) && this._value.equals(that._value);
            }
            return false;
        };
        Slot.prototype.hashCode = function () {
            if (Slot._hashSeed === void 0) {
                Slot._hashSeed = Murmur3.seed(Slot);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Slot._hashSeed, this._key.hashCode()), this._value.hashCode()));
        };
        Slot.prototype.debug = function (output) {
            output = output.write("Slot").write(46).write("of").write(40).display(this.key);
            if (!(this.value instanceof Item.Extant)) {
                output = output.write(44).write(32).display(this.value);
            }
            output = output.write(41);
        };
        Slot.prototype.display = function (output) {
            this.debug(output);
        };
        Slot.of = function (key, value) {
            key = Item.Value.fromAny(key);
            value = arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant();
            return new Slot(key, value);
        };
        return Slot;
    }(Field));
    Item.Slot = Slot;

    var ValueBuilder = (function () {
        function ValueBuilder() {
            this._record = null;
            this._value = null;
        }
        ValueBuilder.prototype.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            for (var i = 0, n = arguments.length; i < n; i += 1) {
                var item = arguments[i];
                if (item instanceof Field) {
                    return this.pushField(item);
                }
                else if (item instanceof Value) {
                    return this.pushValue(item);
                }
                else {
                    throw new TypeError("" + item);
                }
            }
        };
        ValueBuilder.prototype.pushField = function (item) {
            if (this._record === null) {
                this._record = Item.Record.create();
                if (this._value !== null) {
                    this._record.push(this._value);
                    this._value = null;
                }
            }
            this._record.push(item);
        };
        ValueBuilder.prototype.pushValue = function (item) {
            if (this._record != null) {
                this._record.push(item);
            }
            else if (this._value == null) {
                this._value = item;
            }
            else {
                this._record = Item.Record.create();
                this._record.push(this._value);
                this._value = null;
                this._record.push(item);
            }
        };
        ValueBuilder.prototype.bind = function () {
            if (this._record !== null) {
                return this._record;
            }
            else if (this._value !== null) {
                return this._value;
            }
            else {
                return Value.absent();
            }
        };
        return ValueBuilder;
    }());

    var Value = (function (_super) {
        __extends(Value, _super);
        function Value() {
            return _super.call(this) || this;
        }
        Value.prototype.isDefined = function () {
            return true;
        };
        Value.prototype.isDistinct = function () {
            return true;
        };
        Object.defineProperty(Value.prototype, "key", {
            get: function () {
                return Value.absent();
            },
            enumerable: true,
            configurable: true
        });
        Value.prototype.toValue = function () {
            return this;
        };
        Value.prototype.tag = function () {
            return void 0;
        };
        Value.prototype.target = function () {
            return this;
        };
        Value.prototype.flattened = function () {
            return this;
        };
        Value.prototype.unflattened = function () {
            return Value.Record.of(this);
        };
        Value.prototype.header = function (tag) {
            return Value.absent();
        };
        Value.prototype.headers = function (tag) {
            return void 0;
        };
        Value.prototype.head = function () {
            return Item.absent();
        };
        Value.prototype.tail = function () {
            return Value.Record.empty();
        };
        Value.prototype.body = function () {
            return Value.extant();
        };
        Object.defineProperty(Value.prototype, "length", {
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Value.prototype.has = function (key) {
            return false;
        };
        Value.prototype.get = function (key) {
            return Value.absent();
        };
        Value.prototype.getAttr = function (key) {
            return Value.absent();
        };
        Value.prototype.getSlot = function (key) {
            return Value.absent();
        };
        Value.prototype.getField = function (key) {
            return void 0;
        };
        Value.prototype.getItem = function (index) {
            return Item.absent();
        };
        Value.prototype.deleted = function (key) {
            return this;
        };
        Value.prototype.conditional = function (thenTerm, elseTerm) {
            thenTerm = Item.fromAny(thenTerm);
            return thenTerm;
        };
        Value.prototype.or = function (that) {
            return this;
        };
        Value.prototype.and = function (that) {
            that = Item.fromAny(that);
            return that;
        };
        Value.prototype.bitwiseOr = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseOrOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.bitwiseOr(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.bitwiseOr(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.bitwiseXor = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseXorOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.bitwiseXor(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.bitwiseXor(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.bitwiseAnd = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.BitwiseAndOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.bitwiseAnd(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.bitwiseAnd(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.lt = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.LtOperator(this, that);
            }
            return _super.prototype.lt.call(this, that);
        };
        Value.prototype.le = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.LeOperator(this, that);
            }
            return _super.prototype.le.call(this, that);
        };
        Value.prototype.eq = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.EqOperator(this, that);
            }
            return _super.prototype.eq.call(this, that);
        };
        Value.prototype.ne = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.NeOperator(this, that);
            }
            return _super.prototype.ne.call(this, that);
        };
        Value.prototype.ge = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.GeOperator(this, that);
            }
            return _super.prototype.ge.call(this, that);
        };
        Value.prototype.gt = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.GtOperator(this, that);
            }
            return _super.prototype.gt.call(this, that);
        };
        Value.prototype.plus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.PlusOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.plus(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.plus(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.minus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.MinusOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.minus(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.minus(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.times = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.TimesOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.times(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.times(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.divide = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.DivideOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.divide(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.divide(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.modulo = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Item.Expression) {
                return new Item.ModuloOperator(this, that);
            }
            else if (that instanceof Item.Attr) {
                var newValue = this.modulo(that.value);
                if (newValue.isDefined()) {
                    return new Item.Attr(that.key, newValue);
                }
            }
            else if (that instanceof Item.Slot) {
                var newValue = this.modulo(that.value);
                if (newValue.isDefined()) {
                    return new Item.Slot(that.key, newValue);
                }
            }
            return Item.absent();
        };
        Value.prototype.not = function () {
            return Value.absent();
        };
        Value.prototype.bitwiseNot = function () {
            return Value.absent();
        };
        Value.prototype.negative = function () {
            return Value.absent();
        };
        Value.prototype.positive = function () {
            return Value.absent();
        };
        Value.prototype.inverse = function () {
            return Value.absent();
        };
        Value.prototype.lambda = function (template) {
            return new Item.LambdaFunc(this, template);
        };
        Value.prototype.stringValue = function (orElse) {
            return orElse;
        };
        Value.prototype.numberValue = function (orElse) {
            return orElse;
        };
        Value.prototype.booleanValue = function (orElse) {
            return orElse;
        };
        Value.prototype.isAliased = function () {
            return false;
        };
        Value.prototype.isMutable = function () {
            return false;
        };
        Value.prototype.alias = function () {
        };
        Value.prototype.branch = function () {
            return this;
        };
        Value.prototype.clone = function () {
            return this;
        };
        Value.prototype.commit = function () {
            return this;
        };
        Value.prototype.keyEquals = function (key) {
            return false;
        };
        Value.builder = function () {
            return new ValueBuilder();
        };
        Value.empty = function () {
            return Value.Record.empty();
        };
        Value.extant = function () {
            return Value.Extant.extant();
        };
        Value.absent = function () {
            return Value.Absent.absent();
        };
        Value.fromAny = function (value) {
            if (value instanceof Value) {
                return value;
            }
            else if (value === void 0) {
                return Value.Absent.absent();
            }
            else if (value === null) {
                return Value.Extant.extant();
            }
            else if (typeof value === "boolean") {
                return Value.Bool.from(value);
            }
            else if (typeof value === "number") {
                return Value.Num.from(value);
            }
            else if (typeof value === "string") {
                return Value.Text.from(value);
            }
            else if (value instanceof Uint8Array) {
                return Value.Data.wrap(value);
            }
            else if (Array.isArray(value)) {
                return Value.Record.fromArray(value);
            }
            else if (typeof value === "object") {
                return Value.Record.fromObject(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        return Value;
    }(Item));
    Item.Value = Value;

    var RecordCursor = (function (_super) {
        __extends(RecordCursor, _super);
        function RecordCursor(record, lower, upper, index) {
            if (lower === void 0) { lower = 0; }
            if (upper === void 0) { upper = record.length; }
            if (index === void 0) { index = lower; }
            var _this = _super.call(this) || this;
            _this._record = record;
            _this._lower = lower;
            _this._upper = upper;
            _this._index = index;
            _this._direction = 0;
            return _this;
        }
        RecordCursor.prototype.isEmpty = function () {
            return this._index >= this._upper;
        };
        RecordCursor.prototype.head = function () {
            this._direction = 0;
            if (this._index < this._upper) {
                return this._record.getItem(this._index);
            }
            else {
                throw new Error("empty");
            }
        };
        RecordCursor.prototype.step = function () {
            this._direction = 0;
            if (this._index < this._upper) {
                this._index += 1;
            }
            else {
                throw new Error("empty");
            }
        };
        RecordCursor.prototype.skip = function (count) {
            this._index = Math.min(Math.max(this._lower, this._index + count, this._upper));
        };
        RecordCursor.prototype.hasNext = function () {
            return this._index < this._upper;
        };
        RecordCursor.prototype.nextIndex = function () {
            return this._index - this._lower;
        };
        RecordCursor.prototype.next = function () {
            this._direction = 1;
            var index = this._index;
            if (index < this._upper) {
                this._index = index + 1;
                return { value: this._record.getItem(index), done: this._index === this._upper };
            }
            else {
                this._index = this._upper;
                return { done: true };
            }
        };
        RecordCursor.prototype.hasPrevious = function () {
            return this._index > this._lower;
        };
        RecordCursor.prototype.previousIndex = function () {
            return this._index - this._lower - 1;
        };
        RecordCursor.prototype.previous = function () {
            this._direction = -1;
            var index = this._index - 1;
            if (index >= this._lower) {
                this._index = index;
                return { value: this._record.getItem(index), done: index === this._lower };
            }
            else {
                this._index = 0;
                return { done: true };
            }
        };
        RecordCursor.prototype.set = function (newItem) {
            if (this._direction > 0) {
                this._record.setItem(this._index - 1, newItem);
            }
            else {
                this._record.setItem(this._index, newItem);
            }
        };
        RecordCursor.prototype.delete = function () {
            if (this._direction > 0) {
                this._index -= 1;
            }
            this._record.splice(this._index, 1);
            this._direction = 0;
        };
        return RecordCursor;
    }(Cursor));

    var Record = (function (_super) {
        __extends(Record, _super);
        function Record() {
            return _super.call(this) || this;
        }
        Record.prototype.isArray = function () {
            return this.fieldCount() === 0;
        };
        Record.prototype.isObject = function () {
            return this.valueCount() === 0;
        };
        Record.prototype.fieldCount = function () {
            var count = 0;
            this.forEach(function (member) {
                if (member instanceof Item.Field) {
                    count += 1;
                }
            }, this);
            return count;
        };
        Record.prototype.valueCount = function () {
            var count = 0;
            this.forEach(function (member) {
                if (member instanceof Value) {
                    count += 1;
                }
            }, this);
            return count;
        };
        Record.prototype.isConstant = function () {
            return this.forEach(function (member) {
                return member.isConstant() ? void 0 : false;
            }, this) === void 0;
        };
        Record.prototype.tag = function () {
            var item = this.head();
            if (item instanceof Item.Attr) {
                return item.key.value;
            }
            return void 0;
        };
        Record.prototype.target = function () {
            var value;
            var record;
            var modified = false;
            this.forEach(function (item) {
                if (item instanceof Item.Attr) {
                    modified = true;
                }
                else if (value === void 0 && item instanceof Value) {
                    value = item;
                }
                else {
                    if (record === void 0) {
                        record = Record.create();
                        if (value !== void 0) {
                            record.push(value);
                        }
                    }
                    record.push(item);
                }
            }, this);
            if (value === void 0) {
                return Value.extant();
            }
            else if (record === void 0) {
                return value;
            }
            else if (modified) {
                return record;
            }
            else {
                return this;
            }
        };
        Record.prototype.flattened = function () {
            if (this.isEmpty()) {
                return Value.extant();
            }
            else {
                var items = this.iterator();
                var head = items.head();
                items.step();
                if (items.isEmpty() && head instanceof Value) {
                    return head;
                }
                else {
                    return this.branch();
                }
            }
        };
        Record.prototype.unflattened = function () {
            return this;
        };
        Record.prototype.header = function (tag) {
            var head = this.head();
            if (head instanceof Item.Attr && head.key.value === tag) {
                return head.value;
            }
            else {
                return Value.absent();
            }
        };
        Record.prototype.headers = function (tag) {
            var head = this.head();
            if (head instanceof Item.Attr && head.key.value === tag) {
                var header = head.value;
                if (header instanceof Record) {
                    return header;
                }
                else {
                    return Record.of(header);
                }
            }
            return void 0;
        };
        Record.prototype.head = function () {
            return this.forEach(function (item) {
                return item;
            }, this) || Item.absent();
        };
        Record.prototype.tail = function () {
            var tail = Record.create();
            this.forEach(function (item, index) {
                if (index > 0) {
                    tail.push(item);
                }
            }, this);
            return tail;
        };
        Record.prototype.body = function () {
            var tail = this.tail();
            if (!tail.isEmpty()) {
                return tail.flattened();
            }
            else {
                return Value.absent();
            }
        };
        Record.prototype.has = function (key) {
            key = Value.fromAny(key);
            return this.forEach(function (item) {
                return item instanceof Item.Field && item.key.equals(key) ? true : void 0;
            }, this) || false;
        };
        Record.prototype.indexOf = function (item, index) {
            if (index === void 0) { index = 0; }
            item = Item.fromAny(item);
            if (index < 0) {
                index = Math.max(0, this.length + index);
            }
            var i = this.forEach(function (member, i) {
                return i >= index && item.equals(member) ? i : void 0;
            }, this);
            return i !== void 0 ? i : -1;
        };
        Record.prototype.lastIndexOf = function (item, index) {
            item = Item.fromAny(item);
            var n = this.length;
            if (index === void 0) {
                index = n - 1;
            }
            else if (index < 0) {
                index = n + index;
            }
            index = Math.min(index, n - 1);
            while (index >= 0) {
                if (item.equals(this.getItem(index))) {
                    return index;
                }
                index -= 1;
            }
            return -1;
        };
        Record.prototype.get = function (key) {
            key = Value.fromAny(key);
            return this.forEach(function (item) {
                return item instanceof Item.Field && item.key.equals(key) ? item.value : void 0;
            }, this) || Value.absent();
        };
        Record.prototype.getAttr = function (key) {
            key = Value.Text.fromAny(key);
            return this.forEach(function (item) {
                return item instanceof Item.Attr && item.key.equals(key) ? item.value : void 0;
            }, this) || Value.absent();
        };
        Record.prototype.getSlot = function (key) {
            key = Value.fromAny(key);
            return this.forEach(function (item) {
                return item instanceof Item.Slot && item.key.equals(key) ? item.value : void 0;
            }, this) || Value.absent();
        };
        Record.prototype.getField = function (key) {
            key = Value.fromAny(key);
            return this.forEach(function (item) {
                return item instanceof Item.Field && item.key.equals(key) ? item : void 0;
            }, this);
        };
        Record.prototype.set = function (key, newValue) {
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            var items = this.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item instanceof Item.Field && item.key.equals(key)) {
                    if (item.isMutable()) {
                        item.setValue(newValue);
                    }
                    else {
                        items.set(item.updatedValue(newValue));
                    }
                    return this;
                }
                items.step();
            }
            this.push(new Item.Slot(key, newValue));
            return this;
        };
        Record.prototype.setAttr = function (key, newValue) {
            key = Value.Text.fromAny(key);
            newValue = Value.fromAny(newValue);
            var items = this.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item instanceof Item.Field && item.key.equals(key)) {
                    if (item instanceof Item.Attr && item.isMutable()) {
                        item.setValue(newValue);
                    }
                    else {
                        items.set(new Item.Attr(key, newValue));
                    }
                    return this;
                }
                items.step();
            }
            this.push(new Item.Attr(key, newValue));
            return this;
        };
        Record.prototype.setSlot = function (key, newValue) {
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            var items = this.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item instanceof Item.Field && item.key.equals(key)) {
                    if (item instanceof Item.Slot && item.isMutable()) {
                        item.setValue(newValue);
                    }
                    else {
                        items.set(new Item.Slot(key, newValue));
                    }
                    return this;
                }
                items.step();
            }
            this.push(new Item.Slot(key, newValue));
            return this;
        };
        Record.prototype.updated = function (key, value) {
            key = Value.fromAny(key);
            value = Value.fromAny(value);
            var record = this.isMutable() ? this : this.branch();
            var items = record.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item.key.equals(key)) {
                    if (item instanceof Item.Field && item.isMutable()) {
                        item.setValue(value);
                    }
                    else {
                        items.set(new Item.Slot(key, value));
                    }
                    return record;
                }
                items.step();
            }
            record.push(new Item.Slot(key, value));
            return record;
        };
        Record.prototype.updatedAttr = function (key, value) {
            key = Value.Text.fromAny(key);
            value = Value.fromAny(value);
            var record = this.isMutable() ? this : this.branch();
            var items = record.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item.key.equals(key)) {
                    if (item instanceof Item.Attr && item.isMutable()) {
                        item.setValue(value);
                    }
                    else {
                        items.set(new Item.Attr(key, value));
                    }
                    return record;
                }
                items.step();
            }
            record.push(new Item.Attr(key, value));
            return record;
        };
        Record.prototype.updatedSlot = function (key, value) {
            key = Value.fromAny(key);
            value = Value.fromAny(value);
            var record = this.isMutable() ? this : this.branch();
            var items = record.iterator();
            while (!items.isEmpty()) {
                var item = items.head();
                if (item.key.equals(key)) {
                    if (item instanceof Item.Slot && item.isMutable()) {
                        item.setValue(value);
                    }
                    else {
                        items.set(new Item.Slot(key, value));
                    }
                    return record;
                }
                items.step();
            }
            record.push(new Item.Slot(key, value));
            return record;
        };
        Record.prototype.appended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = this.isMutable() ? this : this.branch();
            record.push.apply(record, arguments);
            return record;
        };
        Record.prototype.prepended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = this.isMutable() ? this : this.branch();
            record.splice.apply(record, Array.prototype.concat.apply([0, 0], arguments));
            return record;
        };
        Record.prototype.deleted = function (key) {
            var record = this.isMutable() ? this : this.branch();
            record.delete(key);
            return record;
        };
        Record.prototype.concat = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = this.isMutable() ? this : this.branch();
            for (var i = 0, n = arguments.length; i < n; i += 1) {
                Item.fromAny(arguments[i]).forEach(function (item) {
                    record.push(item);
                });
            }
            return record;
        };
        Record.prototype.slice = function (lower, upper) {
            return this.subRecord.apply(this, arguments).branch();
        };
        Record.prototype.attr = function (key, value) {
            this.push(Item.Attr.of.apply(void 0, arguments));
            return this;
        };
        Record.prototype.slot = function (key, value) {
            this.push(Item.Slot.of.apply(void 0, arguments));
            return this;
        };
        Record.prototype.item = function (item) {
            this.push(item);
            return this;
        };
        Record.prototype.items = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            this.push.apply(this, arguments);
            return this;
        };
        Record.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var scope = Record.create();
            interpreter.pushScope(scope);
            var changed = false;
            this.forEach(function (oldItem) {
                var newItem = oldItem.evaluate(interpreter);
                if (newItem.isDefined()) {
                    scope.push(newItem);
                }
                if (oldItem !== newItem) {
                    changed = true;
                }
            }, this);
            interpreter.popScope();
            return changed ? scope : this;
        };
        Record.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var scope = Record.create();
            interpreter.pushScope(scope);
            var changed = false;
            this.forEach(function (oldItem) {
                var newItem = oldItem.substitute(interpreter);
                if (newItem.isDefined()) {
                    scope.push(newItem);
                }
                if (oldItem !== newItem) {
                    changed = true;
                }
            }, this);
            interpreter.popScope();
            return changed ? scope : this;
        };
        Record.prototype.stringValue = function (orElse) {
            var recordString = "";
            var defined = this.forEach(function (item) {
                if (item instanceof Value) {
                    var itemString = item.stringValue();
                    if (itemString !== void 0) {
                        recordString += itemString;
                        return;
                    }
                }
                return null;
            }, this) === void 0;
            return defined ? recordString : void 0;
        };
        Record.prototype.toAny = function () {
            if (!this.isEmpty() && this.isArray()) {
                return this.toArray();
            }
            else {
                return this.toObject();
            }
        };
        Record.prototype.toArray = function () {
            var array = new Array(this.length);
            this.forEach(function (item, index) {
                if (item instanceof Value) {
                    array[index] = item.toAny();
                }
                else if (item instanceof Item.Field) {
                    array[index] = {
                        $key: item.key.toAny(),
                        $value: item.value.toAny(),
                    };
                }
            }, this);
            return array;
        };
        Record.prototype.toObject = function () {
            var object = {};
            this.forEach(function (item, index) {
                if (item instanceof Item.Attr) {
                    object["@" + item.key.value] = item.value.toAny();
                }
                else if (item instanceof Item.Slot) {
                    if (item.key instanceof Value.Text) {
                        object[item.key.value] = item.value.toAny();
                    }
                    else {
                        object["$" + index] = {
                            $key: item.key.toAny(),
                            $value: item.value.toAny(),
                        };
                    }
                }
                else if (item instanceof Value) {
                    object["$" + index] = item.toAny();
                }
            }, this);
            return object;
        };
        Record.prototype.isAliased = function () {
            return false;
        };
        Record.prototype.isMutable = function () {
            return true;
        };
        Record.prototype.alias = function () {
        };
        Record.prototype.branch = function () {
            var branch = Record.create();
            this.forEach(function (item) {
                branch.push(item);
            }, this);
            return branch;
        };
        Record.prototype.clone = function () {
            var clone = Record.create();
            this.forEach(function (item) {
                clone.push(item.clone());
            }, this);
            return clone;
        };
        Record.prototype.commit = function () {
            return this;
        };
        Record.prototype.bind = function () {
            return this;
        };
        Record.prototype.subRecord = function (lower, upper) {
            var n = this.length;
            if (lower === void 0) {
                lower = 0;
            }
            else if (lower < 0) {
                lower = n + lower;
            }
            lower = Math.min(Math.max(0, lower), n);
            if (upper === void 0) {
                upper = n;
            }
            else if (upper < 0) {
                upper = n + upper;
            }
            var record = Value.Record.create();
            this.forEach(function (item, index) {
                if (index < lower) {
                    return;
                }
                else if (index < upper) {
                    record.push(item);
                    return;
                }
                else {
                    return null;
                }
            }, this);
            return record;
        };
        Record.prototype.iterator = function () {
            return new RecordCursor(this);
        };
        Record.prototype.typeOrder = function () {
            return 3;
        };
        Record.prototype.compareTo = function (that) {
            if (that instanceof Record) {
                var xs = this.iterator();
                var ys = that.iterator();
                var order = 0;
                do {
                    if (!xs.isEmpty() && !ys.isEmpty()) {
                        order = xs.head().compareTo(ys.head());
                        xs.step();
                        ys.step();
                    }
                    else {
                        break;
                    }
                } while (order === 0);
                if (order !== 0) {
                    return order;
                }
                else if (xs.isEmpty() && !ys.isEmpty()) {
                    return -1;
                }
                else if (!xs.isEmpty() && ys.isEmpty()) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Record.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Record) {
                var xs = this.iterator();
                var ys = that.iterator();
                while (!xs.isEmpty() && !ys.isEmpty()) {
                    if (!xs.head().equals(ys.head())) {
                        return false;
                    }
                    xs.step();
                    ys.step();
                }
                return xs.isEmpty() && ys.isEmpty();
            }
            return false;
        };
        Record.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                if (Record._hashSeed === void 0) {
                    Record._hashSeed = Murmur3.seed(Record);
                }
                var code_1 = Record._hashSeed;
                this.forEach(function (item) {
                    code_1 = Murmur3.mix(code_1, item.hashCode());
                }, this);
                this._hashCode = Murmur3.mash(code_1);
            }
            return this._hashCode;
        };
        Record.prototype.debug = function (output) {
            output = output.write("Record").write(46);
            if (this.isEmpty()) {
                output = output.write("empty").write(40).write(41);
            }
            else {
                output = output.write("of").write(40);
                this.forEach(function (item, index) {
                    if (index !== 0) {
                        output = output.write(44).write(32);
                    }
                    output.display(item);
                }, this);
                output = output.write(41);
            }
        };
        Record.prototype.display = function (output) {
            this.debug(output);
        };
        Record.empty = function () {
            return Record.RecordMap.empty();
        };
        Record.create = function (initialCapacity) {
            return Record.RecordMap.create(initialCapacity);
        };
        Record.of = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return Record.RecordMap.of.apply(void 0, arguments);
        };
        Record.fromAny = function (value) {
            if (value instanceof Record) {
                return value;
            }
            else if (Array.isArray(value)) {
                return Record.fromArray(value);
            }
            else if (value && typeof value === "object") {
                return Record.fromObject(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Record.fromArray = function (array) {
            var n = array.length || 0;
            var record = Record.create(n);
            for (var i = 0; i < n; i += 1) {
                record.push(Item.fromAny(array[i]));
            }
            return record;
        };
        Record.fromObject = function (object) {
            var record = Record.create();
            for (var key in object) {
                var value = object[key];
                if (key.charCodeAt(0) === 36) {
                    if (!value || typeof value !== "object" || !value.hasOwnProperty("$key")) {
                        record.push(Value.fromAny(value));
                    }
                    else {
                        record.push(Item.Field.of(value.$key, value.$value));
                    }
                }
                else {
                    record.push(Item.Field.of(key, value));
                }
            }
            return record;
        };
        Record.expand = function (n) {
            n = Math.max(8, n) - 1;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        };
        Record.ALIASED = 1;
        Record.IMMUTABLE = 2;
        return Record;
    }(Value));
    Item.Record = Record;

    var RecordMap = (function (_super) {
        __extends(RecordMap, _super);
        function RecordMap(array, table, itemCount, fieldCount, flags) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._table = table;
            _this._itemCount = itemCount;
            _this._fieldCount = fieldCount;
            _this._flags = flags;
            return _this;
        }
        RecordMap.prototype.isEmpty = function () {
            return this._itemCount === 0;
        };
        Object.defineProperty(RecordMap.prototype, "length", {
            get: function () {
                return this._itemCount;
            },
            enumerable: true,
            configurable: true
        });
        RecordMap.prototype.fieldCount = function () {
            return this._fieldCount;
        };
        RecordMap.prototype.valueCount = function () {
            return this._itemCount - this._fieldCount;
        };
        RecordMap.prototype.isConstant = function () {
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                if (!array[i].isConstant()) {
                    return false;
                }
            }
            return true;
        };
        RecordMap.prototype.tag = function () {
            if (this._fieldCount > 0) {
                var head = this._array[0];
                if (head instanceof Item.Attr) {
                    return head.key.value;
                }
            }
            return void 0;
        };
        RecordMap.prototype.target = function () {
            var value;
            var record;
            var modified = false;
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Attr) {
                    modified = true;
                }
                else if (value === void 0 && item instanceof Value) {
                    value = item;
                }
                else {
                    if (record === void 0) {
                        record = Record.create();
                        if (value !== void 0) {
                            record.push(value);
                        }
                    }
                    record.push(item);
                }
            }
            if (value === void 0) {
                return Value.extant();
            }
            else if (record === void 0) {
                return value;
            }
            else if (modified) {
                return record;
            }
            else {
                return this;
            }
        };
        RecordMap.prototype.head = function () {
            if (this._itemCount > 0) {
                return this._array[0];
            }
            return Item.absent();
        };
        RecordMap.prototype.tail = function () {
            var n = this._itemCount;
            if (n > 0) {
                return new Record.RecordMapView(this, 1, n);
            }
            else {
                return Record.empty();
            }
        };
        RecordMap.prototype.body = function () {
            var n = this._itemCount;
            if (n > 2) {
                return new Record.RecordMapView(this, 1, n).branch();
            }
            else if (n === 2) {
                var item = this._array[1];
                if (item instanceof Value) {
                    return item;
                }
                else {
                    return Record.of(item);
                }
            }
            return Value.absent();
        };
        RecordMap.prototype.has = function (key) {
            if (this._fieldCount !== 0) {
                key = Value.fromAny(key);
                var table = this.hashTable();
                var n = table.length;
                var x = Math.abs(key.hashCode() % n);
                var i = x;
                do {
                    var field = table[i];
                    if (field !== void 0) {
                        if (field.key.equals(key)) {
                            return true;
                        }
                    }
                    else {
                        break;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
            }
            return false;
        };
        RecordMap.prototype.indexOf = function (item, index) {
            if (index === void 0) { index = 0; }
            item = Item.fromAny(item);
            var array = this._array;
            var n = this._itemCount;
            if (index < 0) {
                index = Math.max(0, n + index);
            }
            while (index < n) {
                if (item.equals(array[index])) {
                    return index;
                }
                index += 1;
            }
            return -1;
        };
        RecordMap.prototype.lastIndexOf = function (item, index) {
            item = Item.fromAny(item);
            var array = this._array;
            var n = this._itemCount;
            if (index === void 0) {
                index = n - 1;
            }
            else if (index < 0) {
                index = n + index;
            }
            index = Math.min(index, n - 1);
            while (index >= 0) {
                if (item.equals(array[index])) {
                    return index;
                }
                index -= 1;
            }
            return -1;
        };
        RecordMap.prototype.get = function (key) {
            if (this._fieldCount > 0) {
                key = Value.fromAny(key);
                var table = this.hashTable();
                var n = table.length;
                var x = Math.abs(key.hashCode() % n);
                var i = x;
                do {
                    var field = table[i];
                    if (field !== void 0) {
                        if (field.key.equals(key)) {
                            return field.value;
                        }
                    }
                    else {
                        break;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
            }
            return Value.absent();
        };
        RecordMap.prototype.getAttr = function (key) {
            if (this._fieldCount > 0) {
                key = Value.Text.fromAny(key);
                var table = this.hashTable();
                var n = table.length;
                var x = Math.abs(key.hashCode() % n);
                var i = x;
                do {
                    var field = table[i];
                    if (field !== void 0) {
                        if (field instanceof Item.Attr && field.key.equals(key)) {
                            return field.value;
                        }
                    }
                    else {
                        break;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
            }
            return Value.absent();
        };
        RecordMap.prototype.getSlot = function (key) {
            if (this._fieldCount > 0) {
                key = Value.fromAny(key);
                var table = this.hashTable();
                var n = table.length;
                var x = Math.abs(key.hashCode() % n);
                var i = x;
                do {
                    var field = table[i];
                    if (field !== void 0) {
                        if (field instanceof Item.Slot && field.key.equals(key)) {
                            return field.value;
                        }
                    }
                    else {
                        break;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
            }
            return Value.absent();
        };
        RecordMap.prototype.getField = function (key) {
            if (this._fieldCount > 0) {
                key = Value.fromAny(key);
                var table = this.hashTable();
                var n = table.length;
                var x = Math.abs(key.hashCode() % n);
                var i = x;
                do {
                    var field = table[i];
                    if (field !== void 0) {
                        if (field.key.equals(key)) {
                            return field;
                        }
                    }
                    else {
                        break;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
            }
            return void 0;
        };
        RecordMap.prototype.getItem = function (index) {
            if (index instanceof Item.Num) {
                index = index.value;
            }
            var n = this._itemCount;
            if (index < 0) {
                index = n + index;
            }
            if (index >= 0 && index < n) {
                return this._array[index];
            }
            else {
                return Item.absent();
            }
        };
        RecordMap.prototype.set = function (key, newValue) {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            if ((this._flags & Record.ALIASED) !== 0) {
                if (this._fieldCount > 0) {
                    this.setAliased(key, newValue);
                }
                else {
                    this.pushAliased(new Item.Slot(key, newValue));
                }
            }
            else {
                if (this._fieldCount > 0) {
                    if (this._table !== null) {
                        this.setMutable(key, newValue);
                    }
                    else {
                        this.updateMutable(key, newValue);
                    }
                }
                else {
                    this.pushMutable(new Item.Slot(key, newValue));
                }
            }
            return this;
        };
        RecordMap.prototype.setAliased = function (key, newValue) {
            var n = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(n + 1));
            for (var i = 0; i < n; i += 1) {
                var item = oldArray[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    newArray[i] = item.updatedValue(newValue);
                    i += 1;
                    while (i < n) {
                        newArray[i] = oldArray[i];
                        i += 1;
                    }
                    this._array = newArray;
                    this._table = null;
                    this._flags &= ~Record.ALIASED;
                    return;
                }
                newArray[i] = item;
            }
            newArray[n] = new Item.Slot(key, newValue);
            this._array = newArray;
            this._table = null;
            this._itemCount = n + 1;
            this._fieldCount += 1;
            this._flags &= ~Record.ALIASED;
        };
        RecordMap.prototype.setMutable = function (key, newValue) {
            var table = this._table;
            var n = table.length;
            var x = Math.abs(key.hashCode() % n);
            var i = x;
            do {
                var field_1 = table[i];
                if (field_1 !== void 0) {
                    if (field_1.key.equals(key)) {
                        if (field_1.isMutable()) {
                            field_1.setValue(newValue);
                            return;
                        }
                        else {
                            this.updateMutable(key, newValue);
                            return;
                        }
                    }
                }
                else {
                    break;
                }
                i = (i + 1) % n;
            } while (i !== x);
            var field = new Item.Slot(key, newValue);
            this.pushMutable(field);
            RecordMap.put(table, field);
        };
        RecordMap.prototype.updateMutable = function (key, newValue) {
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    array[i] = item.updatedValue(newValue);
                    this._table = null;
                    return;
                }
            }
            var field = new Item.Slot(key, newValue);
            this.pushMutable(field);
            RecordMap.put(this._table, field);
        };
        RecordMap.prototype.setAttr = function (key, newValue) {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            key = Value.Text.fromAny(key);
            newValue = Value.fromAny(newValue);
            if ((this._flags & Record.ALIASED) !== 0) {
                if (this._fieldCount > 0) {
                    this.setAttrAliased(key, newValue);
                }
                else {
                    this.pushAliased(new Item.Attr(key, newValue));
                }
            }
            else {
                if (this._fieldCount > 0) {
                    if (this._table !== null) {
                        this.setAttrMutable(key, newValue);
                    }
                    else {
                        this.updateAttrMutable(key, newValue);
                    }
                }
                else {
                    this.pushMutable(new Item.Attr(key, newValue));
                }
            }
            return this;
        };
        RecordMap.prototype.setAttrAliased = function (key, newValue) {
            var n = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(n + 1));
            for (var i = 0; i < n; i += 1) {
                var item = oldArray[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    newArray[i] = new Item.Attr(key, newValue);
                    i += 1;
                    while (i < n) {
                        newArray[i] = oldArray[i];
                        i += 1;
                    }
                    this._array = newArray;
                    this._table = null;
                    this._flags &= ~Record.ALIASED;
                    return;
                }
                newArray[i] = item;
            }
            newArray[n] = new Item.Attr(key, newValue);
            this._array = newArray;
            this._table = null;
            this._itemCount = n + 1;
            this._fieldCount += 1;
            this._flags &= ~Record.ALIASED;
        };
        RecordMap.prototype.setAttrMutable = function (key, newValue) {
            var table = this._table;
            var n = table.length;
            var x = Math.abs(key.hashCode() % n);
            var i = x;
            do {
                var field_2 = table[i];
                if (field_2 !== void 0) {
                    if (field_2.key.equals(key)) {
                        if (field_2 instanceof Item.Attr && field_2.isMutable()) {
                            field_2.setValue(newValue);
                        }
                        else {
                            this.updateAttrMutable(key, newValue);
                        }
                        return;
                    }
                }
                else {
                    break;
                }
                i = (i + 1) % n;
            } while (i !== x);
            var field = new Item.Attr(key, newValue);
            this.push(field);
            RecordMap.put(table, field);
        };
        RecordMap.prototype.updateAttrMutable = function (key, newValue) {
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    array[i] = new Item.Attr(key, newValue);
                    this._table = null;
                    return;
                }
            }
            var field = new Item.Attr(key, newValue);
            this.push(field);
            RecordMap.put(this._table, field);
        };
        RecordMap.prototype.setSlot = function (key, newValue) {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            if ((this._flags & Record.ALIASED) !== 0) {
                if (this._fieldCount > 0) {
                    this.setSlotAliased(key, newValue);
                }
                else {
                    this.pushAliased(new Item.Slot(key, newValue));
                }
            }
            else {
                if (this._fieldCount > 0) {
                    if (this._table !== null) {
                        this.setSlotMutable(key, newValue);
                    }
                    else {
                        this.updateSlotMutable(key, newValue);
                    }
                }
                else {
                    this.pushMutable(new Item.Slot(key, newValue));
                }
            }
            return this;
        };
        RecordMap.prototype.setSlotAliased = function (key, newValue) {
            var n = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(n + 1));
            for (var i = 0; i < n; i += 1) {
                var item = oldArray[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    newArray[i] = new Item.Slot(key, newValue);
                    i += 1;
                    while (i < n) {
                        newArray[i] = oldArray[i];
                        i += 1;
                    }
                    this._array = newArray;
                    this._table = null;
                    this._flags &= ~Record.ALIASED;
                    return;
                }
                newArray[i] = item;
            }
            newArray[n] = new Item.Slot(key, newValue);
            this._array = newArray;
            this._table = null;
            this._itemCount = n + 1;
            this._fieldCount += 1;
            this._flags &= ~Record.ALIASED;
        };
        RecordMap.prototype.setSlotMutable = function (key, newValue) {
            var table = this._table;
            var n = table.length;
            var x = Math.abs(key.hashCode() % n);
            var i = x;
            do {
                var field_3 = table[i];
                if (field_3 !== void 0) {
                    if (field_3.key.equals(key)) {
                        if (field_3 instanceof Item.Slot && field_3.isMutable()) {
                            field_3.setValue(newValue);
                        }
                        else {
                            this.updateSlotMutable(key, newValue);
                        }
                        return;
                    }
                }
                else {
                    break;
                }
                i = (i + 1) % n;
            } while (i !== x);
            var field = new Item.Slot(key, newValue);
            this.push(field);
            RecordMap.put(table, field);
        };
        RecordMap.prototype.updateSlotMutable = function (key, newValue) {
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    array[i] = new Item.Slot(key, newValue);
                    this._table = null;
                    return;
                }
            }
            var field = new Item.Slot(key, newValue);
            this.push(field);
            RecordMap.put(this._table, field);
        };
        RecordMap.prototype.setItem = function (index, newItem) {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            newItem = Item.fromAny(newItem);
            var n = this._itemCount;
            if (index < 0) {
                index = n + index;
            }
            if (index < 0 || index > n) {
                throw new RangeError("" + index);
            }
            if ((this._flags & Record.ALIASED) !== 0) {
                this.setItemAliased(index, newItem);
            }
            else {
                this.setItemMutable(index, newItem);
            }
            return this;
        };
        RecordMap.prototype.setItemAliased = function (index, newItem) {
            var n = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(n));
            for (var i = 0; i < n; i += 1) {
                newArray[i] = oldArray[i];
            }
            var oldItem = oldArray[index];
            newArray[index] = newItem;
            this._array = newArray;
            this._table = null;
            if (newItem instanceof Item.Field) {
                if (!(oldItem instanceof Item.Field)) {
                    this._fieldCount += 1;
                }
            }
            else if (oldItem instanceof Item.Field) {
                this._fieldCount -= 1;
            }
            this._flags &= ~Record.ALIASED;
        };
        RecordMap.prototype.setItemMutable = function (index, newItem) {
            var array = this._array;
            var oldItem = array[index];
            array[index] = newItem;
            if (newItem instanceof Item.Field) {
                this._table = null;
                if (!(oldItem instanceof Item.Field)) {
                    this._fieldCount += 1;
                }
            }
            else if (oldItem instanceof Item.Field) {
                this._table = null;
                this._fieldCount -= 1;
            }
        };
        RecordMap.prototype.updated = function (key, newValue) {
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            var record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();
            if ((record._flags & Record.ALIASED) !== 0) {
                if (record._fieldCount > 0) {
                    record.setAliased(key, newValue);
                }
                else {
                    record.pushAliased(new Item.Slot(key, newValue));
                }
            }
            else {
                if (record._fieldCount > 0) {
                    if (record._table !== null) {
                        record.setMutable(key, newValue);
                    }
                    else {
                        record.updateMutable(key, newValue);
                    }
                }
                else {
                    record.pushMutable(new Item.Slot(key, newValue));
                }
            }
            return record;
        };
        RecordMap.prototype.updatedAttr = function (key, newValue) {
            key = Value.Text.fromAny(key);
            newValue = Value.fromAny(newValue);
            var record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();
            if ((record._flags & Record.ALIASED) !== 0) {
                if (record._fieldCount > 0) {
                    record.setAttrAliased(key, newValue);
                }
                else {
                    record.pushAliased(new Item.Attr(key, newValue));
                }
            }
            else {
                if (record._fieldCount > 0) {
                    if (record._table !== null) {
                        record.setAttrMutable(key, newValue);
                    }
                    else {
                        record.updateAttrMutable(key, newValue);
                    }
                }
                else {
                    record.pushMutable(new Item.Attr(key, newValue));
                }
            }
            return record;
        };
        RecordMap.prototype.updatedSlot = function (key, newValue) {
            key = Value.fromAny(key);
            newValue = Value.fromAny(newValue);
            var record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();
            if ((record._flags & Record.ALIASED) !== 0) {
                if (record._fieldCount > 0) {
                    record.setSlotAliased(key, newValue);
                }
                else {
                    record.pushAliased(new Item.Slot(key, newValue));
                }
            }
            else {
                if (record._fieldCount > 0) {
                    if (record._table !== null) {
                        record.setSlotMutable(key, newValue);
                    }
                    else {
                        record.updateSlotMutable(key, newValue);
                    }
                }
                else {
                    record.pushMutable(new Item.Slot(key, newValue));
                }
            }
            return record;
        };
        RecordMap.prototype.push = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            if ((this._flags & Record.ALIASED) !== 0) {
                this.pushAliased.apply(this, arguments);
            }
            else {
                this.pushMutable.apply(this, arguments);
            }
            return this._itemCount;
        };
        RecordMap.prototype.pushAliased = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            var k = arguments.length;
            var m = this._itemCount;
            var n = this._fieldCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(m + k));
            if (oldArray !== null) {
                for (var i = 0; i < m; i += 1) {
                    newArray[i] = oldArray[i];
                }
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(arguments[i]);
                newArray[m] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                }
            }
            this._array = newArray;
            this._table = null;
            this._itemCount = m;
            this._fieldCount = n;
            this._flags &= ~Record.ALIASED;
        };
        RecordMap.prototype.pushMutable = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            var k = arguments.length;
            var m = this._itemCount;
            var n = this._fieldCount;
            var oldArray = this._array;
            var newArray;
            if (oldArray === null || m + k > oldArray.length) {
                newArray = new Array(Record.expand(m + k));
                if (oldArray !== null) {
                    for (var i = 0; i < m; i += 1) {
                        newArray[i] = oldArray[i];
                    }
                }
            }
            else {
                newArray = oldArray;
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(arguments[i]);
                newArray[m] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                    this._table = null;
                }
            }
            this._array = newArray;
            this._itemCount = m;
            this._fieldCount = n;
        };
        RecordMap.prototype.splice = function (start, deleteCount) {
            if (deleteCount === void 0) { deleteCount = 0; }
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            var n = this._itemCount;
            if (start < 0) {
                start = n + start;
            }
            start = Math.min(Math.max(0, start), n);
            deleteCount = Math.min(Math.max(0, deleteCount), n - start);
            if ((this._flags & Record.ALIASED) !== 0) {
                return this.spliceAliased.apply(this, arguments);
            }
            else {
                return this.spliceMutable.apply(this, arguments);
            }
        };
        RecordMap.prototype.spliceAliased = function (start, deleteCount) {
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            var k = newItems.length;
            var m = this._itemCount;
            var n = this._fieldCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(m - deleteCount + k));
            for (var i = 0; i < start; i += 1) {
                newArray[i] = oldArray[i];
            }
            var oldItems = [];
            for (var i = start; i < start + deleteCount; i += 1) {
                var oldItem = oldArray[i];
                oldItems.push(oldItem);
                m -= 1;
                if (oldItem instanceof Item.Field) {
                    n -= 1;
                }
            }
            for (var i = start; i < m; i += 1) {
                newArray[i + k] = oldArray[i + deleteCount];
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(newItems[i]);
                newArray[i + start] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                }
            }
            this._array = newArray;
            this._table = null;
            this._itemCount = m;
            this._fieldCount = n;
            this._flags &= ~Record.ALIASED;
            return oldItems;
        };
        RecordMap.prototype.spliceMutable = function (start, deleteCount) {
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            var k = newItems.length;
            var m = this._itemCount;
            var n = this._fieldCount;
            var oldArray = this._array;
            var newArray;
            if (oldArray === null || m - deleteCount + k > oldArray.length) {
                newArray = new Array(Record.expand(m - deleteCount + k));
                if (oldArray !== null) {
                    for (var i = 0; i < start; i += 1) {
                        newArray[i] = oldArray[i];
                    }
                }
            }
            else {
                newArray = oldArray;
            }
            var oldItems = [];
            for (var i = start; i < start + deleteCount; i += 1) {
                var oldItem = oldArray[i];
                oldItems.push(oldItem);
                m -= 1;
                if (oldItem instanceof Item.Field) {
                    n -= 1;
                }
            }
            if (k > deleteCount) {
                for (var i = m - 1; i >= start; i -= 1) {
                    newArray[i + k] = oldArray[i + deleteCount];
                }
            }
            else {
                for (var i = start; i < m; i += 1) {
                    newArray[i + k] = oldArray[i + deleteCount];
                }
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(newItems[i]);
                newArray[i + start] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                }
            }
            this._array = newArray;
            this._itemCount = m;
            this._fieldCount = n;
            return oldItems;
        };
        RecordMap.prototype.delete = function (key) {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            key = Value.fromAny(key);
            if ((this._flags & Record.ALIASED) !== 0) {
                return this.deleteAliased(key);
            }
            else {
                return this.deleteMutable(key);
            }
        };
        RecordMap.prototype.deleteAliased = function (key) {
            var n = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(Record.expand(n));
            for (var i = 0; i < n; i += 1) {
                var item = oldArray[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    for (var j = i + 1; j < n; j += 1, i += 1) {
                        newArray[i] = oldArray[j];
                    }
                    this._array = newArray;
                    this._table = null;
                    this._itemCount = n - 1;
                    this._fieldCount -= 1;
                    this._flags &= ~Record.ALIASED;
                    return item;
                }
                newArray[i] = item;
            }
            return Item.absent();
        };
        RecordMap.prototype.deleteMutable = function (key) {
            var n = this._itemCount;
            var array = this._array;
            for (var i = 0; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    for (var j = i + 1; j < n; j += 1, i += 1) {
                        array[i] = array[j];
                    }
                    array[n - 1] = void 0;
                    this._table = null;
                    this._itemCount = n - 1;
                    this._fieldCount -= 1;
                    return item;
                }
            }
            return Item.absent();
        };
        RecordMap.prototype.clear = function () {
            if ((this._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            this._array = null;
            this._table = null;
            this._itemCount = 0;
            this._fieldCount = 0;
            this._flags = 0;
        };
        RecordMap.prototype.isAliased = function () {
            return (this._flags & Record.ALIASED) !== 0;
        };
        RecordMap.prototype.isMutable = function () {
            return (this._flags & Record.IMMUTABLE) === 0;
        };
        RecordMap.prototype.alias = function () {
            this._flags |= Record.ALIASED;
        };
        RecordMap.prototype.branch = function () {
            if ((this._flags & (Record.ALIASED | Record.IMMUTABLE)) === 0) {
                var array = this._array;
                for (var i = 0, n = this._itemCount; i < n; i += 1) {
                    array[i].alias();
                }
            }
            this._flags |= Record.ALIASED;
            return new RecordMap(this._array, this._table, this._itemCount, this._fieldCount, Record.ALIASED);
        };
        RecordMap.prototype.clone = function () {
            var itemCount = this._itemCount;
            var oldArray = this._array;
            var newArray = new Array(itemCount);
            for (var i = 0; i < itemCount; i += 1) {
                newArray[i] = oldArray[i].clone();
            }
            return new RecordMap(newArray, null, itemCount, this._fieldCount, 0);
        };
        RecordMap.prototype.commit = function () {
            if ((this._flags & Record.IMMUTABLE) === 0) {
                this._flags |= Record.IMMUTABLE;
                var array = this._array;
                for (var i = 0, n = this._itemCount; i < n; i += 1) {
                    array[i].commit();
                }
            }
            return this;
        };
        RecordMap.prototype.hashTable = function () {
            var n = this._fieldCount;
            var table = this._table;
            if (n !== 0 && this._table === null) {
                table = new Array(Record.expand(Math.max(n, n * 10 / 7)));
                var array = this._array;
                for (var i = 0, m = this._itemCount; i < m; i += 1) {
                    var item = array[i];
                    if (item instanceof Item.Field) {
                        RecordMap.put(table, item);
                    }
                }
                this._table = table;
            }
            return table;
        };
        RecordMap.put = function (table, field) {
            if (table !== null) {
                var n = table.length;
                var x = Math.abs(field.key.hashCode() % n);
                var i = x;
                do {
                    var item = table[i];
                    if (item !== void 0) {
                        if (field.key.equals(item.key)) {
                            table[i] = field;
                            return;
                        }
                    }
                    else {
                        table[i] = field;
                        return;
                    }
                    i = (i + 1) % n;
                } while (i !== x);
                throw new Error();
            }
        };
        RecordMap.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var array = this._array;
            var n = this._itemCount;
            var scope = Record.create(n);
            interpreter.pushScope(scope);
            var changed = false;
            for (var i = 0; i < n; i += 1) {
                var oldItem = array[i];
                var newItem = oldItem.evaluate(interpreter);
                if (newItem.isDefined()) {
                    scope.push(newItem);
                }
                if (oldItem !== newItem) {
                    changed = true;
                }
            }
            interpreter.popScope();
            return changed ? scope : this;
        };
        RecordMap.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var array = this._array;
            var n = this._itemCount;
            var scope = Record.create(n);
            interpreter.pushScope(scope);
            var changed = false;
            for (var i = 0; i < n; i += 1) {
                var oldItem = array[i];
                var newItem = oldItem.substitute(interpreter);
                if (newItem.isDefined()) {
                    scope.push(newItem);
                }
                if (oldItem !== newItem) {
                    changed = true;
                }
            }
            interpreter.popScope();
            return changed ? scope : this;
        };
        RecordMap.prototype.subRecord = function (lower, upper) {
            var n = this._itemCount;
            if (lower === void 0) {
                lower = 0;
            }
            else if (lower < 0) {
                lower = n + lower;
            }
            if (upper === void 0) {
                upper = n;
            }
            else if (upper < 0) {
                upper = n + upper;
            }
            if (lower < 0 || upper > n || lower > upper) {
                throw new RangeError(lower + ", " + upper);
            }
            return new Record.RecordMapView(this, lower, upper);
        };
        RecordMap.prototype.forEach = function (callback, thisArg) {
            var array = this._array;
            for (var i = 0, n = this._itemCount; i < n; i += 1) {
                var result = callback.call(thisArg, array[i], i);
                if (result !== void 0) {
                    return result;
                }
            }
            return;
        };
        RecordMap.empty = function () {
            if (!RecordMap._empty) {
                RecordMap._empty = new RecordMap(null, null, 0, 0, Record.ALIASED | Record.IMMUTABLE);
            }
            return RecordMap._empty;
        };
        RecordMap.create = function (initialCapacity) {
            if (initialCapacity === void 0) {
                return new RecordMap(null, null, 0, 0, Record.ALIASED);
            }
            else {
                return new RecordMap(new Array(initialCapacity), null, 0, 0, 0);
            }
        };
        RecordMap.of = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var n = arguments.length;
            if (n === 0) {
                return new RecordMap(null, null, 0, 0, Record.ALIASED);
            }
            else {
                var array = new Array(n);
                var itemCount = 0;
                var fieldCount = 0;
                for (var i = 0; i < n; i += 1) {
                    var item = Item.fromAny(arguments[i]);
                    array[i] = item;
                    itemCount += 1;
                    if (item instanceof Item.Field) {
                        fieldCount += 1;
                    }
                }
                return new RecordMap(array, null, itemCount, fieldCount, 0);
            }
        };
        return RecordMap;
    }(Record));
    Item.RecordMap = RecordMap;

    var RecordMapView = (function (_super) {
        __extends(RecordMapView, _super);
        function RecordMapView(record, lower, upper) {
            var _this = _super.call(this) || this;
            _this._record = record;
            _this._lower = lower;
            _this._upper = upper;
            return _this;
        }
        RecordMapView.prototype.isEmpty = function () {
            return this._lower === this._upper;
        };
        RecordMapView.prototype.isArray = function () {
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                if (array[i] instanceof Item.Field) {
                    return false;
                }
            }
            return true;
        };
        RecordMapView.prototype.isObject = function () {
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                if (array[i] instanceof Value) {
                    return false;
                }
            }
            return true;
        };
        Object.defineProperty(RecordMapView.prototype, "length", {
            get: function () {
                return this._upper - this._lower;
            },
            enumerable: true,
            configurable: true
        });
        RecordMapView.prototype.fieldCount = function () {
            var array = this._record._array;
            var k = 0;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                if (array[i] instanceof Item.Field) {
                    k += 1;
                }
            }
            return k;
        };
        RecordMapView.prototype.valueCount = function () {
            var k = 0;
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                if (array[i] instanceof Value) {
                    k += 1;
                }
            }
            return k;
        };
        RecordMapView.prototype.isConstant = function () {
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                if (!array[i].isConstant()) {
                    return false;
                }
            }
            return true;
        };
        RecordMapView.prototype.tag = function () {
            if (this.length > 0) {
                var item = this._record._array[this._lower];
                if (item instanceof Item.Attr) {
                    return item.key.value;
                }
            }
            return void 0;
        };
        RecordMapView.prototype.target = function () {
            var value;
            var record;
            var modified = false;
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                var item = array[i];
                if (item instanceof Item.Attr) {
                    modified = true;
                }
                else if (value === void 0 && item instanceof Value) {
                    value = item;
                }
                else {
                    if (record === void 0) {
                        record = Record.create();
                        if (value !== void 0) {
                            record.push(value);
                        }
                    }
                    record.push(item);
                }
            }
            if (value === void 0) {
                return Value.extant();
            }
            else if (record === void 0) {
                return value;
            }
            else if (modified) {
                return record;
            }
            else {
                return this;
            }
        };
        RecordMapView.prototype.head = function () {
            if (this.length > 0) {
                return this._record._array[this._lower];
            }
            else {
                return Item.absent();
            }
        };
        RecordMapView.prototype.tail = function () {
            if (this.length > 0) {
                return new RecordMapView(this._record, this._lower + 1, this._upper);
            }
            else {
                return Record.empty();
            }
        };
        RecordMapView.prototype.body = function () {
            var n = this.length;
            if (n > 2) {
                return new RecordMapView(this._record, this._lower + 1, this._upper).branch();
            }
            else if (n === 2) {
                var item = this._record._array[this._lower + 1];
                if (item instanceof Value) {
                    return item;
                }
                else {
                    return Record.of(item);
                }
            }
            else {
                return Value.absent();
            }
        };
        RecordMapView.prototype.indexOf = function (item, index) {
            if (index === void 0) { index = 0; }
            item = Item.fromAny(item);
            var array = this._record._array;
            var n = this.length;
            if (index < 0) {
                index = Math.max(0, n + index);
            }
            index = this._lower + index;
            while (index < this._upper) {
                if (item.equals(array[index])) {
                    return index - this._lower;
                }
                index += 1;
            }
            return -1;
        };
        RecordMapView.prototype.lastIndexOf = function (item, index) {
            item = Item.fromAny(item);
            var array = this._record._array;
            var n = this.length;
            if (index === void 0) {
                index = n - 1;
            }
            else if (index < 0) {
                index = n + index;
            }
            index = this._lower + Math.min(index, n - 1);
            while (index >= this._lower) {
                if (item.equals(array[index])) {
                    return index - this._lower;
                }
                index -= 1;
            }
            return -1;
        };
        RecordMapView.prototype.getItem = function (index) {
            if (index instanceof Item.Num) {
                index = index.value;
            }
            var n = this.length;
            if (index < 0) {
                index = n + index;
            }
            if (index >= 0 && index < n) {
                return this._record._array[this._lower + index];
            }
            else {
                return Item.absent();
            }
        };
        RecordMapView.prototype.setItem = function (index, newItem) {
            if ((this._record._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            newItem = Item.fromAny(newItem);
            var n = this.length;
            if (index < 0) {
                index = n + index;
            }
            if (index < 0 || index > n) {
                throw new RangeError("" + index);
            }
            if ((this._record._flags & Record.ALIASED) !== 0) {
                this.setItemAliased(index, newItem);
            }
            else {
                this.setItemMutable(index, newItem);
            }
            return this;
        };
        RecordMapView.prototype.setItemAliased = function (index, newItem) {
            var n = this._record._itemCount;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(n));
            for (var i = 0; i < n; i += 1) {
                newArray[i] = oldArray[i];
            }
            var oldItem = oldArray[this._lower + index];
            newArray[this._lower + index] = newItem;
            this._record._array = newArray;
            this._record._table = null;
            if (newItem instanceof Item.Field) {
                if (!(oldItem instanceof Item.Field)) {
                    this._record._fieldCount += 1;
                }
            }
            else if (oldItem instanceof Item.Field) {
                this._record._fieldCount -= 1;
            }
            this._record._flags &= ~Record.ALIASED;
        };
        RecordMapView.prototype.setItemMutable = function (index, newItem) {
            var array = this._record._array;
            var oldItem = array[this._lower + index];
            array[this._lower + index] = newItem;
            if (newItem instanceof Item.Field) {
                this._record._table = null;
                if (!(oldItem instanceof Item.Field)) {
                    this._record._fieldCount += 1;
                }
            }
            else if (oldItem instanceof Item.Field) {
                this._record._table = null;
                this._record._fieldCount -= 1;
            }
        };
        RecordMapView.prototype.push = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            if ((this._record._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            if ((this._record._flags & Record.ALIASED) !== 0) {
                this.pushAliased.apply(this, arguments);
            }
            else {
                this.pushMutable.apply(this, arguments);
            }
            return this.length;
        };
        RecordMapView.prototype.pushAliased = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            var k = newItems.length;
            var m = this._record._itemCount;
            var n = this._record._fieldCount;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(m + k));
            if (oldArray !== null) {
                for (var i = 0; i < this._upper; i += 1) {
                    newArray[i] = oldArray[i];
                }
                for (var i = this._upper; i < m; i += 1) {
                    newArray[i + k] = oldArray[i];
                }
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(newItems[i]);
                newArray[i + this._upper] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                }
            }
            this._record._array = newArray;
            this._record._table = null;
            this._record._itemCount = m;
            this._record._fieldCount = n;
            this._record._flags &= ~Record.ALIASED;
            this._upper += k;
        };
        RecordMapView.prototype.pushMutable = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            var k = newItems.length;
            var m = this._record._itemCount;
            var n = this._record._fieldCount;
            var oldArray = this._record._array;
            var newArray;
            if (oldArray === null || m + k > oldArray.length) {
                newArray = new Array(Record.expand(m + k));
                if (oldArray !== null) {
                    for (var i = 0; i < this._upper; i += 1) {
                        newArray[i] = oldArray[i];
                    }
                }
            }
            else {
                newArray = oldArray;
            }
            for (var i = m - 1; i >= this._upper; i -= 1) {
                newArray[i + k] = oldArray[i];
            }
            for (var i = 0; i < k; i += 1) {
                var newItem = Item.fromAny(newItems[i]);
                newArray[i + this._upper] = newItem;
                m += 1;
                if (newItem instanceof Item.Field) {
                    n += 1;
                    this._record._table = null;
                }
            }
            this._record._array = newArray;
            this._record._itemCount = m;
            this._record._fieldCount = n;
            this._upper += k;
        };
        RecordMapView.prototype.splice = function (start, deleteCount) {
            var _a, _b;
            if (deleteCount === void 0) { deleteCount = 0; }
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            if ((this._record._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            var n = this.length;
            if (start < 0) {
                start = n + start;
            }
            start = Math.min(Math.max(0, start), n);
            deleteCount = Math.min(Math.max(0, deleteCount), n - start);
            var deleted;
            if ((this._record._flags & Record.ALIASED) !== 0) {
                deleted = (_a = this._record).spliceAliased.apply(_a, [this._lower + start, deleteCount].concat(newItems));
            }
            else {
                deleted = (_b = this._record).spliceMutable.apply(_b, [this._lower + start, deleteCount].concat(newItems));
            }
            this._upper += newItems.length - deleted.length;
            return deleted;
        };
        RecordMapView.prototype.delete = function (key) {
            if ((this._record._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            key = Value.fromAny(key);
            if ((this._record._flags & Record.ALIASED) !== 0) {
                return this.deleteAliased(key);
            }
            else {
                return this.deleteMutable(key);
            }
        };
        RecordMapView.prototype.deleteAliased = function (key) {
            var n = this._record._itemCount;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(n));
            for (var i = this._lower; i < this._upper; i += 1) {
                var item = oldArray[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    for (var j = i + 1; j < n; j += 1, i += 1) {
                        newArray[i] = oldArray[j];
                    }
                    this._record._array = newArray;
                    this._record._table = null;
                    this._record._itemCount = n - 1;
                    this._record._fieldCount -= 1;
                    this._record._flags &= ~Record.ALIASED;
                    this._upper -= 1;
                    return item;
                }
                newArray[i] = item;
            }
            return Item.absent();
        };
        RecordMapView.prototype.deleteMutable = function (key) {
            var n = this._record._itemCount;
            var array = this._record._array;
            for (var i = this._lower; i < this._upper; i += 1) {
                var item = array[i];
                if (item instanceof Item.Field && item.key.equals(key)) {
                    for (var j = i + 1; j < n; j += 1, i += 1) {
                        array[i] = array[j];
                    }
                    array[n - 1] = void 0;
                    this._record._table = null;
                    this._record._itemCount -= 1;
                    this._record._fieldCount -= 1;
                    this._upper -= 1;
                    return item;
                }
            }
            return Item.absent();
        };
        RecordMapView.prototype.clear = function () {
            if ((this._record._flags & Record.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            if ((this._record._flags & Record.ALIASED) !== 0) {
                this.clearAliased();
            }
            else {
                this.clearMutable();
            }
        };
        RecordMapView.prototype.clearAliased = function () {
            var m = this._record._itemCount;
            var n = this._record._fieldCount;
            var l = m - this.length;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(l));
            var i = 0;
            while (i < this._lower) {
                newArray[i] = oldArray[i];
                i += 1;
            }
            while (i < this._upper) {
                if (oldArray[i] instanceof Item.Field) {
                    n -= 1;
                }
                i += 1;
            }
            i = this._lower;
            var j = this._upper;
            while (j < m) {
                newArray[i] = oldArray[j];
                i += 1;
                j += 1;
            }
            this._record._array = newArray;
            this._record._table = null;
            this._record._itemCount = l;
            this._record._fieldCount = n;
            this._record._flags &= ~Record.ALIASED;
            this._upper = this._lower;
        };
        RecordMapView.prototype.clearMutable = function () {
            var m = this._record._itemCount;
            var n = this._record._fieldCount;
            var array = this._record._array;
            var i = this._lower;
            while (i < this._upper) {
                if (array[i] instanceof Item.Field) {
                    n -= 1;
                }
                i += 1;
            }
            i = this._lower;
            var j = this._upper;
            while (j < m) {
                var item = array[j];
                if (item instanceof Item.Field) {
                    this._record._table = null;
                }
                array[i] = item;
                i += 1;
                j += 1;
            }
            this._record._itemCount = i;
            this._record._fieldCount = n;
            while (i < m) {
                array[i] = void 0;
                i += 1;
            }
            this._upper = this._lower;
        };
        RecordMapView.prototype.isAliased = function () {
            return (this._record._flags & Record.ALIASED) !== 0;
        };
        RecordMapView.prototype.isMutable = function () {
            return (this._record._flags & Record.IMMUTABLE) === 0;
        };
        RecordMapView.prototype.alias = function () {
            this._record._flags |= Record.ALIASED;
        };
        RecordMapView.prototype.branch = function () {
            var m = this.length;
            var n = 0;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(m));
            var i = this._lower;
            var j = 0;
            while (j < m) {
                var item = oldArray[i];
                newArray[j] = item;
                if (item instanceof Item.Field) {
                    n += 1;
                }
                i += 1;
                j += 1;
            }
            return new RecordMap(newArray, null, m, n, 0);
        };
        RecordMapView.prototype.clone = function () {
            var m = this.length;
            var n = 0;
            var oldArray = this._record._array;
            var newArray = new Array(Record.expand(m));
            var i = this._lower;
            var j = 0;
            while (j < m) {
                var item = oldArray[i];
                newArray[j] = item.clone();
                if (item instanceof Item.Field) {
                    n += 1;
                }
                i += 1;
                j += 1;
            }
            return new RecordMap(newArray, null, m, n, 0);
        };
        RecordMapView.prototype.commit = function () {
            this._record.commit();
            return this;
        };
        RecordMapView.prototype.subRecord = function (lower, upper) {
            var n = this.length;
            if (lower === void 0) {
                lower = 0;
            }
            else if (lower < 0) {
                lower = n + lower;
            }
            if (upper === void 0) {
                upper = n;
            }
            else if (upper < 0) {
                upper = n + upper;
            }
            if (lower < 0 || upper > n || lower > upper) {
                throw new RangeError(lower + ", " + upper);
            }
            return new RecordMapView(this._record, this._lower + lower, this._upper + upper);
        };
        RecordMapView.prototype.forEach = function (callback, thisArg) {
            var array = this._record._array;
            for (var i = this._lower, n = this._upper; i < n; i += 1) {
                var result = callback.call(thisArg, array[i], i);
                if (result !== void 0) {
                    return result;
                }
            }
            return;
        };
        return RecordMapView;
    }(Record));
    Item.RecordMapView = RecordMapView;

    var DataOutput = (function (_super) {
        __extends(DataOutput, _super);
        function DataOutput(data, settings) {
            var _this = _super.call(this) || this;
            _this._data = data;
            _this._settings = settings;
            return _this;
        }
        DataOutput.prototype.isCont = function () {
            return true;
        };
        DataOutput.prototype.isFull = function () {
            return false;
        };
        DataOutput.prototype.isDone = function () {
            return false;
        };
        DataOutput.prototype.isError = function () {
            return false;
        };
        DataOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        DataOutput.prototype.write = function (b) {
            if (typeof b === "number") {
                this._data.addByte(b);
                return this;
            }
            else {
                throw new TypeError("" + b);
            }
        };
        DataOutput.prototype.writeln = function (string) {
            throw new TypeError("" + string);
        };
        DataOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = OutputSettings.fromAny(settings);
                return this;
            }
        };
        DataOutput.prototype.bind = function () {
            return this._data;
        };
        DataOutput.prototype.clone = function () {
            return new DataOutput(this._data.branch(), this._settings);
        };
        return DataOutput;
    }(Output));

    var Data = (function (_super) {
        __extends(Data, _super);
        function Data(array, size, flags) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._size = size;
            _this._flags = flags;
            return _this;
        }
        Data.prototype.isConstant = function () {
            return true;
        };
        Object.defineProperty(Data.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        Data.prototype.getByte = function (index) {
            if (index < 0 || index >= this.size) {
                throw new RangeError("" + index);
            }
            return this._array[index];
        };
        Data.prototype.setByte = function (index, value) {
            var flags = this._flags;
            if ((flags & Data.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            else if (index < 0 || index >= this._size) {
                throw new RangeError("" + index);
            }
            if ((flags & Data.ALIASED) !== 0) {
                return this.setByteAliased(index, value);
            }
            else {
                return this.setByteMutable(index, value);
            }
        };
        Data.prototype.setByteAliased = function (index, value) {
            var n = this.size;
            var oldArray = this._array;
            var newArray = new Uint8Array(Data.expand(n));
            newArray.set(oldArray, 0);
            newArray[index] = value;
            this._array = newArray;
            this._flags &= ~Data.ALIASED;
            return this;
        };
        Data.prototype.setByteMutable = function (index, value) {
            this._array[index] = value;
            return this;
        };
        Data.prototype.addByte = function (value) {
            var flags = this._flags;
            if ((flags & Data.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            if ((flags & Data.ALIASED) !== 0) {
                return this.addByteAliased(value);
            }
            else {
                return this.addByteMutable(value);
            }
        };
        Data.prototype.addByteAliased = function (value) {
            var n = this.size;
            var oldArray = this._array;
            var newArray = new Uint8Array(Data.expand(n + 1));
            if (oldArray != null) {
                newArray.set(oldArray, 0);
            }
            newArray[n] = value;
            this._array = newArray;
            this._size = n + 1;
            this._flags &= ~Data.ALIASED;
            return this;
        };
        Data.prototype.addByteMutable = function (value) {
            var n = this.size;
            var oldArray = this._array;
            var newArray;
            if (oldArray === null || n + 1 > oldArray.length) {
                newArray = new Uint8Array(Data.expand(n + 1));
                if (oldArray !== null) {
                    newArray.set(oldArray, 0);
                }
                this._array = newArray;
            }
            else {
                newArray = oldArray;
            }
            newArray[n] = value;
            this._size = n + 1;
            return this;
        };
        Data.prototype.addData = function (data) {
            var array = data._array;
            if (array !== null) {
                var size = data._size;
                if (array.length > size) {
                    array = array.slice(0, size);
                }
                return this.addUint8Array(array);
            }
            else {
                return this;
            }
        };
        Data.prototype.addUint8Array = function (array) {
            var flags = this._flags;
            if ((flags & Data.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            if ((flags & Data.ALIASED) !== 0) {
                return this.addUint8ArrayAliased(array);
            }
            else {
                return this.addUint8ArrayMutable(array);
            }
        };
        Data.prototype.addUint8ArrayAliased = function (array) {
            var size = array.length;
            if (size === 0) {
                return this;
            }
            var n = this.size;
            var oldArray = this._array;
            var newArray = new Uint8Array(Data.expand(n + size));
            if (oldArray !== null) {
                newArray.set(oldArray, 0);
            }
            newArray.set(array, n);
            this._array = newArray;
            this._size = n + size;
            this._flags &= ~Data.ALIASED;
            return this;
        };
        Data.prototype.addUint8ArrayMutable = function (array) {
            var size = array.length;
            if (size === 0) {
                return this;
            }
            var n = this.size;
            var oldArray = this._array;
            var newArray;
            if (oldArray === null || n + size > oldArray.length) {
                newArray = new Uint8Array(Data.expand(n + size));
                if (oldArray !== null) {
                    newArray.set(oldArray, 0);
                }
                this._array = newArray;
            }
            else {
                newArray = oldArray;
            }
            newArray.set(array, n);
            this._size = n + size;
            return this;
        };
        Data.prototype.clear = function () {
            if ((this._flags & Data.IMMUTABLE) !== 0) {
                throw new Error("immutable");
            }
            this._array = null;
            this._size = 0;
            this._flags = Data.ALIASED;
        };
        Data.prototype.toUint8Array = function () {
            var oldArray = this._array;
            var flags = this._flags;
            if ((flags & Data.IMMUTABLE) !== 0) {
                return oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
            }
            else if ((flags & Data.ALIASED) !== 0 || this._size !== oldArray.length) {
                var newArray = oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
                this._array = newArray;
                this._flags &= ~Data.ALIASED;
                return newArray;
            }
            else {
                return oldArray;
            }
        };
        Data.prototype.asUint8Array = function () {
            var array;
            if (this._array && this._size > 0) {
                array = this._array;
                if (array.length !== this._size) {
                    array = new Uint8Array(array.buffer, array.byteOffset, this._size);
                }
            }
            else {
                array = void 0;
            }
            return array;
        };
        Data.prototype.toAny = function () {
            return this.toUint8Array();
        };
        Data.prototype.isAliased = function () {
            return (this._flags & Data.ALIASED) !== 0;
        };
        Data.prototype.isMutable = function () {
            return (this._flags & Data.IMMUTABLE) === 0;
        };
        Data.prototype.branch = function () {
            this._flags |= Data.ALIASED;
            return new Data(this._array, this._size, Data.ALIASED);
        };
        Data.prototype.clone = function () {
            return this.branch();
        };
        Data.prototype.commit = function () {
            this._flags |= Data.IMMUTABLE;
            return this;
        };
        Data.prototype.writeBase16 = function (output, base16) {
            if (base16 === void 0) { base16 = Base16.uppercase(); }
            var array = this._array;
            var size = this._size;
            if (array !== null && size !== 0) {
                if (array.length !== size) {
                    array = array.slice(0, size);
                }
                return base16.writeUint8Array(array, output);
            }
            else {
                return Writer.done();
            }
        };
        Data.prototype.toBase16 = function (base16) {
            if (base16 === void 0) { base16 = Base16.uppercase(); }
            var output = Unicode.stringOutput();
            this.writeBase16(output, base16);
            return output.bind();
        };
        Data.prototype.writeBase64 = function (output, base64) {
            if (base64 === void 0) { base64 = Base64.standard(); }
            var array = this._array;
            var size = this._size;
            if (array !== null && size !== 0) {
                if (array.length !== size) {
                    array = array.slice(0, size);
                }
                return base64.writeUint8Array(array, output);
            }
            else {
                return Writer.done();
            }
        };
        Data.prototype.toBase64 = function (base64) {
            if (base64 === void 0) { base64 = Base64.standard(); }
            var output = Unicode.stringOutput();
            this.writeBase64(output, base64);
            return output.bind();
        };
        Data.prototype.typeOrder = function () {
            return 4;
        };
        Data.prototype.compareTo = function (that) {
            if (that instanceof Data) {
                var xs = this._array;
                var ys = that._array;
                var xn = this._size;
                var yn = that._size;
                var order = 0;
                var i = 0;
                do {
                    if (i < xn && i < yn) {
                        order = xs[i] - ys[i];
                        i += 1;
                    }
                    else {
                        break;
                    }
                } while (order === 0);
                if (order > 0) {
                    return 1;
                }
                else if (order < 0) {
                    return -1;
                }
                else if (xn > yn) {
                    return 1;
                }
                else if (xn < yn) {
                    return -1;
                }
                else {
                    return 0;
                }
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Data.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Data) {
                var xs = this._array;
                var ys = that._array;
                var xn = this._size;
                if (xn !== that._size) {
                    return false;
                }
                for (var i = 0; i < xn; i += 1) {
                    if (xs[i] !== ys[i]) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        Data.prototype.hashCode = function () {
            if (Data._hashSeed === void 0) {
                Data._hashSeed = Murmur3.seed(Data);
            }
            return Murmur3.mash(Murmur3.mix(Data._hashSeed, this._array || new Uint8Array(0)));
        };
        Data.prototype.debug = function (output) {
            output = output.write("Data").write(46);
            if (this._size === 0) {
                output = output.write("empty").write(40).write(41);
            }
            else {
                output = output.write("base16").write(40).write(34);
                this.writeBase16(output);
                output = output.write(34).write(41);
            }
        };
        Data.prototype.display = function (output) {
            this.debug(output);
        };
        Data.output = function (data) {
            if (!(data instanceof Data)) {
                data = Data.create(data);
            }
            return new DataOutput(data, OutputSettings.standard());
        };
        Data.empty = function () {
            if (Data._empty == null) {
                Data._empty = new Data(null, 0, Data.ALIASED | Data.IMMUTABLE);
            }
            return Data._empty;
        };
        Data.create = function (initialCapacity) {
            if (initialCapacity === void 0) {
                return new Data(null, 0, Data.ALIASED);
            }
            else {
                return new Data(new Uint8Array(initialCapacity), 0, 0);
            }
        };
        Data.wrap = function (value) {
            return new Data(value, value.length, Data.ALIASED);
        };
        Data.fromBase16 = function (input) {
            if (typeof input === "string") {
                input = Unicode.stringInput(input);
            }
            return Base16.parse(input, Data.output()).bind();
        };
        Data.fromBase64 = function (input, base64) {
            if (base64 === void 0) { base64 = Base64.standard(); }
            if (typeof input === "string") {
                input = Unicode.stringInput(input);
            }
            return base64.parse(input, Data.output()).bind();
        };
        Data.fromAny = function (value) {
            if (value instanceof Data) {
                return value;
            }
            else if (value instanceof Uint8Array) {
                return Data.wrap(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Data.random = function (size) {
            var array = new Uint8Array(size);
            Random.fillBytes(array);
            return Data.wrap(array);
        };
        Data.expand = function (n) {
            n = Math.max(32, n) - 1;
            n |= n >> 1;
            n |= n >> 2;
            n |= n >> 4;
            n |= n >> 8;
            n |= n >> 16;
            return n + 1;
        };
        Data.ALIASED = 1 << 0;
        Data.IMMUTABLE = 1 << 1;
        return Data;
    }(Value));
    Item.Data = Data;

    var TextOutput = (function (_super) {
        __extends(TextOutput, _super);
        function TextOutput(string, settings) {
            var _this = _super.call(this) || this;
            _this._string = string;
            _this._settings = settings;
            return _this;
        }
        TextOutput.prototype.isCont = function () {
            return true;
        };
        TextOutput.prototype.isFull = function () {
            return false;
        };
        TextOutput.prototype.isDone = function () {
            return false;
        };
        TextOutput.prototype.isError = function () {
            return false;
        };
        TextOutput.prototype.isPart = function (isPart) {
            if (isPart === void 0) {
                return false;
            }
            else {
                return this;
            }
        };
        TextOutput.prototype.write = function (token) {
            if (typeof token === "number") {
                if ((token >= 0x0000 && token <= 0xd7ff)
                    || (token >= 0xe000 && token <= 0xffff)) {
                    token = String.fromCharCode(token);
                }
                else if (token >= 0x10000 && token <= 0x10ffff) {
                    var u = token - 0x10000;
                    token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));
                }
                else {
                    token = "\ufffd";
                }
            }
            this._string += token;
            return this;
        };
        TextOutput.prototype.settings = function (settings) {
            if (settings === void 0) {
                return this._settings;
            }
            else {
                this._settings = OutputSettings.fromAny(settings);
                return this;
            }
        };
        TextOutput.prototype.bind = function () {
            return Text.from(this._string);
        };
        TextOutput.prototype.clone = function () {
            return new TextOutput(this._string, this._settings);
        };
        TextOutput.prototype.toString = function () {
            return this._string;
        };
        return TextOutput;
    }(Output));

    var Text = (function (_super) {
        __extends(Text, _super);
        function Text(value) {
            var _this = _super.call(this) || this;
            _this._value = value;
            return _this;
        }
        Text.prototype.isConstant = function () {
            return true;
        };
        Object.defineProperty(Text.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Text.prototype, "size", {
            get: function () {
                return this._value.length;
            },
            enumerable: true,
            configurable: true
        });
        Text.prototype.stringValue = function (orElse) {
            return this._value;
        };
        Text.prototype.numberValue = function (orElse) {
            try {
                return Item.Num.from(this._value).numberValue();
            }
            catch (error) {
                return orElse;
            }
        };
        Text.prototype.booleanValue = function (orElse) {
            if (this._value === "true") {
                return true;
            }
            else if (this._value === "false") {
                return false;
            }
            else {
                return orElse;
            }
        };
        Text.prototype.toAny = function () {
            return this._value;
        };
        Text.prototype.valueOf = function () {
            return this._value;
        };
        Text.prototype.plus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Text) {
                return Text.from(this._value + that._value);
            }
            return _super.prototype.plus.call(this, that);
        };
        Text.prototype.branch = function () {
            return this;
        };
        Text.prototype.clone = function () {
            return this;
        };
        Text.prototype.commit = function () {
            return this;
        };
        Text.prototype.typeOrder = function () {
            return 5;
        };
        Text.prototype.compareTo = function (that) {
            if (that instanceof Text) {
                var order = this._value.localeCompare(that._value);
                return order < 0 ? -1 : order > 0 ? 1 : 0;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Text.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Text) {
                return this._value === that._value;
            }
            return false;
        };
        Text.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this._value);
            }
            return this._hashCode;
        };
        Text.prototype.debug = function (output) {
            output = output.write("Text").write(46);
            if (this._value.length === 0) {
                output = output.write("empty").write(40).write(41);
            }
            else {
                output = output.write("from").write(40).debug(this._value).write(41);
            }
        };
        Text.prototype.display = function (output) {
            Format.debug(this._value, output);
        };
        Text.prototype.toString = function () {
            return this._value;
        };
        Text.output = function (settings) {
            if (settings === void 0) { settings = OutputSettings.standard(); }
            return new TextOutput("", settings);
        };
        Text.empty = function () {
            if (!Text._empty) {
                Text._empty = new Text("");
            }
            return Text._empty;
        };
        Text.from = function (value) {
            var n = value.length;
            if (n === 0) {
                return Text.empty();
            }
            else {
                var text = new Text(value);
                if (n <= 64) {
                    text = Text.cache().put(text);
                }
                return text;
            }
        };
        Text.fromAny = function (value) {
            if (value instanceof Text) {
                return value;
            }
            else if (typeof value === "string") {
                return Text.from(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Text.cache = function () {
            if (Text._cache == null) {
                var cacheSize = 128;
                Text._cache = new HashGenCacheSet(cacheSize);
            }
            return Text._cache;
        };
        return Text;
    }(Value));
    Item.Text = Text;

    var Num = (function (_super) {
        __extends(Num, _super);
        function Num(value, flags) {
            if (flags === void 0) { flags = 0; }
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._flags = flags;
            return _this;
        }
        Num.prototype.isConstant = function () {
            return true;
        };
        Object.defineProperty(Num.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Num.prototype.isNaN = function () {
            return isNaN(this._value);
        };
        Num.prototype.isInfinite = function () {
            return !isNaN(this._value) && !isFinite(this._value);
        };
        Num.prototype.isUint32 = function () {
            return (this._flags & Num.UINT32) !== 0;
        };
        Num.prototype.isUint64 = function () {
            return (this._flags & Num.UINT64) !== 0;
        };
        Num.prototype.stringValue = function (orElse) {
            return "" + this._value;
        };
        Num.prototype.numberValue = function (orElse) {
            return this._value;
        };
        Num.prototype.booleanValue = function (orElse) {
            return !!this._value;
        };
        Num.prototype.toAny = function () {
            return this._value;
        };
        Num.prototype.valueOf = function () {
            return this._value;
        };
        Num.prototype.bitwiseOr = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from((this._value | that._value) >>> 0);
            }
            return _super.prototype.bitwiseOr.call(this, that);
        };
        Num.prototype.bitwiseXor = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from((this._value ^ that._value) >>> 0);
            }
            return _super.prototype.bitwiseXor.call(this, that);
        };
        Num.prototype.bitwiseAnd = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from((this._value & that._value) >>> 0);
            }
            return _super.prototype.bitwiseAnd.call(this, that);
        };
        Num.prototype.plus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from(this._value + that._value);
            }
            return _super.prototype.plus.call(this, that);
        };
        Num.prototype.minus = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from(this._value - that._value);
            }
            return _super.prototype.minus.call(this, that);
        };
        Num.prototype.times = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from(this._value * that._value);
            }
            return _super.prototype.times.call(this, that);
        };
        Num.prototype.divide = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from(this._value / that._value);
            }
            return _super.prototype.divide.call(this, that);
        };
        Num.prototype.modulo = function (that) {
            that = Item.fromAny(that);
            if (that instanceof Num) {
                return Num.from(this._value % that._value);
            }
            return _super.prototype.modulo.call(this, that);
        };
        Num.prototype.bitwiseNot = function () {
            return Num.from(~this._value >>> 0);
        };
        Num.prototype.negative = function () {
            return Num.from(-this._value);
        };
        Num.prototype.positive = function () {
            return this;
        };
        Num.prototype.inverse = function () {
            return Num.from(1 / this._value);
        };
        Num.prototype.abs = function () {
            return Num.from(Math.abs(this._value));
        };
        Num.prototype.ceil = function () {
            return Num.from(Math.ceil(this._value));
        };
        Num.prototype.floor = function () {
            return Num.from(Math.floor(this._value));
        };
        Num.prototype.round = function () {
            return Num.from(Math.round(this._value));
        };
        Num.prototype.sqrt = function () {
            return Num.from(Math.sqrt(this._value));
        };
        Num.prototype.pow = function (that) {
            that = Num.fromAny(that);
            return Num.from(Math.pow(this._value, that._value));
        };
        Num.prototype.max = function (that) {
            return this.compareTo(that) >= 0 ? this : that;
        };
        Num.prototype.min = function (that) {
            return this.compareTo(that) <= 0 ? this : that;
        };
        Num.prototype.typeOrder = function () {
            return 6;
        };
        Num.prototype.compareTo = function (that) {
            if (that instanceof Num) {
                var x = this._value;
                var y = that._value;
                return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Num.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Num) {
                var x = this._value;
                var y = that._value;
                return x === y || isNaN(x) && isNaN(y);
            }
            return false;
        };
        Num.prototype.hashCode = function () {
            return Murmur3.hash(this._value);
        };
        Num.prototype.debug = function (output) {
            output = output.write("Num").write(46).write("from")
                .write(40).display(this).write(41);
        };
        Num.prototype.display = function (output) {
            Format.displayNumber(this._value, output);
        };
        Num.positiveZero = function () {
            if (Num._positiveZero === void 0) {
                Num._positiveZero = new Num(0);
            }
            return Num._positiveZero;
        };
        Num.negativeZero = function () {
            if (Num._negativeZero === void 0) {
                Num._negativeZero = new Num(-0);
            }
            return Num._negativeZero;
        };
        Num.positiveOne = function () {
            if (Num._positiveOne === void 0) {
                Num._positiveOne = new Num(1);
            }
            return Num._positiveOne;
        };
        Num.negativeOne = function () {
            if (Num._negativeOne === void 0) {
                Num._negativeOne = new Num(-1);
            }
            return Num._negativeOne;
        };
        Num.nan = function () {
            if (Num._nan === void 0) {
                Num._nan = new Num(NaN);
            }
            return Num._nan;
        };
        Num.uint32 = function (value) {
            return new Num(value, Num.UINT32);
        };
        Num.uint64 = function (value) {
            return new Num(value, Num.UINT64);
        };
        Num.from = function (value) {
            if (typeof value === "number") {
                if (value === 0) {
                    if (1 / value === -Infinity) {
                        return Num.negativeZero();
                    }
                    else {
                        return Num.positiveZero();
                    }
                }
                else if (value === 1) {
                    return Num.positiveOne();
                }
                else if (value === -1) {
                    return Num.negativeOne();
                }
                else if (isNaN(value)) {
                    return Num.nan();
                }
                else {
                    return Num.cache().put(new Num(value));
                }
            }
            else if (typeof value === "string") {
                if (value === "NaN") {
                    return Num.nan();
                }
                else {
                    var num = +value;
                    if (isFinite(num)) {
                        return Num.from(num);
                    }
                }
                throw new Error(value);
            }
            throw new TypeError("" + value);
        };
        Num.fromAny = function (value) {
            if (value instanceof Num) {
                return value;
            }
            else if (typeof value === "number") {
                return Num.from(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Num.cache = function () {
            if (Num._cache == null) {
                var cacheSize = 16;
                Num._cache = new HashGenCacheSet(cacheSize);
            }
            return Num._cache;
        };
        Num.TYPE_MASK = 0x3;
        Num.UINT32 = 1;
        Num.UINT64 = 2;
        return Num;
    }(Value));
    Item.Num = Num;

    var Bool = (function (_super) {
        __extends(Bool, _super);
        function Bool(value) {
            var _this = _super.call(this) || this;
            _this._value = value;
            return _this;
        }
        Bool.prototype.isConstant = function () {
            return true;
        };
        Object.defineProperty(Bool.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Bool.prototype.stringValue = function (orElse) {
            return this._value ? "true" : "false";
        };
        Bool.prototype.booleanValue = function (orElse) {
            return this._value;
        };
        Bool.prototype.toAny = function () {
            return this._value;
        };
        Bool.prototype.valueOf = function () {
            return this._value;
        };
        Bool.prototype.conditional = function (thenTerm, elseTerm) {
            return this._value ? Item.fromAny(thenTerm) : Item.fromAny(elseTerm);
        };
        Bool.prototype.or = function (that) {
            return this._value ? this : Item.fromAny(that);
        };
        Bool.prototype.and = function (that) {
            return this._value ? Item.fromAny(that) : this;
        };
        Bool.prototype.not = function () {
            return Bool.from(!this._value);
        };
        Bool.prototype.typeOrder = function () {
            return 7;
        };
        Bool.prototype.compareTo = function (that) {
            if (that instanceof Bool) {
                if (this._value && !that._value) {
                    return -1;
                }
                else if (!this._value && that._value) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Bool.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Bool) {
                return this._value === that._value;
            }
            return false;
        };
        Bool.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this._value ? "true" : "false");
            }
            return this._hashCode;
        };
        Bool.prototype.debug = function (output) {
            output = output.write("Bool").write(46).write("from")
                .write(40).write(this._value ? "true" : "false").write(41);
        };
        Bool.prototype.display = function (output) {
            output = output.write(this._value ? "true" : "false");
        };
        Bool.from = function (value) {
            return value ? Bool.True : Bool.False;
        };
        Bool.fromAny = function (value) {
            if (value instanceof Bool) {
                return value;
            }
            else if (typeof value === "boolean") {
                return Bool.from(value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Bool.True = new Bool(true);
        Bool.False = new Bool(false);
        return Bool;
    }(Value));
    Item.Bool = Bool;

    var Expression = (function (_super) {
        __extends(Expression, _super);
        function Expression() {
            return _super.call(this) || this;
        }
        Expression.prototype.conditional = function (thenTerm, elseTerm) {
            thenTerm = Item.fromAny(thenTerm);
            elseTerm = Item.fromAny(elseTerm);
            return new Item.ConditionalOperator(this, thenTerm, elseTerm);
        };
        Expression.prototype.or = function (that) {
            that = Item.fromAny(that);
            return new Item.OrOperator(this, that);
        };
        Expression.prototype.and = function (that) {
            that = Item.fromAny(that);
            return new Item.AndOperator(this, that);
        };
        Expression.prototype.bitwiseOr = function (that) {
            that = Item.fromAny(that);
            return new Item.BitwiseOrOperator(this, that);
        };
        Expression.prototype.bitwiseXor = function (that) {
            that = Item.fromAny(that);
            return new Item.BitwiseXorOperator(this, that);
        };
        Expression.prototype.bitwiseAnd = function (that) {
            that = Item.fromAny(that);
            return new Item.BitwiseAndOperator(this, that);
        };
        Expression.prototype.lt = function (that) {
            that = Item.fromAny(that);
            return new Item.LtOperator(this, that);
        };
        Expression.prototype.le = function (that) {
            that = Item.fromAny(that);
            return new Item.LeOperator(this, that);
        };
        Expression.prototype.eq = function (that) {
            that = Item.fromAny(that);
            return new Item.EqOperator(this, that);
        };
        Expression.prototype.ne = function (that) {
            that = Item.fromAny(that);
            return new Item.NeOperator(this, that);
        };
        Expression.prototype.ge = function (that) {
            that = Item.fromAny(that);
            return new Item.GeOperator(this, that);
        };
        Expression.prototype.gt = function (that) {
            that = Item.fromAny(that);
            return new Item.GtOperator(this, that);
        };
        Expression.prototype.plus = function (that) {
            that = Item.fromAny(that);
            return new Item.PlusOperator(this, that);
        };
        Expression.prototype.minus = function (that) {
            that = Item.fromAny(that);
            return new Item.MinusOperator(this, that);
        };
        Expression.prototype.times = function (that) {
            that = Item.fromAny(that);
            return new Item.TimesOperator(this, that);
        };
        Expression.prototype.divide = function (that) {
            that = Item.fromAny(that);
            return new Item.DivideOperator(this, that);
        };
        Expression.prototype.modulo = function (that) {
            that = Item.fromAny(that);
            return new Item.ModuloOperator(this, that);
        };
        Expression.prototype.not = function () {
            return new Item.NotOperator(this);
        };
        Expression.prototype.bitwiseNot = function () {
            return new Item.BitwiseNotOperator(this);
        };
        Expression.prototype.negative = function () {
            return new Item.NegativeOperator(this);
        };
        Expression.prototype.positive = function () {
            return new Item.PositiveOperator(this);
        };
        Expression.prototype.inverse = function () {
            return new Item.DivideOperator(Item.Num.positiveOne(), this);
        };
        Expression.prototype.toAny = function () {
            return this;
        };
        return Expression;
    }(Value));
    Item.Expression = Expression;

    var Operator = (function (_super) {
        __extends(Operator, _super);
        function Operator() {
            return _super.call(this) || this;
        }
        return Operator;
    }(Expression));
    Item.Operator = Operator;

    var Selector = (function (_super) {
        __extends(Selector, _super);
        function Selector() {
            return _super.call(this) || this;
        }
        Selector.prototype.isConstant = function () {
            return false;
        };
        Selector.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var selected = Item.Record.create();
            this.forSelected(interpreter, function (interpreter) {
                var scope = interpreter.peekScope();
                if (scope) {
                    selected.push(scope);
                }
            }, this);
            return selected.isEmpty() ? Item.absent() : selected.flattened();
        };
        Selector.prototype.get = function (key) {
            key = Value.fromAny(key);
            return this.andThen(new Item.GetSelector(key, Selector.identity()));
        };
        Selector.prototype.getAttr = function (key) {
            key = Item.Text.fromAny(key);
            return this.andThen(new Item.GetAttrSelector(key, Selector.identity()));
        };
        Selector.prototype.getItem = function (index) {
            index = Item.Num.fromAny(index);
            return this.andThen(new Item.GetItemSelector(index, Selector.identity()));
        };
        Selector.prototype.keys = function () {
            return this.andThen(Selector.keys());
        };
        Selector.prototype.values = function () {
            return this.andThen(Selector.values());
        };
        Selector.prototype.children = function () {
            return this.andThen(Selector.children());
        };
        Selector.prototype.descendants = function () {
            return this.andThen(Selector.descendants());
        };
        Selector.prototype.filter = function (predicate) {
            if (arguments.length === 0) {
                return new Item.FilterSelector(this, Selector.identity());
            }
            else {
                predicate = Item.fromAny(predicate);
                return this.andThen(predicate.filter());
            }
        };
        Selector.prototype.invoke = function (args) {
            return new Item.InvokeOperator(this, args);
        };
        Selector.prototype.precedence = function () {
            return 11;
        };
        Selector.prototype.debug = function (output) {
            output = output.write("Selector").write(46).write("identity").write(40).write(41);
            this.debugThen(output);
        };
        Selector.identity = function () {
            return Selector._identity;
        };
        Selector.get = function (key) {
            key = Value.fromAny(key);
            return new Item.GetSelector(key, Selector.identity());
        };
        Selector.getAttr = function (key) {
            key = Item.Text.fromAny(key);
            return new Item.GetAttrSelector(key, Selector.identity());
        };
        Selector.getItem = function (index) {
            index = Item.Num.fromAny(index);
            return new Item.GetItemSelector(index, Selector.identity());
        };
        Selector.keys = function () {
            if (!Selector._keys) {
                Selector._keys = new Item.KeysSelector(Selector.identity());
            }
            return Selector._keys;
        };
        Selector.values = function () {
            if (!Selector._values) {
                Selector._values = new Item.ValuesSelector(Selector.identity());
            }
            return Selector._values;
        };
        Selector.children = function () {
            if (!Selector._children) {
                Selector._children = new Item.ChildrenSelector(Selector.identity());
            }
            return Selector._children;
        };
        Selector.descendants = function () {
            if (!Selector._descendants) {
                Selector._descendants = new Item.DescendantsSelector(Selector.identity());
            }
            return Selector._descendants;
        };
        Selector.literal = function (item) {
            item = Item.fromAny(item);
            if (!(item instanceof Selector)) {
                item = new Item.LiteralSelector(item, Selector.identity());
            }
            return item;
        };
        return Selector;
    }(Expression));
    Item.Selector = Selector;

    var Func = (function (_super) {
        __extends(Func, _super);
        function Func() {
            return _super.call(this) || this;
        }
        Func.prototype.expand = function (args, interpreter, operator) {
            return void 0;
        };
        Func.prototype.isConstant = function () {
            return false;
        };
        return Func;
    }(Expression));
    Item.Func = Func;

    var Extant = (function (_super) {
        __extends(Extant, _super);
        function Extant() {
            return _super.call(this) || this;
        }
        Extant.prototype.isDefined = function () {
            return true;
        };
        Extant.prototype.isDistinct = function () {
            return false;
        };
        Extant.prototype.isConstant = function () {
            return true;
        };
        Extant.prototype.unflattened = function () {
            return Value.Record.empty();
        };
        Extant.prototype.not = function () {
            return Value.absent();
        };
        Extant.prototype.stringValue = function (orElse) {
            return "";
        };
        Extant.prototype.booleanValue = function (orElse) {
            return true;
        };
        Extant.prototype.toAny = function () {
            return null;
        };
        Extant.prototype.typeOrder = function () {
            return 98;
        };
        Extant.prototype.compareTo = function (that) {
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Extant.prototype.equals = function (that) {
            return this === that;
        };
        Extant.prototype.hashCode = function () {
            if (Extant._hashSeed === void 0) {
                Extant._hashSeed = Murmur3.seed(Extant);
            }
            return Extant._hashSeed;
        };
        Extant.prototype.debug = function (output) {
            output = output.write("Value").write(46).write("extant").write(40).write(41);
        };
        Extant.prototype.display = function (output) {
            output = output.write("null");
        };
        Extant.extant = function () {
            return Extant._extant;
        };
        Extant.fromAny = function (value) {
            if (value instanceof Extant) {
                return value;
            }
            else if (value === null) {
                return Extant.extant();
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Extant._extant = new Extant();
        return Extant;
    }(Value));
    Item.Extant = Extant;

    var Absent = (function (_super) {
        __extends(Absent, _super);
        function Absent() {
            return _super.call(this) || this;
        }
        Absent.prototype.isDefined = function () {
            return false;
        };
        Absent.prototype.isDistinct = function () {
            return false;
        };
        Absent.prototype.isConstant = function () {
            return true;
        };
        Absent.prototype.unflattened = function () {
            return Value.Record.empty();
        };
        Absent.prototype.updated = function (key, value) {
            return Value.Record.of(Item.Slot.of(key, value));
        };
        Absent.prototype.updatedAttr = function (key, value) {
            return Value.Record.of(Item.Attr.of(key, value));
        };
        Absent.prototype.updatedSlot = function (key, value) {
            return Value.Record.of(Item.Slot.of(key, value));
        };
        Absent.prototype.appended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return Value.Record.of(items);
        };
        Absent.prototype.prepended = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return Value.Record.of(items);
        };
        Absent.prototype.concat = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var record = Value.Record.create();
            for (var i = 0, n = arguments.length; i < n; i += 1) {
                Item.fromAny(arguments[i]).forEach(function (item) {
                    record.push(item);
                });
            }
            return record;
        };
        Absent.prototype.cond = function (thenTerm, elseTerm) {
            return Item.fromAny(elseTerm);
        };
        Absent.prototype.or = function (that) {
            return Item.fromAny(that);
        };
        Absent.prototype.and = function (that) {
            return this;
        };
        Absent.prototype.not = function () {
            return Value.extant();
        };
        Absent.prototype.booleanValue = function (orElse) {
            return false;
        };
        Absent.prototype.toAny = function () {
            return void 0;
        };
        Absent.prototype.forEach = function (callback, thisArg) {
            return void 0;
        };
        Absent.prototype.iterator = function () {
            return Cursor.empty();
        };
        Absent.prototype.typeOrder = function () {
            return 99;
        };
        Absent.prototype.compareTo = function (that) {
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        Absent.prototype.equals = function (that) {
            return this === that;
        };
        Absent.prototype.hashCode = function () {
            if (Absent._hashSeed === void 0) {
                Absent._hashSeed = Murmur3.seed(Absent);
            }
            return Absent._hashSeed;
        };
        Absent.prototype.debug = function (output) {
            output = output.write("Value").write(46).write("absent").write(40).write(41);
        };
        Absent.prototype.display = function (output) {
            output = output.write("undefined");
        };
        Absent.absent = function () {
            return Absent._absent;
        };
        Absent.fromAny = function (value) {
            if (value instanceof Absent) {
                return value;
            }
            else if (value === void 0) {
                return Absent.absent();
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Absent._absent = new Absent();
        return Absent;
    }(Value));
    Item.Absent = Absent;

    var FormException = (function (_super) {
        __extends(FormException, _super);
        function FormException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = FormException.prototype;
            return _this;
        }
        return FormException;
    }(Error));

    var Form = (function () {
        function Form() {
        }
        Form.prototype.tag = function (tag) {
            if (arguments.length === 0) {
                return void 0;
            }
            else if (tag !== void 0) {
                return new Form.TagForm(tag, this);
            }
            else {
                return this;
            }
        };
        Form.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return void 0;
            }
            else if (unit !== void 0) {
                return new Form.UnitForm(unit, this);
            }
            else {
                return this;
            }
        };
        Form.forString = function () {
            if (!Form._stringForm) {
                Form._stringForm = new Form.StringForm("");
            }
            return Form._stringForm;
        };
        Form.forNumber = function () {
            if (!Form._numberForm) {
                Form._numberForm = new Form.NumberForm(0);
            }
            return Form._numberForm;
        };
        Form.forBoolean = function () {
            if (!Form._booleanForm) {
                Form._booleanForm = new Form.BooleanForm(false);
            }
            return Form._booleanForm;
        };
        Form.forAny = function () {
            if (!Form._anyForm) {
                Form._anyForm = new Form.AnyForm(void 0);
            }
            return Form._anyForm;
        };
        Form.forItem = function () {
            if (!Form._itemForm) {
                Form._itemForm = new Form.ItemForm(Item.absent());
            }
            return Form._itemForm;
        };
        Form.forValue = function () {
            if (!Form._valueForm) {
                Form._valueForm = new Form.ValueForm(Value.absent());
            }
            return Form._valueForm;
        };
        return Form;
    }());

    var BinaryOperator = (function (_super) {
        __extends(BinaryOperator, _super);
        function BinaryOperator(operand1, operand2) {
            var _this = _super.call(this) || this;
            _this._operand1 = operand1;
            _this._operand2 = operand2;
            return _this;
        }
        BinaryOperator.prototype.operand1 = function () {
            return this._operand1;
        };
        BinaryOperator.prototype.operand2 = function () {
            return this._operand2;
        };
        BinaryOperator.prototype.isConstant = function () {
            return this._operand1.isConstant() && this._operand2.isConstant();
        };
        return BinaryOperator;
    }(Operator));
    Item.BinaryOperator = BinaryOperator;

    var UnaryOperator = (function (_super) {
        __extends(UnaryOperator, _super);
        function UnaryOperator(operand) {
            var _this = _super.call(this) || this;
            _this._operand = operand;
            return _this;
        }
        UnaryOperator.prototype.operand = function () {
            return this._operand;
        };
        UnaryOperator.prototype.isConstant = function () {
            return this._operand.isConstant();
        };
        return UnaryOperator;
    }(Operator));
    Item.UnaryOperator = UnaryOperator;

    var ConditionalOperator = (function (_super) {
        __extends(ConditionalOperator, _super);
        function ConditionalOperator(ifTerm, thenTerm, elseTerm) {
            var _this = _super.call(this) || this;
            _this._ifTerm = ifTerm.commit();
            _this._thenTerm = thenTerm.commit();
            _this._elseTerm = elseTerm.commit();
            return _this;
        }
        ConditionalOperator.prototype.ifTerm = function () {
            return this._ifTerm;
        };
        ConditionalOperator.prototype.thenTerm = function () {
            return this._thenTerm;
        };
        ConditionalOperator.prototype.elseTerm = function () {
            return this._elseTerm;
        };
        ConditionalOperator.prototype.isConstant = function () {
            return this._ifTerm.isConstant() && this._thenTerm.isConstant()
                && this._elseTerm.isConstant();
        };
        ConditionalOperator.prototype.precedence = function () {
            return 2;
        };
        ConditionalOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var result;
            var ifTerm = this._ifTerm.evaluate(interpreter);
            if (ifTerm.booleanValue(false)) {
                var theTerm = this._thenTerm.evaluate(interpreter);
                result = theTerm;
            }
            else {
                var elseTerm = this._elseTerm.evaluate(interpreter);
                result = elseTerm;
            }
            interpreter.didOperate(this, result);
            return result;
        };
        ConditionalOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var ifTerm = this._ifTerm.substitute(interpreter);
            var thenTerm = this._thenTerm.substitute(interpreter);
            var elseTerm = this._elseTerm.substitute(interpreter);
            return new ConditionalOperator(ifTerm, thenTerm, elseTerm);
        };
        ConditionalOperator.prototype.typeOrder = function () {
            return 20;
        };
        ConditionalOperator.prototype.compareTo = function (that) {
            if (that instanceof ConditionalOperator) {
                var order = this._ifTerm.compareTo(that._ifTerm);
                if (order === 0) {
                    order = this._thenTerm.compareTo(that._thenTerm);
                    if (order === 0) {
                        order = this._elseTerm.compareTo(that._elseTerm);
                    }
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        ConditionalOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof ConditionalOperator) {
                return this._ifTerm.equals(that._ifTerm) && this._thenTerm.equals(that._thenTerm)
                    && this._elseTerm.equals(that._elseTerm);
            }
            return false;
        };
        ConditionalOperator.prototype.hashCode = function () {
            if (ConditionalOperator._hashSeed === void 0) {
                ConditionalOperator._hashSeed = Murmur3.seed(ConditionalOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(ConditionalOperator._hashSeed, this._ifTerm.hashCode()), this._thenTerm.hashCode()), this._elseTerm.hashCode()));
        };
        ConditionalOperator.prototype.debug = function (output) {
            output.debug(this._ifTerm).write(46).write("conditional").write(40)
                .debug(this._thenTerm).write(44).write(32)
                .debug(this._elseTerm).write(41);
        };
        ConditionalOperator.prototype.clone = function () {
            return new ConditionalOperator(this._ifTerm.clone(), this._thenTerm.clone(), this._elseTerm.clone());
        };
        return ConditionalOperator;
    }(Operator));
    Item.ConditionalOperator = ConditionalOperator;

    var OrOperator = (function (_super) {
        __extends(OrOperator, _super);
        function OrOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        OrOperator.prototype.operator = function () {
            return "||";
        };
        OrOperator.prototype.precedence = function () {
            return 3;
        };
        OrOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var result;
            var argument1 = this._operand1.evaluate(interpreter);
            if (argument1.booleanValue(false)) {
                result = argument1;
            }
            else {
                var argument2 = this._operand2.evaluate(interpreter);
                result = argument2;
            }
            interpreter.didOperate(this, result);
            return result;
        };
        OrOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.or(argument2);
        };
        OrOperator.prototype.typeOrder = function () {
            return 21;
        };
        OrOperator.prototype.compareTo = function (that) {
            if (that instanceof OrOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        OrOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof OrOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        OrOperator.prototype.hashCode = function () {
            if (OrOperator._hashSeed === void 0) {
                OrOperator._hashSeed = Murmur3.seed(OrOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(OrOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        OrOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("or").write(40)
                .debug(this._operand2).write(41);
        };
        OrOperator.prototype.clone = function () {
            return new OrOperator(this._operand1.clone(), this._operand2.clone());
        };
        return OrOperator;
    }(BinaryOperator));
    Item.OrOperator = OrOperator;

    var AndOperator = (function (_super) {
        __extends(AndOperator, _super);
        function AndOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        AndOperator.prototype.operator = function () {
            return "&&";
        };
        AndOperator.prototype.precedence = function () {
            return 4;
        };
        AndOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var result;
            var argument1 = this._operand1.evaluate(interpreter);
            if (argument1.booleanValue(false)) {
                var argument2 = this._operand2.evaluate(interpreter);
                result = argument2;
            }
            else {
                result = argument1;
            }
            interpreter.didOperate(this, result);
            return result;
        };
        AndOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.and(argument2);
        };
        AndOperator.prototype.typeOrder = function () {
            return 22;
        };
        AndOperator.prototype.compareTo = function (that) {
            if (that instanceof AndOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        AndOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof AndOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        AndOperator.prototype.hashCode = function () {
            if (AndOperator._hashSeed === void 0) {
                AndOperator._hashSeed = Murmur3.seed(AndOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(AndOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        AndOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("and").write(40)
                .debug(this._operand2).write(41);
        };
        AndOperator.prototype.clone = function () {
            return new AndOperator(this._operand1.clone(), this._operand2.clone());
        };
        return AndOperator;
    }(BinaryOperator));
    Item.AndOperator = AndOperator;

    var BitwiseOrOperator = (function (_super) {
        __extends(BitwiseOrOperator, _super);
        function BitwiseOrOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        BitwiseOrOperator.prototype.operator = function () {
            return "|";
        };
        BitwiseOrOperator.prototype.precedence = function () {
            return 5;
        };
        BitwiseOrOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.bitwiseOr(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        BitwiseOrOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.bitwiseOr(argument2);
        };
        BitwiseOrOperator.prototype.typeOrder = function () {
            return 23;
        };
        BitwiseOrOperator.prototype.compareTo = function (that) {
            if (that instanceof BitwiseOrOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        BitwiseOrOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof BitwiseOrOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        BitwiseOrOperator.prototype.hashCode = function () {
            if (BitwiseOrOperator._hashSeed === void 0) {
                BitwiseOrOperator._hashSeed = Murmur3.seed(BitwiseOrOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseOrOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        BitwiseOrOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("bitwiseOr").write(40)
                .debug(this._operand2).write(41);
        };
        BitwiseOrOperator.prototype.clone = function () {
            return new BitwiseOrOperator(this._operand1.clone(), this._operand2.clone());
        };
        return BitwiseOrOperator;
    }(BinaryOperator));
    Item.BitwiseOrOperator = BitwiseOrOperator;

    var BitwiseXorOperator = (function (_super) {
        __extends(BitwiseXorOperator, _super);
        function BitwiseXorOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        BitwiseXorOperator.prototype.operator = function () {
            return "^";
        };
        BitwiseXorOperator.prototype.precedence = function () {
            return 6;
        };
        BitwiseXorOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.bitwiseXor(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        BitwiseXorOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.bitwiseXor(argument2);
        };
        BitwiseXorOperator.prototype.typeOrder = function () {
            return 24;
        };
        BitwiseXorOperator.prototype.compareTo = function (that) {
            if (that instanceof BitwiseXorOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        BitwiseXorOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof BitwiseXorOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        BitwiseXorOperator.prototype.hashCode = function () {
            if (BitwiseXorOperator._hashSeed === void 0) {
                BitwiseXorOperator._hashSeed = Murmur3.seed(BitwiseXorOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseXorOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        BitwiseXorOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("bitwiseXor").write(40)
                .debug(this._operand2).write(41);
        };
        BitwiseXorOperator.prototype.clone = function () {
            return new BitwiseXorOperator(this._operand1.clone(), this._operand2.clone());
        };
        return BitwiseXorOperator;
    }(BinaryOperator));
    Item.BitwiseXorOperator = BitwiseXorOperator;

    var BitwiseAndOperator = (function (_super) {
        __extends(BitwiseAndOperator, _super);
        function BitwiseAndOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        BitwiseAndOperator.prototype.operator = function () {
            return "&";
        };
        BitwiseAndOperator.prototype.precedence = function () {
            return 7;
        };
        BitwiseAndOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.bitwiseAnd(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        BitwiseAndOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.bitwiseAnd(argument2);
        };
        BitwiseAndOperator.prototype.typeOrder = function () {
            return 25;
        };
        BitwiseAndOperator.prototype.compareTo = function (that) {
            if (that instanceof BitwiseAndOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        BitwiseAndOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof BitwiseAndOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        BitwiseAndOperator.prototype.hashCode = function () {
            if (BitwiseAndOperator._hashSeed === void 0) {
                BitwiseAndOperator._hashSeed = Murmur3.seed(BitwiseAndOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseAndOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        BitwiseAndOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("bitwiseAnd").write(40)
                .debug(this._operand2).write(41);
        };
        BitwiseAndOperator.prototype.clone = function () {
            return new BitwiseAndOperator(this._operand1.clone(), this._operand2.clone());
        };
        return BitwiseAndOperator;
    }(BinaryOperator));
    Item.BitwiseAndOperator = BitwiseAndOperator;

    var LtOperator = (function (_super) {
        __extends(LtOperator, _super);
        function LtOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        LtOperator.prototype.operator = function () {
            return "<";
        };
        LtOperator.prototype.precedence = function () {
            return 0;
        };
        LtOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.lt(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        LtOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.lt(argument2);
        };
        LtOperator.prototype.typeOrder = function () {
            return 26;
        };
        LtOperator.prototype.compareTo = function (that) {
            if (that instanceof LtOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        LtOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof LtOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        LtOperator.prototype.hashCode = function () {
            if (LtOperator._hashSeed === void 0) {
                LtOperator._hashSeed = Murmur3.seed(LtOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(LtOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        LtOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("lt").write(40)
                .debug(this._operand2).write(41);
        };
        LtOperator.prototype.clone = function () {
            return new LtOperator(this._operand1.clone(), this._operand2.clone());
        };
        return LtOperator;
    }(BinaryOperator));
    Item.LtOperator = LtOperator;

    var LeOperator = (function (_super) {
        __extends(LeOperator, _super);
        function LeOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        LeOperator.prototype.operator = function () {
            return "<=";
        };
        LeOperator.prototype.precedence = function () {
            return 0;
        };
        LeOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.le(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        LeOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.le(argument2);
        };
        LeOperator.prototype.typeOrder = function () {
            return 27;
        };
        LeOperator.prototype.compareTo = function (that) {
            if (that instanceof LeOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        LeOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof LeOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        LeOperator.prototype.hashCode = function () {
            if (LeOperator._hashSeed === void 0) {
                LeOperator._hashSeed = Murmur3.seed(LeOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(LeOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        LeOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("le").write(40)
                .debug(this._operand2).write(41);
        };
        LeOperator.prototype.clone = function () {
            return new LeOperator(this._operand1.clone(), this._operand2.clone());
        };
        return LeOperator;
    }(BinaryOperator));
    Item.LeOperator = LeOperator;

    var EqOperator = (function (_super) {
        __extends(EqOperator, _super);
        function EqOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        EqOperator.prototype.operator = function () {
            return "==";
        };
        EqOperator.prototype.precedence = function () {
            return 0;
        };
        EqOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.eq(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        EqOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.eq(argument2);
        };
        EqOperator.prototype.typeOrder = function () {
            return 28;
        };
        EqOperator.prototype.compareTo = function (that) {
            if (that instanceof EqOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        EqOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof EqOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        EqOperator.prototype.hashCode = function () {
            if (EqOperator._hashSeed === void 0) {
                EqOperator._hashSeed = Murmur3.seed(EqOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(EqOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        EqOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("eq").write(40)
                .debug(this._operand2).write(41);
        };
        EqOperator.prototype.clone = function () {
            return new EqOperator(this._operand1.clone(), this._operand2.clone());
        };
        return EqOperator;
    }(BinaryOperator));
    Item.EqOperator = EqOperator;

    var NeOperator = (function (_super) {
        __extends(NeOperator, _super);
        function NeOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        NeOperator.prototype.operator = function () {
            return "!=";
        };
        NeOperator.prototype.precedence = function () {
            return 0;
        };
        NeOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.ne(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        NeOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.ne(argument2);
        };
        NeOperator.prototype.typeOrder = function () {
            return 29;
        };
        NeOperator.prototype.compareTo = function (that) {
            if (that instanceof NeOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        NeOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof NeOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        NeOperator.prototype.hashCode = function () {
            if (NeOperator._hashSeed === void 0) {
                NeOperator._hashSeed = Murmur3.seed(NeOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(NeOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        NeOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("ne").write(40)
                .debug(this._operand2).write(41);
        };
        NeOperator.prototype.clone = function () {
            return new NeOperator(this._operand1.clone(), this._operand2.clone());
        };
        return NeOperator;
    }(BinaryOperator));
    Item.NeOperator = NeOperator;

    var GeOperator = (function (_super) {
        __extends(GeOperator, _super);
        function GeOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        GeOperator.prototype.operator = function () {
            return ">=";
        };
        GeOperator.prototype.precedence = function () {
            return 0;
        };
        GeOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.ge(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        GeOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.ge(argument2);
        };
        GeOperator.prototype.typeOrder = function () {
            return 30;
        };
        GeOperator.prototype.compareTo = function (that) {
            if (that instanceof GeOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        GeOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof GeOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        GeOperator.prototype.hashCode = function () {
            if (GeOperator._hashSeed === void 0) {
                GeOperator._hashSeed = Murmur3.seed(GeOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(GeOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        GeOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("ge").write(40)
                .debug(this._operand2).write(41);
        };
        GeOperator.prototype.clone = function () {
            return new GeOperator(this._operand1.clone(), this._operand2.clone());
        };
        return GeOperator;
    }(BinaryOperator));
    Item.GeOperator = GeOperator;

    var GtOperator = (function (_super) {
        __extends(GtOperator, _super);
        function GtOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        GtOperator.prototype.operator = function () {
            return ">";
        };
        GtOperator.prototype.precedence = function () {
            return 0;
        };
        GtOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.gt(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        GtOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.gt(argument2);
        };
        GtOperator.prototype.typeOrder = function () {
            return 31;
        };
        GtOperator.prototype.compareTo = function (that) {
            if (that instanceof GtOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        GtOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof GtOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        GtOperator.prototype.hashCode = function () {
            if (GtOperator._hashSeed === void 0) {
                GtOperator._hashSeed = Murmur3.seed(GtOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(GtOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        GtOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("gt").write(40)
                .debug(this._operand2).write(41);
        };
        GtOperator.prototype.clone = function () {
            return new GtOperator(this._operand1.clone(), this._operand2.clone());
        };
        return GtOperator;
    }(BinaryOperator));
    Item.GtOperator = GtOperator;

    var PlusOperator = (function (_super) {
        __extends(PlusOperator, _super);
        function PlusOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        PlusOperator.prototype.operator = function () {
            return "+";
        };
        PlusOperator.prototype.precedence = function () {
            return 8;
        };
        PlusOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.plus(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        PlusOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.plus(argument2);
        };
        PlusOperator.prototype.typeOrder = function () {
            return 32;
        };
        PlusOperator.prototype.compareTo = function (that) {
            if (that instanceof PlusOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        PlusOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof PlusOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        PlusOperator.prototype.hashCode = function () {
            if (PlusOperator._hashSeed === void 0) {
                PlusOperator._hashSeed = Murmur3.seed(PlusOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(PlusOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        PlusOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("plus").write(40)
                .debug(this._operand2).write(41);
        };
        PlusOperator.prototype.clone = function () {
            return new PlusOperator(this._operand1.clone(), this._operand2.clone());
        };
        return PlusOperator;
    }(BinaryOperator));
    Item.PlusOperator = PlusOperator;

    var MinusOperator = (function (_super) {
        __extends(MinusOperator, _super);
        function MinusOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        MinusOperator.prototype.operator = function () {
            return "-";
        };
        MinusOperator.prototype.precedence = function () {
            return 8;
        };
        MinusOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.minus(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        MinusOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.minus(argument2);
        };
        MinusOperator.prototype.typeOrder = function () {
            return 33;
        };
        MinusOperator.prototype.compareTo = function (that) {
            if (that instanceof MinusOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        MinusOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof MinusOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        MinusOperator.prototype.hashCode = function () {
            if (MinusOperator._hashSeed === void 0) {
                MinusOperator._hashSeed = Murmur3.seed(MinusOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(MinusOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        MinusOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("minus").write(40)
                .debug(this._operand2).write(41);
        };
        MinusOperator.prototype.clone = function () {
            return new MinusOperator(this._operand1.clone(), this._operand2.clone());
        };
        return MinusOperator;
    }(BinaryOperator));
    Item.MinusOperator = MinusOperator;

    var TimesOperator = (function (_super) {
        __extends(TimesOperator, _super);
        function TimesOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        TimesOperator.prototype.operator = function () {
            return "*";
        };
        TimesOperator.prototype.precedence = function () {
            return 9;
        };
        TimesOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.times(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        TimesOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.times(argument2);
        };
        TimesOperator.prototype.typeOrder = function () {
            return 34;
        };
        TimesOperator.prototype.compareTo = function (that) {
            if (that instanceof TimesOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        TimesOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof TimesOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        TimesOperator.prototype.hashCode = function () {
            if (TimesOperator._hashSeed === void 0) {
                TimesOperator._hashSeed = Murmur3.seed(TimesOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(TimesOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        TimesOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("times").write(40)
                .debug(this._operand2).write(41);
        };
        TimesOperator.prototype.clone = function () {
            return new TimesOperator(this._operand1.clone(), this._operand2.clone());
        };
        return TimesOperator;
    }(BinaryOperator));
    Item.TimesOperator = TimesOperator;

    var DivideOperator = (function (_super) {
        __extends(DivideOperator, _super);
        function DivideOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        DivideOperator.prototype.operator = function () {
            return "/";
        };
        DivideOperator.prototype.precedence = function () {
            return 9;
        };
        DivideOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.divide(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        DivideOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.divide(argument2);
        };
        DivideOperator.prototype.typeOrder = function () {
            return 35;
        };
        DivideOperator.prototype.compareTo = function (that) {
            if (that instanceof DivideOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        DivideOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof DivideOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        DivideOperator.prototype.hashCode = function () {
            if (DivideOperator._hashSeed === void 0) {
                DivideOperator._hashSeed = Murmur3.seed(DivideOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(DivideOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        DivideOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("divide").write(40)
                .debug(this._operand2).write(41);
        };
        DivideOperator.prototype.clone = function () {
            return new DivideOperator(this._operand1.clone(), this._operand2.clone());
        };
        return DivideOperator;
    }(BinaryOperator));
    Item.DivideOperator = DivideOperator;

    var ModuloOperator = (function (_super) {
        __extends(ModuloOperator, _super);
        function ModuloOperator(operand1, operand2) {
            return _super.call(this, operand1, operand2) || this;
        }
        ModuloOperator.prototype.operator = function () {
            return "%";
        };
        ModuloOperator.prototype.precedence = function () {
            return 9;
        };
        ModuloOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            interpreter.willOperate(this);
            var argument1 = this._operand1.evaluate(interpreter);
            var argument2 = this._operand2.evaluate(interpreter);
            var result = argument1.modulo(argument2);
            interpreter.didOperate(this, result);
            return result;
        };
        ModuloOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument1 = this._operand1.substitute(interpreter);
            var argument2 = this._operand2.substitute(interpreter);
            return argument1.modulo(argument2);
        };
        ModuloOperator.prototype.typeOrder = function () {
            return 36;
        };
        ModuloOperator.prototype.compareTo = function (that) {
            if (that instanceof ModuloOperator) {
                var order = this._operand1.compareTo(that._operand1);
                if (order === 0) {
                    order = this._operand2.compareTo(that._operand2);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        ModuloOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof ModuloOperator) {
                return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);
            }
            return false;
        };
        ModuloOperator.prototype.hashCode = function () {
            if (ModuloOperator._hashSeed === void 0) {
                ModuloOperator._hashSeed = Murmur3.seed(ModuloOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(ModuloOperator._hashSeed, this._operand1.hashCode()), this._operand2.hashCode()));
        };
        ModuloOperator.prototype.debug = function (output) {
            output.debug(this._operand1).write(46).write("modulo").write(40)
                .debug(this._operand2).write(41);
        };
        ModuloOperator.prototype.clone = function () {
            return new ModuloOperator(this._operand1.clone(), this._operand2.clone());
        };
        return ModuloOperator;
    }(BinaryOperator));
    Item.ModuloOperator = ModuloOperator;

    var NotOperator = (function (_super) {
        __extends(NotOperator, _super);
        function NotOperator(operand) {
            return _super.call(this, operand) || this;
        }
        NotOperator.prototype.operator = function () {
            return "!";
        };
        NotOperator.prototype.precedence = function () {
            return 10;
        };
        NotOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.evaluate(interpreter);
            return argument.not();
        };
        NotOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.substitute(interpreter);
            return argument.not();
        };
        NotOperator.prototype.typeOrder = function () {
            return 37;
        };
        NotOperator.prototype.compareTo = function (that) {
            if (that instanceof NotOperator) {
                return this._operand.compareTo(that._operand);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        NotOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof NotOperator) {
                return this._operand.equals(that._operand);
            }
            return false;
        };
        NotOperator.prototype.hashCode = function () {
            if (NotOperator._hashSeed === void 0) {
                NotOperator._hashSeed = Murmur3.seed(NotOperator);
            }
            return Murmur3.mash(Murmur3.mix(NotOperator._hashSeed, this._operand.hashCode()));
        };
        NotOperator.prototype.debug = function (output) {
            output.debug(this._operand).write(46).write("not").write(40).write(41);
        };
        NotOperator.prototype.clone = function () {
            return new NotOperator(this._operand.clone());
        };
        return NotOperator;
    }(UnaryOperator));
    Item.NotOperator = NotOperator;

    var BitwiseNotOperator = (function (_super) {
        __extends(BitwiseNotOperator, _super);
        function BitwiseNotOperator(operand) {
            return _super.call(this, operand) || this;
        }
        BitwiseNotOperator.prototype.operator = function () {
            return "~";
        };
        BitwiseNotOperator.prototype.precedence = function () {
            return 10;
        };
        BitwiseNotOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.evaluate(interpreter);
            return argument.bitwiseNot();
        };
        BitwiseNotOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.substitute(interpreter);
            return argument.bitwiseNot();
        };
        BitwiseNotOperator.prototype.typeOrder = function () {
            return 38;
        };
        BitwiseNotOperator.prototype.compareTo = function (that) {
            if (that instanceof BitwiseNotOperator) {
                return this._operand.compareTo(that._operand);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        BitwiseNotOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof BitwiseNotOperator) {
                return this._operand.equals(that._operand);
            }
            return false;
        };
        BitwiseNotOperator.prototype.hashCode = function () {
            if (BitwiseNotOperator._hashSeed === void 0) {
                BitwiseNotOperator._hashSeed = Murmur3.seed(BitwiseNotOperator);
            }
            return Murmur3.mash(Murmur3.mix(BitwiseNotOperator._hashSeed, this._operand.hashCode()));
        };
        BitwiseNotOperator.prototype.debug = function (output) {
            output.debug(this._operand).write(46).write("bitwiseNot").write(40).write(41);
        };
        BitwiseNotOperator.prototype.clone = function () {
            return new BitwiseNotOperator(this._operand.clone());
        };
        return BitwiseNotOperator;
    }(UnaryOperator));
    Item.BitwiseNotOperator = BitwiseNotOperator;

    var NegativeOperator = (function (_super) {
        __extends(NegativeOperator, _super);
        function NegativeOperator(operand) {
            return _super.call(this, operand) || this;
        }
        NegativeOperator.prototype.operator = function () {
            return "-";
        };
        NegativeOperator.prototype.precedence = function () {
            return 10;
        };
        NegativeOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.evaluate(interpreter);
            return argument.negative();
        };
        NegativeOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.substitute(interpreter);
            return argument.negative();
        };
        NegativeOperator.prototype.typeOrder = function () {
            return 39;
        };
        NegativeOperator.prototype.compareTo = function (that) {
            if (that instanceof NegativeOperator) {
                return this._operand.compareTo(that._operand);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        NegativeOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof NegativeOperator) {
                return this._operand.equals(that._operand);
            }
            return false;
        };
        NegativeOperator.prototype.hashCode = function () {
            if (NegativeOperator._hashSeed === void 0) {
                NegativeOperator._hashSeed = Murmur3.seed(NegativeOperator);
            }
            return Murmur3.mash(Murmur3.mix(NegativeOperator._hashSeed, this._operand.hashCode()));
        };
        NegativeOperator.prototype.debug = function (output) {
            output.debug(this._operand).write(46).write("negative").write(40).write(41);
        };
        NegativeOperator.prototype.clone = function () {
            return new NegativeOperator(this._operand.clone());
        };
        return NegativeOperator;
    }(UnaryOperator));
    Item.NegativeOperator = NegativeOperator;

    var PositiveOperator = (function (_super) {
        __extends(PositiveOperator, _super);
        function PositiveOperator(operand) {
            return _super.call(this, operand) || this;
        }
        PositiveOperator.prototype.operator = function () {
            return "+";
        };
        PositiveOperator.prototype.precedence = function () {
            return 10;
        };
        PositiveOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.evaluate(interpreter);
            return argument.positive();
        };
        PositiveOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var argument = this._operand.substitute(interpreter);
            return argument.positive();
        };
        PositiveOperator.prototype.typeOrder = function () {
            return 40;
        };
        PositiveOperator.prototype.compareTo = function (that) {
            if (that instanceof PositiveOperator) {
                return this._operand.compareTo(that._operand);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        PositiveOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof PositiveOperator) {
                return this._operand.equals(that._operand);
            }
            return false;
        };
        PositiveOperator.prototype.hashCode = function () {
            if (PositiveOperator._hashSeed === void 0) {
                PositiveOperator._hashSeed = Murmur3.seed(PositiveOperator);
            }
            return Murmur3.mash(Murmur3.mix(PositiveOperator._hashSeed, this._operand.hashCode()));
        };
        PositiveOperator.prototype.debug = function (output) {
            output.debug(this._operand).write(46).write("positive").write(40).write(41);
        };
        PositiveOperator.prototype.clone = function () {
            return new PositiveOperator(this._operand.clone());
        };
        return PositiveOperator;
    }(UnaryOperator));
    Item.PositiveOperator = PositiveOperator;

    var InvokeOperator = (function (_super) {
        __extends(InvokeOperator, _super);
        function InvokeOperator(func, args) {
            var _this = _super.call(this) || this;
            _this._func = func;
            _this._args = args.commit();
            return _this;
        }
        InvokeOperator.prototype.func = function () {
            return this._func;
        };
        InvokeOperator.prototype.args = function () {
            return this._args;
        };
        InvokeOperator.prototype.state = function () {
            return this._state;
        };
        InvokeOperator.prototype.setState = function (state) {
            this._state = state;
        };
        InvokeOperator.prototype.isConstant = function () {
            return this._func.isConstant() && this._args.isConstant();
        };
        InvokeOperator.prototype.precedence = function () {
            return 11;
        };
        InvokeOperator.prototype.evaluate = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var func = this._func.evaluate(interpreter);
            if (func instanceof Item.Func) {
                return func.invoke(this._args, interpreter, this);
            }
            return Item.absent();
        };
        InvokeOperator.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var func = this._func.evaluate(interpreter);
            if (func instanceof Item.Func) {
                var result = func.expand(this._args, interpreter, this);
                if (result) {
                    return result;
                }
            }
            var args = this._args.substitute(interpreter).toValue();
            return new InvokeOperator(this._func, args);
        };
        InvokeOperator.prototype.typeOrder = function () {
            return 41;
        };
        InvokeOperator.prototype.compareTo = function (that) {
            if (that instanceof InvokeOperator) {
                var order = this._func.compareTo(that._func);
                if (order === 0) {
                    order = this._args.compareTo(that._args);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        InvokeOperator.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof InvokeOperator) {
                return this._func.equals(that._func) && this._args.equals(that._args);
            }
            return false;
        };
        InvokeOperator.prototype.hashCode = function () {
            if (InvokeOperator._hashSeed === void 0) {
                InvokeOperator._hashSeed = Murmur3.seed(InvokeOperator);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(InvokeOperator._hashSeed, this._func.hashCode()), this._args.hashCode()));
        };
        InvokeOperator.prototype.debug = function (output) {
            output.debug(this._func).write(46).write("invoke").write(40)
                .debug(this._args).write(41);
        };
        InvokeOperator.prototype.clone = function () {
            return new InvokeOperator(this._func.clone(), this._args.clone());
        };
        return InvokeOperator;
    }(Operator));
    Item.InvokeOperator = InvokeOperator;

    var IdentitySelector = (function (_super) {
        __extends(IdentitySelector, _super);
        function IdentitySelector() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IdentitySelector.prototype.then = function () {
            return this;
        };
        IdentitySelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var oldScope = interpreter.popScope();
                var newScope = oldScope.evaluate(interpreter);
                interpreter.pushScope(newScope);
                selected = callback.call(thisArg, interpreter);
                interpreter.swapScope(oldScope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        IdentitySelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            return transform.call(thisArg, interpreter);
        };
        IdentitySelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            return interpreter.peekScope().substitute(interpreter);
        };
        IdentitySelector.prototype.get = function (key) {
            key = Value.fromAny(key);
            return new Item.GetSelector(key, this);
        };
        IdentitySelector.prototype.getAttr = function (key) {
            key = Item.Text.fromAny(key);
            return new Item.GetAttrSelector(key, this);
        };
        IdentitySelector.prototype.getItem = function (index) {
            index = Item.Num.fromAny(index);
            return new Item.GetItemSelector(index, this);
        };
        IdentitySelector.prototype.andThen = function (then) {
            return then;
        };
        IdentitySelector.prototype.keys = function () {
            return Selector.keys();
        };
        IdentitySelector.prototype.values = function () {
            return Selector.values();
        };
        IdentitySelector.prototype.children = function () {
            return Selector.children();
        };
        IdentitySelector.prototype.descendants = function () {
            return Selector.descendants();
        };
        IdentitySelector.prototype.filter = function (predicate) {
            if (arguments.length === 0) {
                return new Item.FilterSelector(this, this);
            }
            else {
                predicate = Item.fromAny(predicate);
                return predicate.filter();
            }
        };
        IdentitySelector.prototype.typeOrder = function () {
            return 10;
        };
        IdentitySelector.prototype.compareTo = function (that) {
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        IdentitySelector.prototype.equals = function (that) {
            return this === that;
        };
        IdentitySelector.prototype.hashCode = function () {
            if (IdentitySelector._hashSeed === void 0) {
                IdentitySelector._hashSeed = Murmur3.seed(IdentitySelector);
            }
            return IdentitySelector._hashSeed;
        };
        IdentitySelector.prototype.debugThen = function (output) {
        };
        IdentitySelector.prototype.clone = function () {
            return this;
        };
        return IdentitySelector;
    }(Selector));
    Item.IdentitySelector = IdentitySelector;
    Selector._identity = new IdentitySelector();

    var GetSelector = (function (_super) {
        __extends(GetSelector, _super);
        function GetSelector(key, then) {
            var _this = _super.call(this) || this;
            _this._key = key.commit();
            _this._then = then;
            return _this;
        }
        GetSelector.prototype.accessor = function () {
            return this._key;
        };
        GetSelector.prototype.then = function () {
            return this._then;
        };
        GetSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            interpreter.willSelect(this);
            var key = this._key.evaluate(interpreter).toValue();
            var selected = GetSelector.forSelected(key, this._then, interpreter, callback, thisArg);
            interpreter.didSelect(this, selected);
            return selected;
        };
        GetSelector.forSelected = function (key, then, interpreter, callback, thisArg) {
            var selected;
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var field = void 0;
                if (scope instanceof Item.Record) {
                    field = scope.getField(key);
                    if (field) {
                        interpreter.pushScope(field.toValue());
                        selected = then.forSelected(interpreter, callback, thisArg);
                        interpreter.popScope();
                    }
                }
                if (field === void 0 && selected === void 0) {
                    GetSelector.forSelected(key, then, interpreter, callback, thisArg);
                }
                interpreter.pushScope(scope);
            }
            return selected;
        };
        GetSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            var key = this._key.evaluate(interpreter).toValue();
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var oldField = scope.getField(key);
                    if (oldField) {
                        interpreter.pushScope(oldField.toValue());
                        var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                        interpreter.popScope();
                        if (newItem instanceof Item.Field) {
                            if (key.equals(newItem.key)) {
                                scope.set(key, newItem.toValue());
                            }
                            else {
                                scope.delete(key);
                                scope.push(newItem);
                            }
                        }
                        else if (newItem.isDefined()) {
                            scope.set(key, newItem.toValue());
                        }
                        else {
                            scope.delete(key);
                        }
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        GetSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key.evaluate(interpreter).toValue();
            var value = GetSelector.substitute(key, this._then, interpreter);
            if (value) {
                return value;
            }
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new GetSelector(this._key, then);
        };
        GetSelector.substitute = function (key, then, interpreter) {
            var selected;
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var field = void 0;
                if (scope instanceof Item.Record) {
                    field = scope.getField(key);
                    if (field) {
                        selected = field.toValue().substitute(interpreter);
                    }
                }
                if (field === void 0 && selected === void 0) {
                    GetSelector.substitute(key, then, interpreter);
                }
                interpreter.pushScope(scope);
            }
            return selected;
        };
        GetSelector.prototype.andThen = function (then) {
            return new GetSelector(this._key, this._then.andThen(then));
        };
        GetSelector.prototype.typeOrder = function () {
            return 12;
        };
        GetSelector.prototype.compareTo = function (that) {
            if (that instanceof GetSelector) {
                var order = this._key.compareTo(that._key);
                if (order === 0) {
                    order = this._then.compareTo(that._then);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        GetSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof GetSelector) {
                return this._key.equals(that._key) && this._then.equals(that._then);
            }
            return false;
        };
        GetSelector.prototype.hashCode = function () {
            if (GetSelector._hashSeed === void 0) {
                GetSelector._hashSeed = Murmur3.seed(GetSelector);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetSelector._hashSeed, this._key.hashCode()), this._then.hashCode()));
        };
        GetSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("get").write(40).debug(this._key).write(41);
            this._then.debugThen(output);
        };
        GetSelector.prototype.clone = function () {
            return new GetSelector(this._key.clone(), this._then.clone());
        };
        return GetSelector;
    }(Selector));
    Item.GetSelector = GetSelector;

    var GetAttrSelector = (function (_super) {
        __extends(GetAttrSelector, _super);
        function GetAttrSelector(key, then) {
            var _this = _super.call(this) || this;
            _this._key = key;
            _this._then = then;
            return _this;
        }
        GetAttrSelector.prototype.accessor = function () {
            return this._key;
        };
        GetAttrSelector.prototype.then = function () {
            return this._then;
        };
        GetAttrSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            interpreter.willSelect(this);
            var key = this._key;
            var selected = GetAttrSelector.forSelected(key, this._then, interpreter, callback);
            interpreter.didSelect(this, selected);
            return selected;
        };
        GetAttrSelector.forSelected = function (key, then, interpreter, callback, thisArg) {
            var selected;
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var field = void 0;
                if (scope instanceof Item.Record) {
                    field = scope.getField(key);
                    if (field instanceof Attr) {
                        interpreter.pushScope(field.toValue());
                        selected = then.forSelected(interpreter, callback, thisArg);
                        interpreter.popScope();
                    }
                }
                if (field === void 0 && selected === void 0) {
                    GetAttrSelector.forSelected(key, then, interpreter, callback, thisArg);
                }
                interpreter.pushScope(scope);
            }
            return selected;
        };
        GetAttrSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            var key = this._key;
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var oldField = scope.getField(key);
                    if (oldField instanceof Item.Attr) {
                        interpreter.pushScope(oldField.toValue());
                        var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                        interpreter.popScope();
                        if (newItem instanceof Item.Field) {
                            if (key.equals(newItem.key)) {
                                scope.setAttr(key, newItem.toValue());
                            }
                            else {
                                scope.delete(key);
                                scope.push(newItem);
                            }
                        }
                        else if (newItem.isDefined()) {
                            scope.setAttr(key, newItem.toValue());
                        }
                        else {
                            scope.delete(key);
                        }
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        GetAttrSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var key = this._key;
            var value = GetAttrSelector.substitute(key, this._then, interpreter);
            if (value) {
                return value;
            }
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new GetAttrSelector(this._key, then);
        };
        GetAttrSelector.substitute = function (key, then, interpreter) {
            var selected;
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var field = void 0;
                if (scope instanceof Item.Record) {
                    field = scope.getField(key);
                    if (field instanceof Item.Attr) {
                        selected = field.toValue().substitute(interpreter);
                    }
                }
                if (field === void 0 && selected === void 0) {
                    GetAttrSelector.substitute(key, then, interpreter);
                }
                interpreter.pushScope(scope);
            }
            return selected;
        };
        GetAttrSelector.prototype.andThen = function (then) {
            return new GetAttrSelector(this._key, this._then.andThen(then));
        };
        GetAttrSelector.prototype.typeOrder = function () {
            return 13;
        };
        GetAttrSelector.prototype.compareTo = function (that) {
            if (that instanceof GetAttrSelector) {
                var order = this._key.compareTo(that._key);
                if (order === 0) {
                    order = this._then.compareTo(that._then);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        GetAttrSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof GetAttrSelector) {
                return this._key.equals(that._key) && this._then.equals(that._then);
            }
            return false;
        };
        GetAttrSelector.prototype.hashCode = function () {
            if (GetAttrSelector._hashSeed === void 0) {
                GetAttrSelector._hashSeed = Murmur3.seed(GetAttrSelector);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetAttrSelector._hashSeed, this._key.hashCode()), this._then.hashCode()));
        };
        GetAttrSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("getAttr").write(40).debug(this._key).write(41);
            this._then.debugThen(output);
        };
        GetAttrSelector.prototype.clone = function () {
            return new GetAttrSelector(this._key.clone(), this._then.clone());
        };
        return GetAttrSelector;
    }(Selector));
    Item.GetAttrSelector = GetAttrSelector;

    var GetItemSelector = (function (_super) {
        __extends(GetItemSelector, _super);
        function GetItemSelector(index, then) {
            var _this = _super.call(this) || this;
            _this._index = index;
            _this._then = then;
            return _this;
        }
        GetItemSelector.prototype.accessor = function () {
            return this._index;
        };
        GetItemSelector.prototype.then = function () {
            return this._then;
        };
        GetItemSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            var index = this._index.numberValue();
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record && index < scope.length) {
                    var item = scope.getItem(index);
                    interpreter.pushScope(item);
                    selected = this._then.forSelected(interpreter, callback, thisArg);
                    interpreter.popScope();
                }
                interpreter.pushScope(scope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        GetItemSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var index = this._index.numberValue();
                if (scope instanceof Item.Record && index < scope.length) {
                    var oldItem = scope.getItem(index);
                    interpreter.pushScope(oldItem);
                    var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                    interpreter.popScope();
                    if (newItem.isDefined()) {
                        scope.setItem(index, newItem);
                    }
                    else {
                        scope.splice(index, 1);
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        GetItemSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var index = this._index.numberValue();
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                var selected = void 0;
                if (scope instanceof Item.Record && index < scope.length) {
                    var item = scope.getItem(index);
                    selected = item.substitute(interpreter);
                }
                interpreter.pushScope(scope);
                if (selected) {
                    return selected;
                }
            }
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new GetItemSelector(this._index, then);
        };
        GetItemSelector.prototype.andThen = function (then) {
            return new GetItemSelector(this._index, this._then.andThen(then));
        };
        GetItemSelector.prototype.typeOrder = function () {
            return 14;
        };
        GetItemSelector.prototype.compareTo = function (that) {
            if (that instanceof GetItemSelector) {
                var order = this._index.compareTo(that._index);
                if (order === 0) {
                    order = this._then.compareTo(that._then);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        GetItemSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof GetItemSelector) {
                return this._index.equals(that._index) && this._then.equals(that._then);
            }
            return false;
        };
        GetItemSelector.prototype.hashCode = function () {
            if (GetItemSelector._hashSeed === void 0) {
                GetItemSelector._hashSeed = Murmur3.seed(GetItemSelector);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetItemSelector._hashSeed, this._index.hashCode()), this._then.hashCode()));
        };
        GetItemSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("getItem").write(40).debug(this._index).write(41);
            this._then.debugThen(output);
        };
        GetItemSelector.prototype.clone = function () {
            return new GetItemSelector(this._index, this._then.clone());
        };
        return GetItemSelector;
    }(Selector));
    Item.GetItemSelector = GetItemSelector;

    var KeysSelector = (function (_super) {
        __extends(KeysSelector, _super);
        function KeysSelector(then) {
            var _this = _super.call(this) || this;
            _this._then = then;
            return _this;
        }
        KeysSelector.prototype.then = function () {
            return this._then;
        };
        KeysSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (selected === void 0 && children.hasNext()) {
                        var child = children.next().value;
                        if (child instanceof Item.Field) {
                            interpreter.pushScope(child.key);
                            selected = this._then.forSelected(interpreter, callback, thisArg);
                            interpreter.popScope();
                        }
                    }
                }
                else if (scope instanceof Item.Field) {
                    interpreter.pushScope(scope.key);
                    selected = this._then.forSelected(interpreter, callback, thisArg);
                    interpreter.popScope();
                }
                interpreter.pushScope(scope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        KeysSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (children.hasNext()) {
                        var child = children.next().value;
                        if (child instanceof Item.Field) {
                            var oldKey = child.key;
                            interpreter.pushScope(oldKey);
                            var newKey = this._then.mapSelected(interpreter, transform, thisArg).toValue();
                            interpreter.popScope();
                            if (newKey.isDefined()) {
                                if (oldKey !== newKey) {
                                    if (scope instanceof Item.Attr && newKey instanceof Item.Text) {
                                        children.set(Item.Attr.of(newKey, scope.toValue()));
                                    }
                                    else {
                                        children.set(Item.Slot.of(newKey, scope.toValue()));
                                    }
                                }
                            }
                            else {
                                children.delete();
                            }
                        }
                    }
                }
                else if (scope instanceof Item.Field) {
                    var oldKey = scope.key;
                    interpreter.pushScope(oldKey);
                    var newKey = this._then.mapSelected(interpreter, transform, thisArg).toValue();
                    interpreter.popScope();
                    if (newKey.isDefined()) {
                        if (oldKey !== newKey) {
                            if (scope instanceof Item.Attr && newKey instanceof Item.Text) {
                                scope = Item.Attr.of(newKey, scope.toValue());
                            }
                            else {
                                scope = Item.Slot.of(newKey, scope.toValue());
                            }
                        }
                    }
                    else {
                        scope = Item.absent();
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        KeysSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new KeysSelector(then);
        };
        KeysSelector.prototype.andThen = function (then) {
            return new KeysSelector(this._then.andThen(then));
        };
        KeysSelector.prototype.typeOrder = function () {
            return 15;
        };
        KeysSelector.prototype.compareTo = function (that) {
            if (that instanceof KeysSelector) {
                return this._then.compareTo(that._then);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        KeysSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof KeysSelector) {
                return this._then.equals(that._then);
            }
            return false;
        };
        KeysSelector.prototype.hashCode = function () {
            if (KeysSelector._hashSeed === void 0) {
                KeysSelector._hashSeed = Murmur3.seed(KeysSelector);
            }
            return Murmur3.mash(Murmur3.mix(KeysSelector._hashSeed, this._then.hashCode()));
        };
        KeysSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("keys").write(40).write(41);
            this._then.debugThen(output);
        };
        KeysSelector.prototype.clone = function () {
            return new KeysSelector(this._then.clone());
        };
        return KeysSelector;
    }(Selector));
    Item.KeysSelector = KeysSelector;

    var ValuesSelector = (function (_super) {
        __extends(ValuesSelector, _super);
        function ValuesSelector(then) {
            var _this = _super.call(this) || this;
            _this._then = then;
            return _this;
        }
        ValuesSelector.prototype.then = function () {
            return this._then;
        };
        ValuesSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (selected === void 0 && children.hasNext()) {
                        var child = children.next().value;
                        interpreter.pushScope(child.toValue());
                        selected = this._then.forSelected(interpreter, callback, thisArg);
                        interpreter.popScope();
                    }
                }
                else {
                    interpreter.pushScope(scope.toValue());
                    selected = this._then.forSelected(interpreter, callback, thisArg);
                    interpreter.popScope();
                }
                interpreter.pushScope(scope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        ValuesSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (children.hasNext()) {
                        var child = children.next().value;
                        if (child instanceof Item.Field) {
                            var oldValue = child.toValue();
                            interpreter.pushScope(oldValue);
                            var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                            interpreter.popScope();
                            if (newItem.isDefined()) {
                                if (newItem instanceof Item.Field) {
                                    children.set(newItem);
                                }
                                else if (newItem !== oldValue) {
                                    children.set(child.updatedValue(newItem.toValue()));
                                }
                            }
                            else {
                                children.delete();
                            }
                        }
                        else {
                            interpreter.pushScope(child.toValue());
                            var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                            interpreter.popScope();
                            if (newItem.isDefined()) {
                                if (child !== newItem) {
                                    children.set(newItem);
                                }
                            }
                            else {
                                children.delete();
                            }
                        }
                    }
                }
                else if (scope instanceof Item.Field) {
                    var oldValue = scope.toValue();
                    interpreter.pushScope(oldValue);
                    var newItem = this._then.mapSelected(interpreter, transform, thisArg);
                    interpreter.popScope();
                    if (newItem.isDefined()) {
                        if (newItem instanceof Item.Field) {
                            scope = newItem;
                        }
                        else if (newItem !== oldValue) {
                            scope = scope.updatedValue(newItem.toValue());
                        }
                    }
                    else {
                        scope = Item.absent();
                    }
                }
                else {
                    interpreter.pushScope(scope);
                    scope = this._then.mapSelected(interpreter, transform, thisArg);
                    interpreter.popScope();
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        ValuesSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new ValuesSelector(then);
        };
        ValuesSelector.prototype.andThen = function (then) {
            return new ValuesSelector(this._then.andThen(then));
        };
        ValuesSelector.prototype.typeOrder = function () {
            return 16;
        };
        ValuesSelector.prototype.compareTo = function (that) {
            if (that instanceof ValuesSelector) {
                return this._then.compareTo(that._then);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        ValuesSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof ValuesSelector) {
                return this._then.equals(that._then);
            }
            return false;
        };
        ValuesSelector.prototype.hashCode = function () {
            if (ValuesSelector._hashSeed === void 0) {
                ValuesSelector._hashSeed = Murmur3.seed(ValuesSelector);
            }
            return Murmur3.mash(Murmur3.mix(ValuesSelector._hashSeed, this._then.hashCode()));
        };
        ValuesSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("values").write(40).write(41);
            this._then.debugThen(output);
        };
        ValuesSelector.prototype.clone = function () {
            return new ValuesSelector(this._then.clone());
        };
        return ValuesSelector;
    }(Selector));
    Item.ValuesSelector = ValuesSelector;

    var ChildrenSelector = (function (_super) {
        __extends(ChildrenSelector, _super);
        function ChildrenSelector(then) {
            var _this = _super.call(this) || this;
            _this._then = then;
            return _this;
        }
        ChildrenSelector.prototype.then = function () {
            return this._then;
        };
        ChildrenSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (selected === void 0 && children.hasNext()) {
                        var child = children.next().value;
                        interpreter.pushScope(child);
                        selected = this._then.forSelected(interpreter, callback, thisArg);
                        interpreter.popScope();
                    }
                }
                interpreter.pushScope(scope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        ChildrenSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (children.hasNext()) {
                        var oldChild = children.next().value;
                        interpreter.pushScope(oldChild);
                        var newChild = this._then.mapSelected(interpreter, transform);
                        interpreter.popScope();
                        if (newChild.isDefined()) {
                            if (newChild !== oldChild) {
                                children.set(newChild);
                            }
                        }
                        else {
                            children.delete();
                        }
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        ChildrenSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new ChildrenSelector(then);
        };
        ChildrenSelector.prototype.andThen = function (then) {
            return new ChildrenSelector(this._then.andThen(then));
        };
        ChildrenSelector.prototype.typeOrder = function () {
            return 17;
        };
        ChildrenSelector.prototype.compareTo = function (that) {
            if (that instanceof ChildrenSelector) {
                return this._then.compareTo(that._then);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        ChildrenSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof ChildrenSelector) {
                return this._then.equals(that._then);
            }
            return false;
        };
        ChildrenSelector.prototype.hashCode = function () {
            if (ChildrenSelector._hashSeed === void 0) {
                ChildrenSelector._hashSeed = Murmur3.seed(ChildrenSelector);
            }
            return Murmur3.mash(Murmur3.mix(ChildrenSelector._hashSeed, this._then.hashCode()));
        };
        ChildrenSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("children").write(40).write(41);
            this._then.debugThen(output);
        };
        ChildrenSelector.prototype.clone = function () {
            return new ChildrenSelector(this._then.clone());
        };
        return ChildrenSelector;
    }(Selector));
    Item.ChildrenSelector = ChildrenSelector;

    var DescendantsSelector = (function (_super) {
        __extends(DescendantsSelector, _super);
        function DescendantsSelector(then) {
            var _this = _super.call(this) || this;
            _this._then = then;
            return _this;
        }
        DescendantsSelector.prototype.then = function () {
            return this._then;
        };
        DescendantsSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (selected === void 0 && children.hasNext()) {
                        var child = children.next().value;
                        interpreter.pushScope(child);
                        selected = this._then.forSelected(interpreter, callback, thisArg);
                        if (selected === void 0) {
                            this.forSelected(interpreter, callback, thisArg);
                        }
                        interpreter.popScope();
                    }
                }
                interpreter.pushScope(scope);
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        DescendantsSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var scope = interpreter.popScope().toValue();
                if (scope instanceof Item.Record) {
                    var children = scope.iterator();
                    while (children.hasNext()) {
                        var oldChild = children.next().value;
                        interpreter.pushScope(oldChild);
                        var newChild = this._then.mapSelected(interpreter, transform, thisArg);
                        if (newChild.isDefined()) {
                            newChild = this.mapSelected(interpreter, transform, thisArg);
                        }
                        interpreter.popScope();
                        if (newChild.isDefined()) {
                            if (newChild !== oldChild) {
                                children.set(newChild);
                            }
                        }
                        else {
                            children.delete();
                        }
                    }
                }
                interpreter.pushScope(scope);
                result = scope;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        DescendantsSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new DescendantsSelector(then);
        };
        DescendantsSelector.prototype.andThen = function (then) {
            return new DescendantsSelector(this._then.andThen(then));
        };
        DescendantsSelector.prototype.typeOrder = function () {
            return 18;
        };
        DescendantsSelector.prototype.compareTo = function (that) {
            if (that instanceof DescendantsSelector) {
                return this._then.compareTo(that._then);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        DescendantsSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof DescendantsSelector) {
                return this._then.equals(that._then);
            }
            return false;
        };
        DescendantsSelector.prototype.hashCode = function () {
            if (DescendantsSelector._hashSeed === void 0) {
                DescendantsSelector._hashSeed = Murmur3.seed(DescendantsSelector);
            }
            return Murmur3.mash(Murmur3.mix(DescendantsSelector._hashSeed, this._then.hashCode()));
        };
        DescendantsSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("descendants").write(40).write(41);
            this._then.debugThen(output);
        };
        DescendantsSelector.prototype.clone = function () {
            return new DescendantsSelector(this._then.clone());
        };
        return DescendantsSelector;
    }(Selector));
    Item.DescendantsSelector = DescendantsSelector;

    var FilterSelector = (function (_super) {
        __extends(FilterSelector, _super);
        function FilterSelector(predicate, then) {
            var _this = _super.call(this) || this;
            _this._predicate = predicate;
            _this._then = then;
            return _this;
        }
        FilterSelector.prototype.predicate = function () {
            return this._predicate;
        };
        FilterSelector.prototype.then = function () {
            return this._then;
        };
        FilterSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                if (this.filterSelected(interpreter)) {
                    selected = this._then.forSelected(interpreter, callback, thisArg);
                }
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        FilterSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                if (this.filterSelected(interpreter)) {
                    result = this._then.mapSelected(interpreter, transform, thisArg);
                }
                else {
                    result = interpreter.peekScope().toValue();
                }
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        FilterSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var predicate = this._predicate.substitute(interpreter);
            if (!(predicate instanceof Selector)) {
                predicate = this._predicate;
            }
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new FilterSelector(predicate, then);
        };
        FilterSelector.prototype.filterSelected = function (interpreter) {
            return this._predicate.forSelected(interpreter, this.selected, this) !== void 0;
        };
        FilterSelector.prototype.selected = function (interpreter) {
            return null;
        };
        FilterSelector.prototype.andThen = function (then) {
            return new FilterSelector(this._predicate, this._then.andThen(then));
        };
        FilterSelector.prototype.filter = function (predicate) {
            if (arguments.length === 0) {
                return this;
            }
            else {
                predicate = Item.fromAny(predicate);
                return this.andThen(predicate.filter());
            }
        };
        FilterSelector.prototype.typeOrder = function () {
            return 19;
        };
        FilterSelector.prototype.compareTo = function (that) {
            if (that instanceof FilterSelector) {
                var order = this._predicate.compareTo(that._predicate);
                if (order === 0) {
                    order = this._then.compareTo(that._then);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        FilterSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof FilterSelector) {
                return this._predicate.equals(that._predicate) && this._then.equals(that._then);
            }
            return false;
        };
        FilterSelector.prototype.hashCode = function () {
            if (FilterSelector._hashSeed === void 0) {
                FilterSelector._hashSeed = Murmur3.seed(FilterSelector);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(FilterSelector._hashSeed, this._predicate.hashCode()), this._then.hashCode()));
        };
        FilterSelector.prototype.debugThen = function (output) {
            output = output.write(46).write("filter").write(40).debug(this._predicate).write(41);
            this._then.debugThen(output);
        };
        FilterSelector.prototype.clone = function () {
            return new FilterSelector(this._predicate.clone(), this._then.clone());
        };
        return FilterSelector;
    }(Selector));
    Item.FilterSelector = FilterSelector;

    var LiteralSelector = (function (_super) {
        __extends(LiteralSelector, _super);
        function LiteralSelector(item, then) {
            var _this = _super.call(this) || this;
            _this._item = item.commit();
            _this._then = then;
            return _this;
        }
        LiteralSelector.prototype.item = function () {
            return this._item;
        };
        LiteralSelector.prototype.then = function () {
            return this._then;
        };
        LiteralSelector.prototype.forSelected = function (interpreter, callback, thisArg) {
            var selected;
            interpreter.willSelect(this);
            if (interpreter.scopeDepth() !== 0) {
                var literal = this._item.evaluate(interpreter);
                if (literal.isDefined()) {
                    interpreter.pushScope(literal);
                    selected = this._then.forSelected(interpreter, callback, thisArg);
                    interpreter.popScope();
                }
            }
            interpreter.didSelect(this, selected);
            return selected;
        };
        LiteralSelector.prototype.mapSelected = function (interpreter, transform, thisArg) {
            var result;
            interpreter.willTransform(this);
            if (interpreter.scopeDepth() !== 0) {
                var literal = this._item.evaluate(interpreter);
                if (literal.isDefined()) {
                    interpreter.pushScope(literal);
                    literal = this._then.mapSelected(interpreter, transform, thisArg);
                    interpreter.popScope();
                }
                result = literal;
            }
            else {
                result = Item.absent();
            }
            interpreter.didTransform(this, result);
            return result;
        };
        LiteralSelector.prototype.substitute = function (interpreter) {
            interpreter = Interpreter.fromAny(interpreter);
            var item = this._item.substitute(interpreter);
            var then = this._then.substitute(interpreter);
            if (!(then instanceof Selector)) {
                then = this._then;
            }
            return new LiteralSelector(item, then);
        };
        LiteralSelector.prototype.andThen = function (then) {
            return new LiteralSelector(this._item, this._then.andThen(then));
        };
        LiteralSelector.prototype.precedence = function () {
            return this._item.precedence();
        };
        LiteralSelector.prototype.typeOrder = function () {
            return 11;
        };
        LiteralSelector.prototype.compareTo = function (that) {
            if (that instanceof LiteralSelector) {
                var order = this._item.compareTo(that._item);
                if (order === 0) {
                    order = this._then.compareTo(that._then);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        LiteralSelector.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof LiteralSelector) {
                return this._item.equals(that._item) && this._then.equals(that._then);
            }
            return false;
        };
        LiteralSelector.prototype.hashCode = function () {
            if (LiteralSelector._hashSeed === void 0) {
                LiteralSelector._hashSeed = Murmur3.seed(LiteralSelector);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(LiteralSelector._hashSeed, this._item.hashCode()), this._then.hashCode()));
        };
        LiteralSelector.prototype.debug = function (output) {
            output = output.write("Selector").write(46).write("literal").write(40)
                .debug(this._item).write(41);
            this._then.debugThen(output);
        };
        LiteralSelector.prototype.debugThen = function (output) {
        };
        LiteralSelector.prototype.clone = function () {
            return new LiteralSelector(this._item.clone(), this._then.clone());
        };
        return LiteralSelector;
    }(Selector));
    Item.LiteralSelector = LiteralSelector;

    var LambdaFunc = (function (_super) {
        __extends(LambdaFunc, _super);
        function LambdaFunc(bindings, template) {
            var _this = _super.call(this) || this;
            _this._bindings = bindings;
            _this._template = template;
            return _this;
        }
        LambdaFunc.prototype.bindings = function () {
            return this._bindings;
        };
        LambdaFunc.prototype.template = function () {
            return this._template;
        };
        LambdaFunc.prototype.precedence = function () {
            return 1;
        };
        LambdaFunc.prototype.invoke = function (args, interpreter, operator) {
            interpreter = Interpreter.fromAny(interpreter);
            var bindings = this._bindings;
            var arity = Math.max(1, bindings.length);
            var params = Item.Record.create(arity);
            var i = 0;
            var j = 0;
            while (i < arity) {
                var binding = bindings instanceof Item.Record ? bindings.getItem(i) : i === 0 ? bindings : Item.absent();
                var arg = args instanceof Item.Record ? args.getItem(j).toValue() : j === 0 ? args : Item.Value.absent();
                if (binding instanceof Item.Text && arg.isDistinct()) {
                    params.push(Item.Slot.of(binding, arg));
                    j += 1;
                }
                else if (binding instanceof Item.Slot) {
                    if (arg.isDistinct()) {
                        params.push(binding.updatedValue(arg));
                    }
                    else {
                        params.push(binding);
                    }
                    j += 1;
                }
                i += 1;
            }
            interpreter.pushScope(params);
            var result = this._template.evaluate(interpreter);
            interpreter.popScope();
            return result;
        };
        LambdaFunc.prototype.typeOrder = function () {
            return 50;
        };
        LambdaFunc.prototype.compareTo = function (that) {
            if (that instanceof LambdaFunc) {
                var order = this._bindings.compareTo(that._bindings);
                if (order === 0) {
                    order = this._template.compareTo(that._template);
                }
                return order;
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        LambdaFunc.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof LambdaFunc) {
                return this._bindings.equals(that._bindings) && this._template.equals(that._template);
            }
            return false;
        };
        LambdaFunc.prototype.hashCode = function () {
            if (LambdaFunc._hashSeed === void 0) {
                LambdaFunc._hashSeed = Murmur3.seed(LambdaFunc);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(LambdaFunc._hashSeed, this._bindings.hashCode()), this._template.hashCode()));
        };
        LambdaFunc.prototype.debug = function (output) {
            output.debug(this.bindings).write(46).write("lambda").write(40)
                .debug(this.template).write(41);
        };
        return LambdaFunc;
    }(Func));
    Item.LambdaFunc = LambdaFunc;

    var BridgeFunc = (function (_super) {
        __extends(BridgeFunc, _super);
        function BridgeFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BridgeFunc.prototype.typeOrder = function () {
            return 51;
        };
        BridgeFunc.prototype.compareTo = function (that) {
            if (that instanceof BridgeFunc) {
                return Objects.compare(this.__proto__.constructor.name, that.__proto__.constructor.name);
            }
            return Objects.compare(this.typeOrder(), that.typeOrder());
        };
        BridgeFunc.prototype.equals = function (that) {
            return this === that;
        };
        BridgeFunc.prototype.hashCode = function () {
            return Murmur3.seed(this.__proto__.constructor);
        };
        BridgeFunc.prototype.debug = function (output) {
            output = output.write(this.__proto__.constructor.name);
        };
        return BridgeFunc;
    }(Func));
    Item.BridgeFunc = BridgeFunc;

    var MathModule = (function () {
        function MathModule() {
        }
        MathModule.max = function () {
            if (!MathModule._max) {
                MathModule._max = new MaxFunc();
            }
            return MathModule._max;
        };
        MathModule.min = function () {
            if (!MathModule._min) {
                MathModule._min = new MinFunc();
            }
            return MathModule._min;
        };
        MathModule.abs = function () {
            if (!MathModule._abs) {
                MathModule._abs = new AbsFunc();
            }
            return MathModule._abs;
        };
        MathModule.ceil = function () {
            if (!MathModule._ceil) {
                MathModule._ceil = new CeilFunc();
            }
            return MathModule._ceil;
        };
        MathModule.floor = function () {
            if (!MathModule._floor) {
                MathModule._floor = new FloorFunc();
            }
            return MathModule._floor;
        };
        MathModule.round = function () {
            if (!MathModule._round) {
                MathModule._round = new RoundFunc();
            }
            return MathModule._round;
        };
        MathModule.sqrt = function () {
            if (!MathModule._sqrt) {
                MathModule._sqrt = new SqrtFunc();
            }
            return MathModule._sqrt;
        };
        MathModule.pow = function () {
            if (!MathModule._pow) {
                MathModule._pow = new PowFunc();
            }
            return MathModule._pow;
        };
        MathModule.rate = function () {
            if (!MathModule._rate) {
                MathModule._rate = new RateFunc();
            }
            return MathModule._rate;
        };
        MathModule.random = function () {
            if (!MathModule._random) {
                MathModule._random = new RandomFunc();
            }
            return MathModule._random;
        };
        MathModule.scope = function () {
            if (!MathModule._scope) {
                MathModule._scope = Item.Record.create(10)
                    .slot("max", MathModule.max())
                    .slot("min", MathModule.min())
                    .slot("abs", MathModule.abs())
                    .slot("ceil", MathModule.ceil())
                    .slot("floor", MathModule.floor())
                    .slot("round", MathModule.round())
                    .slot("pow", MathModule.pow())
                    .slot("sqrt", MathModule.sqrt())
                    .slot("rate", MathModule.rate())
                    .slot("random", MathModule.random())
                    .commit();
            }
            return MathModule._scope;
        };
        return MathModule;
    }());
    Item.MathModule = MathModule;
    var MaxFunc = (function (_super) {
        __extends(MaxFunc, _super);
        function MaxFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MaxFunc.prototype.invoke = function (args, interpreter, operator) {
            interpreter = Interpreter.fromAny(interpreter);
            var x;
            var y;
            if (args.length >= 2) {
                x = args.getItem(0).evaluate(interpreter);
                y = args.getItem(1).evaluate(interpreter);
            }
            else {
                x = args.evaluate(interpreter);
            }
            if (y !== void 0) {
                return x.max(y);
            }
            else if (operator) {
                y = operator.state();
                var max = y !== void 0 ? x.max(y) : x;
                operator.setState(max);
                return max;
            }
            return Item.absent();
        };
        MaxFunc.prototype.expand = function (args, interpreter, operator) {
            if (args.length === 1) {
                args = args.evaluate(interpreter).toValue();
                return this.invoke(args, interpreter, operator);
            }
            return void 0;
        };
        return MaxFunc;
    }(BridgeFunc));
    var MinFunc = (function (_super) {
        __extends(MinFunc, _super);
        function MinFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MinFunc.prototype.invoke = function (args, interpreter, operator) {
            interpreter = Interpreter.fromAny(interpreter);
            var x;
            var y;
            if (args.length >= 2) {
                x = args.getItem(0).evaluate(interpreter);
                y = args.getItem(1).evaluate(interpreter);
            }
            else {
                x = args.evaluate(interpreter);
            }
            if (y !== void 0) {
                return x.min(y);
            }
            else if (operator) {
                y = operator.state();
                var min = y !== void 0 ? x.min(y) : x;
                operator.setState(min);
                return min;
            }
            return Item.absent();
        };
        MinFunc.prototype.expand = function (args, interpreter, operator) {
            if (args.length === 1) {
                args = args.evaluate(interpreter).toValue();
                return this.invoke(args, interpreter, operator);
            }
            return void 0;
        };
        return MinFunc;
    }(BridgeFunc));
    var AbsFunc = (function (_super) {
        __extends(AbsFunc, _super);
        function AbsFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbsFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            if (args instanceof Item.Num) {
                return args.abs();
            }
            return Item.absent();
        };
        return AbsFunc;
    }(BridgeFunc));
    var CeilFunc = (function (_super) {
        __extends(CeilFunc, _super);
        function CeilFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CeilFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            if (args instanceof Item.Num) {
                return args.ceil();
            }
            return Item.absent();
        };
        return CeilFunc;
    }(BridgeFunc));
    var FloorFunc = (function (_super) {
        __extends(FloorFunc, _super);
        function FloorFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FloorFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            if (args instanceof Item.Num) {
                return args.floor();
            }
            return Item.absent();
        };
        return FloorFunc;
    }(BridgeFunc));
    var RoundFunc = (function (_super) {
        __extends(RoundFunc, _super);
        function RoundFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RoundFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            if (args instanceof Item.Num) {
                return args.round();
            }
            return Item.absent();
        };
        return RoundFunc;
    }(BridgeFunc));
    var SqrtFunc = (function (_super) {
        __extends(SqrtFunc, _super);
        function SqrtFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SqrtFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            if (args instanceof Item.Num) {
                return args.sqrt();
            }
            return Item.absent();
        };
        return SqrtFunc;
    }(BridgeFunc));
    var PowFunc = (function (_super) {
        __extends(PowFunc, _super);
        function PowFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PowFunc.prototype.invoke = function (args, interpreter, operator) {
            interpreter = Interpreter.fromAny(interpreter);
            var x = args.getItem(0).evaluate(interpreter);
            var y = args.getItem(1).evaluate(interpreter);
            if (x instanceof Item.Num && y instanceof Item.Num) {
                return x.pow(y);
            }
            return Item.absent();
        };
        return PowFunc;
    }(BridgeFunc));
    var RateFunc = (function (_super) {
        __extends(RateFunc, _super);
        function RateFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RateFunc.prototype.invoke = function (args, interpreter, operator) {
            interpreter = Interpreter.fromAny(interpreter);
            var value;
            var period;
            if (args.length >= 2) {
                value = args.getItem(0).evaluate(interpreter).numberValue(NaN);
                period = args.getItem(1).evaluate(interpreter).numberValue(1000);
            }
            else {
                value = args.evaluate(interpreter).numberValue(NaN);
                period = 1000;
            }
            if (isFinite(value) && operator) {
                var state = operator.state();
                if (state === void 0) {
                    state = { v0: value, t0: Date.now(), dv: 0, dt: 0 };
                    operator.setState(state);
                }
                else {
                    var t1 = Date.now();
                    var dt = t1 - state.t0;
                    if (dt > period && t1 > state.t0 || dt > 2 * period) {
                        var dv = value - state.v0;
                        state.v0 = value;
                        state.t0 = t1;
                        state.dv = dv;
                        state.dt = dt;
                    }
                    operator.setState(state);
                    if (state.dt !== 0) {
                        var rate = period * state.dv / state.dt;
                        return Item.Num.from(rate);
                    }
                }
            }
            return Item.absent();
        };
        RateFunc.prototype.expand = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            return this.invoke(args, interpreter, operator);
        };
        return RateFunc;
    }(BridgeFunc));
    var RandomFunc = (function (_super) {
        __extends(RandomFunc, _super);
        function RandomFunc() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RandomFunc.prototype.invoke = function (args, interpreter, operator) {
            args = args.evaluate(interpreter).toValue();
            var lower = args.length >= 1 ? args.getItem(0).numberValue(0.0) : 0.0;
            var upper = args.length >= 2 ? args.getItem(1).numberValue(lower + 1.0) : lower + 1.0;
            var value = lower + Math.random() * (upper - lower);
            return Item.Num.from(value);
        };
        return RandomFunc;
    }(BridgeFunc));

    var TagForm = (function (_super) {
        __extends(TagForm, _super);
        function TagForm(tag, form) {
            var _this = _super.call(this) || this;
            _this._tag = tag;
            _this._form = form;
            return _this;
        }
        TagForm.prototype.tag = function (tag) {
            if (arguments.length === 0) {
                return this._tag;
            }
            else if (tag !== void 0) {
                return new TagForm(tag, this._form);
            }
            else {
                return this._form;
            }
        };
        TagForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._form.unit();
            }
            else {
                return new TagForm(this._tag, this._form.unit(unit));
            }
        };
        TagForm.prototype.mold = function (object, item) {
            item = this._form.mold(object, item);
            if (!item.header(this._tag).isDefined()) {
                item = item.prepended(Attr.of(this._tag));
            }
            return item;
        };
        TagForm.prototype.cast = function (item, object) {
            if (item.header(this._tag).isDefined()) {
                return this._form.cast(item, object);
            }
            else if (item.keyEquals(this._tag)) {
                return this._form.cast(item.toValue(), object);
            }
            return void 0;
        };
        return TagForm;
    }(Form));
    Form.TagForm = TagForm;

    var UnitForm = (function (_super) {
        __extends(UnitForm, _super);
        function UnitForm(unit, form) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            _this._form = form;
            return _this;
        }
        UnitForm.prototype.tag = function (tag) {
            if (arguments.length === 0) {
                return this._form.tag();
            }
            else {
                return new UnitForm(this._unit, this._form.tag(tag));
            }
        };
        UnitForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._form.unit();
            }
            else if (unit !== void 0) {
                return new UnitForm(unit, this._form);
            }
            else {
                return this._form;
            }
        };
        UnitForm.prototype.mold = function (object, item) {
            return this._form.mold.apply(this._form, arguments);
        };
        UnitForm.prototype.cast = function (item, object) {
            return this._form.cast.apply(this._form, arguments);
        };
        return UnitForm;
    }(Form));
    Form.UnitForm = UnitForm;

    var StringForm = (function (_super) {
        __extends(StringForm, _super);
        function StringForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        StringForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new StringForm(unit);
            }
        };
        StringForm.prototype.mold = function (object, item) {
            if (item === void 0) {
                return Text.from(object);
            }
            else {
                return item.concat(Text.from(object));
            }
        };
        StringForm.prototype.cast = function (item, object) {
            var value = item.target();
            try {
                return value.stringValue();
            }
            catch (error) {
                return void 0;
            }
        };
        return StringForm;
    }(Form));
    Form.StringForm = StringForm;

    var NumberForm = (function (_super) {
        __extends(NumberForm, _super);
        function NumberForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        NumberForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new NumberForm(unit);
            }
        };
        NumberForm.prototype.mold = function (object, item) {
            if (item === void 0) {
                return Num.from(object);
            }
            else {
                return item.concat(Num.from(object));
            }
        };
        NumberForm.prototype.cast = function (item, object) {
            var value = item.target();
            try {
                return value.numberValue();
            }
            catch (error) {
                return void 0;
            }
        };
        return NumberForm;
    }(Form));
    Form.NumberForm = NumberForm;

    var BooleanForm = (function (_super) {
        __extends(BooleanForm, _super);
        function BooleanForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        BooleanForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new BooleanForm(unit);
            }
        };
        BooleanForm.prototype.mold = function (object, item) {
            if (item === void 0) {
                return Bool.from(object);
            }
            else {
                return item.concat(Bool.from(object));
            }
        };
        BooleanForm.prototype.cast = function (item, object) {
            var value = item.target();
            try {
                return value.booleanValue();
            }
            catch (error) {
                return void 0;
            }
        };
        return BooleanForm;
    }(Form));
    Form.BooleanForm = BooleanForm;

    var AnyForm = (function (_super) {
        __extends(AnyForm, _super);
        function AnyForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        AnyForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new AnyForm(unit);
            }
        };
        AnyForm.prototype.mold = function (object, item) {
            object = Item.fromAny(object);
            if (item !== void 0) {
                object = item.concat(object);
            }
            return object;
        };
        AnyForm.prototype.cast = function (item, object) {
            return item.toAny();
        };
        return AnyForm;
    }(Form));
    Form.AnyForm = AnyForm;

    var ItemForm = (function (_super) {
        __extends(ItemForm, _super);
        function ItemForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit ? unit.commit() : unit;
            return _this;
        }
        ItemForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new ItemForm(unit);
            }
        };
        ItemForm.prototype.mold = function (object, item) {
            object = Item.fromAny(object);
            if (item !== void 0) {
                object = item.concat(object);
            }
            return object;
        };
        ItemForm.prototype.cast = function (item, object) {
            return item;
        };
        return ItemForm;
    }(Form));
    Form.ItemForm = ItemForm;

    var ValueForm = (function (_super) {
        __extends(ValueForm, _super);
        function ValueForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit ? unit.commit() : unit;
            return _this;
        }
        ValueForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new ValueForm(unit);
            }
        };
        ValueForm.prototype.mold = function (object, item) {
            object = Value.fromAny(object);
            if (item !== void 0) {
                object = item.concat(object);
            }
            return object;
        };
        ValueForm.prototype.cast = function (item, object) {
            return item.toValue();
        };
        return ValueForm;
    }(Form));
    Form.ValueForm = ValueForm;

    var ValueCursor = (function (_super) {
        __extends(ValueCursor, _super);
        function ValueCursor(cursor, form) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            _this._form = form;
            return _this;
        }
        ValueCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        ValueCursor.prototype.head = function () {
            var value = this._cursor.head();
            return value.coerce(this._form);
        };
        ValueCursor.prototype.step = function () {
            this._cursor.step();
        };
        ValueCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        ValueCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        ValueCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        ValueCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value.coerce(this._form), done: done };
        };
        ValueCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        ValueCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        ValueCursor.prototype.previous = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value.coerce(this._form), done: done };
        };
        ValueCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return ValueCursor;
    }(Cursor));

    var ValueEntryCursor = (function (_super) {
        __extends(ValueEntryCursor, _super);
        function ValueEntryCursor(cursor, keyForm, valueForm) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            _this._keyForm = keyForm;
            _this._valueForm = valueForm;
            return _this;
        }
        ValueEntryCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        ValueEntryCursor.prototype.head = function () {
            var pair = this._cursor.head();
            return [pair[0].coerce(this._keyForm), pair[1].coerce(this._valueForm)];
        };
        ValueEntryCursor.prototype.step = function () {
            this._cursor.step();
        };
        ValueEntryCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        ValueEntryCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        ValueEntryCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        ValueEntryCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && [value[0].coerce(this._keyForm), value[1].coerce(this._valueForm)], done: done };
        };
        ValueEntryCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        ValueEntryCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        ValueEntryCursor.prototype.previous = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && [value[0].coerce(this._keyForm), value[1].coerce(this._valueForm)], done: done };
        };
        ValueEntryCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return ValueEntryCursor;
    }(Cursor));

    var Inlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var inlet = object;
                return typeof inlet.input === "function"
                    && typeof inlet.bindInput === "function"
                    && typeof inlet.unbindInput === "function";
            }
            return false;
        },
    };

    var Outlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var outlet = object;
                return typeof outlet.outputIterator === "function"
                    && typeof outlet.bindOutput === "function"
                    && typeof outlet.unbindOutput === "function";
            }
            return false;
        },
        MemoizeValueCombinator: void 0,
        MapValueCombinator: void 0,
        WatchValueCombinator: void 0,
    };

    (function (KeyEffect) {
        KeyEffect[KeyEffect["Update"] = 0] = "Update";
        KeyEffect[KeyEffect["Remove"] = 1] = "Remove";
    })(exports.KeyEffect || (exports.KeyEffect = {}));

    var MapInlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var inlet = object;
                return Inlet.is(inlet)
                    && typeof inlet.invalidateOutputKey === "function"
                    && typeof inlet.reconcileOutputKey === "function";
            }
            return false;
        },
    };

    var MapOutlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var outlet = object;
                return Outlet.is(outlet)
                    && typeof outlet.keyIterator === "function"
                    && typeof outlet.outlet === "function";
            }
            return false;
        },
        MemoizeMapCombinator: void 0,
        FilterFieldsCombinator: void 0,
        MapFieldValuesCombinator: void 0,
        ReduceFieldsCombinator: void 0,
        WatchFieldsCombinator: void 0,
    };

    var StreamletException = (function (_super) {
        __extends(StreamletException, _super);
        function StreamletException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = StreamletException.prototype;
            return _this;
        }
        return StreamletException;
    }(Error));

    var StreamletScope = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var scope = object;
                return typeof scope.streamletScope === "function"
                    && typeof scope.streamletContext === "function"
                    && typeof scope.outlet === "function";
            }
            return false;
        },
    };

    var Streamlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var streamlet = object;
                return typeof streamlet.streamletScope === "function"
                    && typeof streamlet.setStreamletScope === "function"
                    && typeof streamlet.streamletContext === "function"
                    && typeof streamlet.setStreamletContext === "function";
            }
            return false;
        },
    };

    var AbstractInlet = (function () {
        function AbstractInlet() {
            this._input = null;
            this._version = -1;
        }
        AbstractInlet.prototype.input = function () {
            return this._input;
        };
        AbstractInlet.prototype.bindInput = function (input) {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractInlet.prototype.unbindInput = function () {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractInlet.prototype.disconnectInputs = function () {
            var input = this._input;
            if (input !== null) {
                input.unbindOutput(this);
                this._input = null;
                input.disconnectInputs();
            }
        };
        AbstractInlet.prototype.disconnectOutputs = function () {
        };
        AbstractInlet.prototype.invalidateOutput = function () {
            if (this._version >= 0) {
                this.willInvalidateOutput();
                this._version = -1;
                this.onInvalidateOutput();
                this.didInvalidateOutput();
            }
        };
        AbstractInlet.prototype.reconcileOutput = function (version) {
            if (this._version < 0) {
                this.willReconcileOutput(version);
                this._version = version;
                if (this._input !== null) {
                    this._input.reconcileInput(version);
                }
                this.onReconcileOutput(version);
                this.didReconcileOutput(version);
            }
        };
        AbstractInlet.prototype.willInvalidateOutput = function () {
        };
        AbstractInlet.prototype.onInvalidateOutput = function () {
        };
        AbstractInlet.prototype.didInvalidateOutput = function () {
        };
        AbstractInlet.prototype.willReconcileOutput = function (version) {
        };
        AbstractInlet.prototype.onReconcileOutput = function (version) {
        };
        AbstractInlet.prototype.didReconcileOutput = function (version) {
        };
        return AbstractInlet;
    }());

    var AbstractOutlet = (function () {
        function AbstractOutlet() {
            this._outputs = null;
            this._version = -1;
        }
        AbstractOutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractOutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractOutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            for (var i = 0, n = oldOutputs !== null ? oldOutputs.length : 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractOutlet.prototype.unbindOutputs = function () {
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractOutlet.prototype.disconnectOutputs = function () {
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                    output.disconnectOutputs();
                }
            }
        };
        AbstractOutlet.prototype.disconnectInputs = function () {
        };
        AbstractOutlet.prototype.invalidateInput = function () {
            if (this._version >= 0) {
                this.willInvalidateInput();
                this._version = -1;
                this.onInvalidateInput();
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this.didInvalidateInput();
            }
        };
        AbstractOutlet.prototype.reconcileInput = function (version) {
            if (this._version < 0) {
                this.willReconcileInput(version);
                this._version = version;
                this.onReconcileInput(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcileInput(version);
            }
        };
        AbstractOutlet.prototype.willInvalidateInput = function () {
        };
        AbstractOutlet.prototype.onInvalidateInput = function () {
        };
        AbstractOutlet.prototype.didInvalidateInput = function () {
        };
        AbstractOutlet.prototype.willReconcileInput = function (version) {
        };
        AbstractOutlet.prototype.onReconcileInput = function (version) {
        };
        AbstractOutlet.prototype.didReconcileInput = function (version) {
        };
        AbstractOutlet.prototype.memoize = function () {
            var combinator = new Outlet.MemoizeValueCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractOutlet.prototype.map = function (func) {
            var combinator = new Outlet.MapValueCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractOutlet.prototype.watch = function (func) {
            var combinator = new Outlet.WatchValueCombinator(func);
            combinator.bindInput(this);
            return this;
        };
        return AbstractOutlet;
    }());

    var AbstractInoutlet = (function () {
        function AbstractInoutlet() {
            this._input = null;
            this._outputs = null;
            this._version = -1;
        }
        AbstractInoutlet.prototype.input = function () {
            return this._input;
        };
        AbstractInoutlet.prototype.bindInput = function (input) {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractInoutlet.prototype.unbindInput = function () {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractInoutlet.prototype.disconnectInputs = function () {
            if (this._outputs === null) {
                var input = this._input;
                if (input !== null) {
                    input.unbindOutput(this);
                    this._input = null;
                    input.disconnectInputs();
                }
            }
        };
        AbstractInoutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractInoutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractInoutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractInoutlet.prototype.unbindOutputs = function () {
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractInoutlet.prototype.disconnectOutputs = function () {
            if (this._input === null) {
                var outputs = this._outputs;
                if (outputs !== null) {
                    this._outputs = null;
                    for (var i = 0, n = outputs.length; i < n; i += 1) {
                        var output = outputs[i];
                        output.unbindInput();
                        output.disconnectOutputs();
                    }
                }
            }
        };
        AbstractInoutlet.prototype.invalidateOutput = function () {
            this.invalidate();
        };
        AbstractInoutlet.prototype.invalidateInput = function () {
            this.invalidate();
        };
        AbstractInoutlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this.didInvalidate();
            }
        };
        AbstractInoutlet.prototype.reconcileOutput = function (version) {
            this.reconcile(version);
        };
        AbstractInoutlet.prototype.reconcileInput = function (version) {
            this.reconcile(version);
        };
        AbstractInoutlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._version = version;
                if (this._input !== null) {
                    this._input.reconcileInput(version);
                }
                this.onReconcile(version);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcile(version);
            }
        };
        AbstractInoutlet.prototype.willInvalidate = function () {
        };
        AbstractInoutlet.prototype.onInvalidate = function () {
        };
        AbstractInoutlet.prototype.didInvalidate = function () {
        };
        AbstractInoutlet.prototype.willReconcile = function (version) {
        };
        AbstractInoutlet.prototype.onReconcile = function (version) {
        };
        AbstractInoutlet.prototype.didReconcile = function (version) {
        };
        AbstractInoutlet.prototype.memoize = function () {
            var combinator = new Outlet.MemoizeValueCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractInoutlet.prototype.map = function (func) {
            var combinator = new Outlet.MapValueCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractInoutlet.prototype.watch = function (func) {
            var combinator = new Outlet.WatchValueCombinator(func);
            combinator.bindInput(this);
            return this;
        };
        return AbstractInoutlet;
    }());

    var KeyOutlet = (function (_super) {
        __extends(KeyOutlet, _super);
        function KeyOutlet(input, key) {
            var _this = _super.call(this) || this;
            _this._input = input;
            _this._key = key;
            return _this;
        }
        KeyOutlet.prototype.input = function () {
            return this._input;
        };
        KeyOutlet.prototype.key = function () {
            return this._key;
        };
        KeyOutlet.prototype.get = function () {
            return this._input.get(this._key);
        };
        return KeyOutlet;
    }(AbstractOutlet));

    var AbstractMapInlet = (function () {
        function AbstractMapInlet() {
            this._input = null;
            this._effects = new BTree();
            this._version = -1;
        }
        AbstractMapInlet.prototype.input = function () {
            return this._input;
        };
        AbstractMapInlet.prototype.bindInput = function (input) {
            if (!MapOutlet.is(input)) {
                throw new TypeError("" + input);
            }
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractMapInlet.prototype.unbindInput = function () {
            if (this._input != null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractMapInlet.prototype.disconnectInputs = function () {
            var input = this._input;
            if (input !== null) {
                input.unbindOutput(this);
                this._input = null;
                input.disconnectInputs();
            }
        };
        AbstractMapInlet.prototype.disconnectOutputs = function () {
        };
        AbstractMapInlet.prototype.invalidateOutputKey = function (key, effect) {
            var oldEffects = this._effects;
            if (oldEffects.get(key) !== effect) {
                this.willInvalidateOutputKey(key, effect);
                this._effects = oldEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateOutputKey(key, effect);
                this.didInvalidateOutputKey(key, effect);
            }
        };
        AbstractMapInlet.prototype.invalidateOutput = function () {
            if (this._version >= 0) {
                this.willInvalidateOutput();
                this._version = -1;
                this.onInvalidateOutput();
                this.didInvalidateOutput();
            }
        };
        AbstractMapInlet.prototype.reconcileOutputKey = function (key, version) {
            if (this._version < 0) {
                var oldEffects = this._effects;
                var effect = oldEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileOutputKey(key, effect, version);
                    this._effects = oldEffects.removed(key);
                    if (this._input !== null) {
                        this._input.reconcileInputKey(key, version);
                    }
                    this.onReconcileOutputKey(key, effect, version);
                    this.didReconcileOutputKey(key, effect, version);
                }
            }
        };
        AbstractMapInlet.prototype.reconcileOutput = function (version) {
            if (this._version < 0) {
                this.willReconcileOutput(version);
                this._effects.forEach(function (key) {
                    this.reconcileOutputKey(key, version);
                }, this);
                this._version = version;
                this.onReconcileOutput(version);
                this.didReconcileOutput(version);
            }
        };
        AbstractMapInlet.prototype.willInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInlet.prototype.onInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInlet.prototype.didInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInlet.prototype.willInvalidateOutput = function () {
        };
        AbstractMapInlet.prototype.onInvalidateOutput = function () {
        };
        AbstractMapInlet.prototype.didInvalidateOutput = function () {
        };
        AbstractMapInlet.prototype.willReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInlet.prototype.onReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInlet.prototype.didReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInlet.prototype.willReconcileOutput = function (version) {
        };
        AbstractMapInlet.prototype.onReconcileOutput = function (version) {
        };
        AbstractMapInlet.prototype.didReconcileOutput = function (version) {
        };
        return AbstractMapInlet;
    }());

    var AbstractMapOutlet = (function () {
        function AbstractMapOutlet() {
            this._effects = new BTree();
            this._outlets = new BTree();
            this._outputs = null;
            this._version = -1;
        }
        AbstractMapOutlet.prototype.outlet = function (key) {
            var outlet = this._outlets.get(key);
            if (outlet === void 0) {
                outlet = new KeyOutlet(this, key);
                this._outlets = this._outlets.updated(key, outlet);
            }
            return outlet;
        };
        AbstractMapOutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractMapOutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractMapOutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractMapOutlet.prototype.unbindOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.unbindOutputs();
                }, this);
            }
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractMapOutlet.prototype.disconnectOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.disconnectOutputs();
                }, this);
            }
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                    output.disconnectOutputs();
                }
            }
        };
        AbstractMapOutlet.prototype.disconnectInputs = function () {
        };
        AbstractMapOutlet.prototype.invalidateInputKey = function (key, effect) {
            var oldEffects = this._effects;
            if (oldEffects.get(key) !== effect) {
                this.willInvalidateInputKey(key, effect);
                this._effects = oldEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateInputKey(key, effect);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    var output = this._outputs[i];
                    if (MapInlet.is(output)) {
                        output.invalidateOutputKey(key, effect);
                    }
                    else {
                        output.invalidateOutput();
                    }
                }
                var outlet = this._outlets.get(key);
                if (outlet !== void 0) {
                    outlet.invalidateInput();
                }
                this.didInvalidateInputKey(key, effect);
            }
        };
        AbstractMapOutlet.prototype.invalidateInput = function () {
            if (this._version >= 0) {
                this.willInvalidateInput();
                this._version = -1;
                this.onInvalidateInput();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this._outlets.forEach(function (key, outlet) {
                    outlet.invalidateInput();
                }, this);
                this.didInvalidateInput();
            }
        };
        AbstractMapOutlet.prototype.reconcileInputKey = function (key, version) {
            if (this._version < 0) {
                var oldEffects = this._effects;
                var effect = oldEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileInputKey(key, effect, version);
                    this._effects = oldEffects.removed(key);
                    this.onReconcileInputKey(key, effect, version);
                    for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                        var output = this._outputs[i];
                        if (MapInlet.is(output)) {
                            output.reconcileOutputKey(key, version);
                        }
                    }
                    var outlet = this._outlets.get(key);
                    if (outlet !== void 0) {
                        outlet.reconcileInput(version);
                    }
                    this.didReconcileInputKey(key, effect, version);
                }
            }
        };
        AbstractMapOutlet.prototype.reconcileInput = function (version) {
            if (this._version < 0) {
                this.willReconcileInput(version);
                this._effects.forEach(function (key) {
                    this.reconcileInputKey(key, version);
                }, this);
                this._version = version;
                this.onReconcileInput(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcileInput(version);
            }
        };
        AbstractMapOutlet.prototype.willInvalidateInputKey = function (key, effect) {
        };
        AbstractMapOutlet.prototype.onInvalidateInputKey = function (key, effect) {
        };
        AbstractMapOutlet.prototype.didInvalidateInputKey = function (key, effect) {
        };
        AbstractMapOutlet.prototype.willInvalidateInput = function () {
        };
        AbstractMapOutlet.prototype.onInvalidateInput = function () {
        };
        AbstractMapOutlet.prototype.didInvalidateInput = function () {
        };
        AbstractMapOutlet.prototype.willReconcileInputKey = function (key, effect, version) {
        };
        AbstractMapOutlet.prototype.onReconcileInputKey = function (key, effect, version) {
        };
        AbstractMapOutlet.prototype.didReconcileInputKey = function (key, effect, version) {
        };
        AbstractMapOutlet.prototype.willReconcileInput = function (version) {
        };
        AbstractMapOutlet.prototype.onReconcileInput = function (version) {
        };
        AbstractMapOutlet.prototype.didReconcileInput = function (version) {
        };
        AbstractMapOutlet.prototype.memoize = function () {
            var combinator = new MapOutlet.MemoizeMapCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapOutlet.prototype.filter = function (func) {
            var combinator = new MapOutlet.FilterFieldsCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapOutlet.prototype.map = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.MapValueCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
            else {
                var combinator = new MapOutlet.MapFieldValuesCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
        };
        AbstractMapOutlet.prototype.reduce = function (identity, accumulator, combiner) {
            var combinator = new MapOutlet.ReduceFieldsCombinator(identity, accumulator, combiner);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapOutlet.prototype.watch = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.WatchValueCombinator(func);
                combinator.bindInput(this);
                return this;
            }
            else {
                var combinator = new MapOutlet.WatchFieldsCombinator(func);
                combinator.bindInput(this);
                return this;
            }
        };
        return AbstractMapOutlet;
    }());

    var AbstractMapInoutlet = (function () {
        function AbstractMapInoutlet() {
            this._input = null;
            this._effects = new BTree();
            this._outlets = new BTree();
            this._outputs = null;
            this._version = -1;
        }
        AbstractMapInoutlet.prototype.input = function () {
            return this._input;
        };
        AbstractMapInoutlet.prototype.bindInput = function (input) {
            if (!MapOutlet.is(input)) {
                throw new TypeError("" + input);
            }
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractMapInoutlet.prototype.unbindInput = function () {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractMapInoutlet.prototype.disconnectInputs = function () {
            if (this._outputs === null && this._outlets.isEmpty()) {
                var input = this._input;
                if (input !== null) {
                    input.unbindOutput(this);
                    this._input = null;
                    input.disconnectInputs();
                }
            }
        };
        AbstractMapInoutlet.prototype.outlet = function (key) {
            var outlet = this._outlets.get(key);
            if (outlet === void 0) {
                outlet = new KeyOutlet(this, key);
                this._outlets = this._outlets.updated(key, outlet);
            }
            return outlet;
        };
        AbstractMapInoutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractMapInoutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractMapInoutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractMapInoutlet.prototype.unbindOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.unbindOutputs();
                }, this);
            }
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractMapInoutlet.prototype.disconnectOutputs = function () {
            if (this._input === null) {
                var outlets = this._outlets;
                if (outlets.isEmpty()) {
                    this._outlets = new BTree();
                    outlets.forEach(function (key, keyOutlet) {
                        keyOutlet.disconnectOutputs();
                    }, this);
                }
                var outputs = this._outputs;
                if (outputs !== null) {
                    this._outputs = null;
                    for (var i = 0, n = outputs.length; i < n; i += 1) {
                        var output = outputs[i];
                        output.unbindInput();
                        output.disconnectOutputs();
                    }
                }
            }
        };
        AbstractMapInoutlet.prototype.invalidateOutputKey = function (key, effect) {
            this.invalidateKey(key, effect);
        };
        AbstractMapInoutlet.prototype.invalidateInputKey = function (key, effect) {
            this.invalidateKey(key, effect);
        };
        AbstractMapInoutlet.prototype.invalidateKey = function (key, effect) {
            var oldEffects = this._effects;
            if (oldEffects.get(key) !== effect) {
                this.willInvalidateKey(key, effect);
                this._effects = oldEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateKey(key, effect);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    var output = this._outputs[i];
                    if (MapInlet.is(output)) {
                        output.invalidateOutputKey(key, effect);
                    }
                    else {
                        output.invalidateOutput();
                    }
                }
                var outlet = this._outlets.get(key);
                if (outlet !== void 0) {
                    outlet.invalidateInput();
                }
                this.didInvalidateKey(key, effect);
            }
        };
        AbstractMapInoutlet.prototype.invalidateOutput = function () {
            this.invalidate();
        };
        AbstractMapInoutlet.prototype.invalidateInput = function () {
            this.invalidate();
        };
        AbstractMapInoutlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this._outlets.forEach(function (key, outlet) {
                    outlet.invalidateInput();
                }, this);
                this.didInvalidate();
            }
        };
        AbstractMapInoutlet.prototype.reconcileOutputKey = function (key, version) {
            this.reconcileKey(key, version);
        };
        AbstractMapInoutlet.prototype.reconcileInputKey = function (key, version) {
            this.reconcileKey(key, version);
        };
        AbstractMapInoutlet.prototype.reconcileKey = function (key, version) {
            if (this._version < 0) {
                var oldEffects = this._effects;
                var effect = oldEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileKey(key, effect, version);
                    this._effects = oldEffects.removed(key);
                    if (this._input !== null) {
                        this._input.reconcileInputKey(key, version);
                    }
                    this.onReconcileKey(key, effect, version);
                    for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                        var output = this._outputs[i];
                        if (MapInlet.is(output)) {
                            output.reconcileOutputKey(key, version);
                        }
                    }
                    var outlet = this._outlets.get(key);
                    if (outlet !== void 0) {
                        outlet.reconcileInput(version);
                    }
                    this.didReconcileKey(key, effect, version);
                }
            }
        };
        AbstractMapInoutlet.prototype.reconcileOutput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInoutlet.prototype.reconcileInput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInoutlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._effects.forEach(function (key) {
                    this.reconcileKey(key, version);
                }, this);
                this._version = version;
                this.onReconcile(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcile(version);
            }
        };
        AbstractMapInoutlet.prototype.willInvalidateKey = function (key, effect) {
        };
        AbstractMapInoutlet.prototype.onInvalidateKey = function (key, effect) {
        };
        AbstractMapInoutlet.prototype.didInvalidateKey = function (key, effect) {
        };
        AbstractMapInoutlet.prototype.willInvalidate = function () {
        };
        AbstractMapInoutlet.prototype.onInvalidate = function () {
        };
        AbstractMapInoutlet.prototype.didInvalidate = function () {
        };
        AbstractMapInoutlet.prototype.willReconcileKey = function (key, effect, version) {
        };
        AbstractMapInoutlet.prototype.onReconcileKey = function (key, effect, version) {
        };
        AbstractMapInoutlet.prototype.didReconcileKey = function (key, effect, version) {
        };
        AbstractMapInoutlet.prototype.willReconcile = function (version) {
        };
        AbstractMapInoutlet.prototype.onReconcile = function (version) {
        };
        AbstractMapInoutlet.prototype.didReconcile = function (version) {
        };
        AbstractMapInoutlet.prototype.memoize = function () {
            var combinator = new MapOutlet.MemoizeMapCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInoutlet.prototype.filter = function (func) {
            var combinator = new MapOutlet.FilterFieldsCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInoutlet.prototype.map = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.MapValueCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
            else {
                var combinator = new MapOutlet.MapFieldValuesCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
        };
        AbstractMapInoutlet.prototype.reduce = function (identity, accumulator, combiner) {
            var combinator = new MapOutlet.ReduceFieldsCombinator(identity, accumulator, combiner);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInoutlet.prototype.watch = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.WatchValueCombinator(func);
                combinator.bindInput(this);
                return this;
            }
            else {
                var combinator = new MapOutlet.WatchFieldsCombinator(func);
                combinator.bindInput(this);
                return this;
            }
        };
        return AbstractMapInoutlet;
    }());

    var AbstractMapInletOutlet = (function () {
        function AbstractMapInletOutlet() {
            this._input = null;
            this._effects = new BTree();
            this._outputs = null;
            this._version = -1;
        }
        AbstractMapInletOutlet.prototype.input = function () {
            return this._input;
        };
        AbstractMapInletOutlet.prototype.bindInput = function (input) {
            if (!MapOutlet.is(input)) {
                throw new TypeError("" + input);
            }
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractMapInletOutlet.prototype.unbindInput = function () {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractMapInletOutlet.prototype.disconnectInputs = function () {
            if (this._outputs === null) {
                var input = this._input;
                if (input !== null) {
                    input.unbindOutput(this);
                    this._input = null;
                    input.disconnectInputs();
                }
            }
        };
        AbstractMapInletOutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractMapInletOutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractMapInletOutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractMapInletOutlet.prototype.unbindOutputs = function () {
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractMapInletOutlet.prototype.disconnectOutputs = function () {
            if (this._input === null) {
                var outputs = this._outputs;
                if (outputs !== null) {
                    this._outputs = null;
                    for (var i = 0, n = outputs.length; i < n; i += 1) {
                        var output = outputs[i];
                        output.unbindInput();
                        output.disconnectOutputs();
                    }
                }
            }
        };
        AbstractMapInletOutlet.prototype.invalidateOutputKey = function (key, effect) {
            var oldEffects = this._effects;
            if (oldEffects.get(key) !== effect) {
                this.willInvalidateOutputKey(key, effect);
                this._effects = oldEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateOutputKey(key, effect);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    var output = this._outputs[i];
                    output.invalidateOutput();
                }
                this.didInvalidateOutputKey(key, effect);
            }
        };
        AbstractMapInletOutlet.prototype.invalidateOutput = function () {
            this.invalidate();
        };
        AbstractMapInletOutlet.prototype.invalidateInput = function () {
            this.invalidate();
        };
        AbstractMapInletOutlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this.didInvalidate();
            }
        };
        AbstractMapInletOutlet.prototype.reconcileOutputKey = function (key, version) {
            if (this._version < 0) {
                var oldEffects = this._effects;
                var effect = oldEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileOutputKey(key, effect, version);
                    this._effects = oldEffects.removed(key);
                    if (this._input !== null) {
                        this._input.reconcileInputKey(key, version);
                    }
                    this.onReconcileOutputKey(key, effect, version);
                    this.didReconcileOutputKey(key, effect, version);
                }
            }
        };
        AbstractMapInletOutlet.prototype.reconcileOutput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInletOutlet.prototype.reconcileInput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInletOutlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._effects.forEach(function (key) {
                    this.reconcileOutputKey(key, version);
                }, this);
                this._version = version;
                this.onReconcile(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcile(version);
            }
        };
        AbstractMapInletOutlet.prototype.willInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletOutlet.prototype.onInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletOutlet.prototype.didInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletOutlet.prototype.willInvalidate = function () {
        };
        AbstractMapInletOutlet.prototype.onInvalidate = function () {
        };
        AbstractMapInletOutlet.prototype.didInvalidate = function () {
        };
        AbstractMapInletOutlet.prototype.willReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletOutlet.prototype.onReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletOutlet.prototype.didReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletOutlet.prototype.willReconcile = function (version) {
        };
        AbstractMapInletOutlet.prototype.onReconcile = function (version) {
        };
        AbstractMapInletOutlet.prototype.didReconcile = function (version) {
        };
        AbstractMapInletOutlet.prototype.memoize = function () {
            var combinator = new Outlet.MemoizeValueCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInletOutlet.prototype.map = function (func) {
            var combinator = new Outlet.MapValueCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInletOutlet.prototype.watch = function (func) {
            var combinator = new Outlet.WatchValueCombinator(func);
            combinator.bindInput(this);
            return this;
        };
        return AbstractMapInletOutlet;
    }());

    var AbstractMapInletMapOutlet = (function () {
        function AbstractMapInletMapOutlet() {
            this._input = null;
            this._outputEffects = new BTree();
            this._inputEffects = new BTree();
            this._outlets = new BTree();
            this._outputs = null;
            this._version = -1;
        }
        AbstractMapInletMapOutlet.prototype.input = function () {
            return this._input;
        };
        AbstractMapInletMapOutlet.prototype.bindInput = function (input) {
            if (!MapOutlet.is(input)) {
                throw new TypeError("" + input);
            }
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = input;
            if (this._input !== null) {
                this._input.bindOutput(this);
            }
        };
        AbstractMapInletMapOutlet.prototype.unbindInput = function () {
            if (this._input !== null) {
                this._input.unbindOutput(this);
            }
            this._input = null;
        };
        AbstractMapInletMapOutlet.prototype.disconnectInputs = function () {
            if (this._outputs === null && this._outlets.isEmpty()) {
                var input = this._input;
                if (input !== null) {
                    input.unbindOutput(this);
                    this._input = null;
                    input.disconnectInputs();
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.outlet = function (key) {
            var outlet = this._outlets.get(key);
            if (outlet === void 0) {
                outlet = new KeyOutlet(this, key);
                this._outlets = this._outlets.updated(key, outlet);
            }
            return outlet;
        };
        AbstractMapInletMapOutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractMapInletMapOutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractMapInletMapOutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.unbindOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.unbindOutputs();
                }, this);
            }
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.disconnectOutputs = function () {
            if (this._input === null) {
                var outlets = this._outlets;
                if (outlets.isEmpty()) {
                    this._outlets = new BTree();
                    outlets.forEach(function (key, keyOutlet) {
                        keyOutlet.disconnectOutputs();
                    }, this);
                }
                var outputs = this._outputs;
                if (outputs !== null) {
                    this._outputs = null;
                    for (var i = 0, n = outputs.length; i < n; i += 1) {
                        var output = outputs[i];
                        output.unbindInput();
                        output.disconnectOutputs();
                    }
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.invalidateOutputKey = function (key, effect) {
            var oldOutputEffects = this._outputEffects;
            if (oldOutputEffects.get(key) !== effect) {
                this.willInvalidateOutputKey(key, effect);
                this._outputEffects = oldOutputEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateOutputKey(key, effect);
                this.didInvalidateOutputKey(key, effect);
            }
        };
        AbstractMapInletMapOutlet.prototype.invalidateInputKey = function (key, effect) {
            var oldInputEffects = this._inputEffects;
            if (oldInputEffects.get(key) !== effect) {
                this.willInvalidateInputKey(key, effect);
                this._inputEffects = oldInputEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateInputKey(key, effect);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    var output = this._outputs[i];
                    if (MapInlet.is(output)) {
                        output.invalidateOutputKey(key, effect);
                    }
                    else {
                        output.invalidateOutput();
                    }
                }
                var outlet = this._outlets.get(key);
                if (outlet !== void 0) {
                    outlet.invalidateInput();
                }
                this.didInvalidateInputKey(key, effect);
            }
        };
        AbstractMapInletMapOutlet.prototype.invalidateOutput = function () {
            this.invalidate();
        };
        AbstractMapInletMapOutlet.prototype.invalidateInput = function () {
            this.invalidate();
        };
        AbstractMapInletMapOutlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this._outlets.forEach(function (key, outlet) {
                    outlet.invalidateInput();
                }, this);
                this.didInvalidate();
            }
        };
        AbstractMapInletMapOutlet.prototype.reconcileOutputKey = function (key, version) {
            if (this._version < 0) {
                var oldOutputEffects = this._outputEffects;
                var effect = oldOutputEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileOutputKey(key, effect, version);
                    this._outputEffects = oldOutputEffects.removed(key);
                    if (this._input !== null) {
                        this._input.reconcileInputKey(key, version);
                    }
                    this.onReconcileOutputKey(key, effect, version);
                    this.didReconcileOutputKey(key, effect, version);
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.reconcileInputKey = function (key, version) {
            if (this._version < 0) {
                var oldInputEffects = this._inputEffects;
                var oldEffect = oldInputEffects.get(key);
                if (oldEffect !== void 0) {
                    var newEffect = this.willReconcileInputKey(key, oldEffect, version);
                    if (oldEffect !== newEffect) {
                        this.invalidateInputKey(key, newEffect);
                    }
                    this._inputEffects = oldInputEffects.removed(key);
                    this.onReconcileInputKey(key, newEffect, version);
                    for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                        var output = this._outputs[i];
                        if (MapInlet.is(output)) {
                            output.reconcileOutputKey(key, version);
                        }
                    }
                    var outlet = this._outlets.get(key);
                    if (outlet !== void 0) {
                        outlet.reconcileInput(version);
                    }
                    this.didReconcileInputKey(key, newEffect, version);
                }
            }
        };
        AbstractMapInletMapOutlet.prototype.reconcileOutput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInletMapOutlet.prototype.reconcileInput = function (version) {
            this.reconcile(version);
        };
        AbstractMapInletMapOutlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._outputEffects.forEach(function (key) {
                    this.reconcileOutputKey(key, version);
                }, this);
                this._inputEffects.forEach(function (key) {
                    this.reconcileInputKey(key, version);
                }, this);
                this._version = version;
                this.onReconcile(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.didReconcile(version);
            }
        };
        AbstractMapInletMapOutlet.prototype.willInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.onInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.didInvalidateOutputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.willInvalidateInputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.onInvalidateInputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.didInvalidateInputKey = function (key, effect) {
        };
        AbstractMapInletMapOutlet.prototype.willInvalidate = function () {
        };
        AbstractMapInletMapOutlet.prototype.onInvalidate = function () {
        };
        AbstractMapInletMapOutlet.prototype.didInvalidate = function () {
        };
        AbstractMapInletMapOutlet.prototype.willReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletMapOutlet.prototype.onReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletMapOutlet.prototype.didReconcileOutputKey = function (key, effect, version) {
        };
        AbstractMapInletMapOutlet.prototype.willReconcileInputKey = function (key, effect, version) {
            return effect;
        };
        AbstractMapInletMapOutlet.prototype.onReconcileInputKey = function (key, effect, version) {
        };
        AbstractMapInletMapOutlet.prototype.didReconcileInputKey = function (key, effect, version) {
        };
        AbstractMapInletMapOutlet.prototype.willReconcile = function (version) {
        };
        AbstractMapInletMapOutlet.prototype.onReconcile = function (version) {
        };
        AbstractMapInletMapOutlet.prototype.didReconcile = function (version) {
        };
        AbstractMapInletMapOutlet.prototype.memoize = function () {
            var combinator = new MapOutlet.MemoizeMapCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInletMapOutlet.prototype.filter = function (func) {
            var combinator = new MapOutlet.FilterFieldsCombinator(func);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInletMapOutlet.prototype.map = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.MapValueCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
            else {
                var combinator = new MapOutlet.MapFieldValuesCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
        };
        AbstractMapInletMapOutlet.prototype.reduce = function (identity, accumulator, combiner) {
            var combinator = new MapOutlet.ReduceFieldsCombinator(identity, accumulator, combiner);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractMapInletMapOutlet.prototype.watch = function (func) {
            if (func.length === 1) {
                var combinator = new Outlet.WatchValueCombinator(func);
                combinator.bindInput(this);
                return this;
            }
            else {
                var combinator = new MapOutlet.WatchFieldsCombinator(func);
                combinator.bindInput(this);
                return this;
            }
        };
        return AbstractMapInletMapOutlet;
    }());

    var OutletInlet = (function (_super) {
        __extends(OutletInlet, _super);
        function OutletInlet(outlet) {
            var _this = _super.call(this) || this;
            _this._outlet = outlet;
            return _this;
        }
        OutletInlet.prototype.outlet = function () {
            return this._outlet;
        };
        OutletInlet.prototype.onInvalidateOutput = function () {
            this._outlet.invalidateInput();
        };
        OutletInlet.prototype.onReconcileOutput = function (version) {
            this._outlet.reconcileInput(version);
        };
        return OutletInlet;
    }(AbstractInlet));

    var OutletMapInlet = (function (_super) {
        __extends(OutletMapInlet, _super);
        function OutletMapInlet(outlet) {
            var _this = _super.call(this) || this;
            _this._outlet = outlet;
            return _this;
        }
        OutletMapInlet.prototype.outlet = function () {
            return this._outlet;
        };
        OutletMapInlet.prototype.onInvalidateOutputKey = function (key, effect) {
            this._outlet.invalidateInput();
        };
        OutletMapInlet.prototype.onInvalidateOutput = function () {
            this._outlet.invalidateInput();
        };
        OutletMapInlet.prototype.onReconcileOutputKey = function (key, effect, version) {
            this._outlet.reconcileInput(version);
        };
        OutletMapInlet.prototype.onReconcileOutput = function (version) {
            this._outlet.reconcileInput(version);
        };
        return OutletMapInlet;
    }(AbstractMapInlet));

    var ValueInput = (function (_super) {
        __extends(ValueInput, _super);
        function ValueInput(state) {
            var _this = _super.call(this) || this;
            _this._state = state;
            return _this;
        }
        ValueInput.prototype.get = function () {
            return this._state;
        };
        ValueInput.prototype.set = function (newState) {
            var oldState = this._state;
            this._state = newState;
            this.invalidateInput();
            return oldState;
        };
        return ValueInput;
    }(AbstractOutlet));

    var ValueOutput = (function (_super) {
        __extends(ValueOutput, _super);
        function ValueOutput(state) {
            var _this = _super.call(this) || this;
            _this._state = state;
            return _this;
        }
        ValueOutput.prototype.get = function () {
            return this._state;
        };
        ValueOutput.prototype.onReconcileOutput = function (version) {
            if (this._input !== null) {
                this._state = this._input.get();
            }
        };
        return ValueOutput;
    }(AbstractInlet));

    var MapInput = (function (_super) {
        __extends(MapInput, _super);
        function MapInput(state) {
            if (state === void 0) { state = new BTree(); }
            var _this = _super.call(this) || this;
            _this._state = state;
            state.forEach(function (key) {
                this._effects = this._effects.updated(key, 0);
            }, _this);
            return _this;
        }
        MapInput.prototype.has = function (key) {
            return this._state.has(key);
        };
        MapInput.prototype.get = function (key) {
            if (key === void 0) {
                return this._state;
            }
            else {
                return this._state.get(key);
            }
        };
        MapInput.prototype.set = function (key, newValue) {
            var oldValue = this._state.get(key);
            this._state = this._state.updated(key, newValue);
            this.invalidateInputKey(key, 0);
            return oldValue;
        };
        MapInput.prototype.delete = function (key) {
            var oldState = this._state;
            var newState = oldState.removed(key);
            if (oldState !== newState) {
                this._state = newState;
                this.invalidateInputKey(key, 1);
            }
            return this;
        };
        MapInput.prototype.keyIterator = function () {
            return this._state.keys();
        };
        return MapInput;
    }(AbstractMapOutlet));

    var MapOutput = (function (_super) {
        __extends(MapOutput, _super);
        function MapOutput() {
            var _this = _super.call(this) || this;
            _this._state = new BTree();
            return _this;
        }
        MapOutput.prototype.get = function () {
            return this._state;
        };
        MapOutput.prototype.onReconcileOutputKey = function (key, effect, version) {
            if (effect === 0) {
                if (this._input !== null) {
                    var value = this._input.get(key);
                    if (value !== void 0) {
                        this._state = this._state.updated(key, value);
                    }
                    else {
                        this._state = this._state.removed(key);
                    }
                }
            }
            else if (effect === 1) {
                this._state = this._state.removed(key);
            }
        };
        return MapOutput;
    }(AbstractMapInlet));

    var MemoizeValueCombinator = (function (_super) {
        __extends(MemoizeValueCombinator, _super);
        function MemoizeValueCombinator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MemoizeValueCombinator.prototype.get = function () {
            return this._state;
        };
        MemoizeValueCombinator.prototype.onReconcile = function (version) {
            if (this._input !== null) {
                this._state = this._input.get();
            }
        };
        MemoizeValueCombinator.prototype.memoize = function () {
            return this;
        };
        return MemoizeValueCombinator;
    }(AbstractInoutlet));
    Outlet.MemoizeValueCombinator = MemoizeValueCombinator;

    var MemoizeMapCombinator = (function (_super) {
        __extends(MemoizeMapCombinator, _super);
        function MemoizeMapCombinator() {
            var _this = _super.call(this) || this;
            _this._cache = new BTree();
            return _this;
        }
        MemoizeMapCombinator.prototype.has = function (key) {
            return this._cache.has(key);
        };
        MemoizeMapCombinator.prototype.get = function (key) {
            if (key === void 0) {
                if (this._state === void 0 && this._input != null) {
                    this._state = this._input.get();
                }
                return this._state;
            }
            else {
                return this._cache.get(key);
            }
        };
        MemoizeMapCombinator.prototype.keyIterator = function () {
            return this._cache.keys();
        };
        MemoizeMapCombinator.prototype.onReconcileKey = function (key, effect, version) {
            if (effect === 0) {
                if (this._input !== null) {
                    var value = this._input.get(key);
                    if (value !== void 0) {
                        this._cache = this._cache.updated(key, value);
                    }
                    else {
                        this._cache = this._cache.removed(key);
                    }
                }
            }
            else if (effect === 1) {
                this._cache = this._cache.removed(key);
            }
        };
        MemoizeMapCombinator.prototype.onReconcile = function (version) {
            this._state = void 0;
        };
        MemoizeMapCombinator.prototype.memoize = function () {
            return this;
        };
        return MemoizeMapCombinator;
    }(AbstractMapInoutlet));
    MapOutlet.MemoizeMapCombinator = MemoizeMapCombinator;

    var FilterFieldsOperator = (function (_super) {
        __extends(FilterFieldsOperator, _super);
        function FilterFieldsOperator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FilterFieldsOperator.prototype.has = function (key) {
            if (this._input !== null) {
                var value = this._input.get(key);
                return value !== void 0 && this.evaluate(key, value);
            }
            return false;
        };
        FilterFieldsOperator.prototype.get = function (key) {
            if (key === void 0) {
                var output = new BTree();
                var keys = this.keyIterator();
                do {
                    var next = keys.next();
                    if (!next.done) {
                        var key_1 = next.value;
                        var value = this._input.get(key_1);
                        if (value !== void 0 && this.evaluate(key_1, value)) {
                            output.set(key_1, value);
                        }
                        continue;
                    }
                    break;
                } while (true);
                return output;
            }
            else {
                if (this._input !== null) {
                    var value = this._input.get(key);
                    if (value !== void 0 && this.evaluate(key, value)) {
                        return value;
                    }
                }
                return void 0;
            }
        };
        FilterFieldsOperator.prototype.keyIterator = function () {
            if (this._input !== null) {
                return this._input.keyIterator();
            }
            else {
                return Cursor.empty();
            }
        };
        FilterFieldsOperator.prototype.onInvalidateOutputKey = function (key, effect) {
            this.invalidateInputKey(key, effect);
        };
        FilterFieldsOperator.prototype.onReconcileOutputKey = function (key, effect, version) {
            this.reconcileInputKey(key, version);
        };
        FilterFieldsOperator.prototype.willReconcileInputKey = function (key, effect, version) {
            if (effect === 0) {
                if (this._input !== null) {
                    var value = this._input.get(key);
                    if (value === void 0 || !this.evaluate(key, value)) {
                        return 1;
                    }
                }
            }
            return effect;
        };
        return FilterFieldsOperator;
    }(AbstractMapInletMapOutlet));

    var FilterFieldsCombinator = (function (_super) {
        __extends(FilterFieldsCombinator, _super);
        function FilterFieldsCombinator(func) {
            var _this = _super.call(this) || this;
            _this._func = func;
            return _this;
        }
        FilterFieldsCombinator.prototype.evaluate = function (key, value) {
            return this._func(key, value);
        };
        return FilterFieldsCombinator;
    }(FilterFieldsOperator));
    MapOutlet.FilterFieldsCombinator = FilterFieldsCombinator;

    var MapValueOperator = (function (_super) {
        __extends(MapValueOperator, _super);
        function MapValueOperator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MapValueOperator.prototype.get = function () {
            if (this._input !== null) {
                return this.evaluate(this._input.get());
            }
            else {
                return void 0;
            }
        };
        return MapValueOperator;
    }(AbstractInoutlet));

    var MapValueCombinator = (function (_super) {
        __extends(MapValueCombinator, _super);
        function MapValueCombinator(func) {
            var _this = _super.call(this) || this;
            _this._func = func;
            return _this;
        }
        MapValueCombinator.prototype.evaluate = function (value) {
            if (value !== void 0) {
                return this._func(value);
            }
            else {
                return void 0;
            }
        };
        return MapValueCombinator;
    }(MapValueOperator));
    Outlet.MapValueCombinator = MapValueCombinator;

    var MapFieldValuesOperator = (function (_super) {
        __extends(MapFieldValuesOperator, _super);
        function MapFieldValuesOperator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MapFieldValuesOperator.prototype.has = function (key) {
            if (this._input !== null) {
                return this._input.has(key);
            }
            else {
                return false;
            }
        };
        MapFieldValuesOperator.prototype.get = function (key) {
            if (key === void 0) {
                var output = new BTree();
                var keys = this.keyIterator();
                do {
                    var next = keys.next();
                    if (!next.done) {
                        var key_1 = next.value;
                        var value = this.evaluate(key_1, this._input.get(key_1));
                        if (value !== void 0) {
                            output.set(key_1, value);
                        }
                        continue;
                    }
                    break;
                } while (true);
                return output;
            }
            else {
                if (this._input !== null) {
                    return this.evaluate(key, this._input.get(key));
                }
                else {
                    return void 0;
                }
            }
        };
        MapFieldValuesOperator.prototype.keyIterator = function () {
            if (this._input !== null) {
                return this._input.keyIterator();
            }
            else {
                return Cursor.empty();
            }
        };
        return MapFieldValuesOperator;
    }(AbstractMapInoutlet));

    var MapFieldValuesCombinator = (function (_super) {
        __extends(MapFieldValuesCombinator, _super);
        function MapFieldValuesCombinator(func) {
            var _this = _super.call(this) || this;
            _this._func = func;
            return _this;
        }
        MapFieldValuesCombinator.prototype.evaluate = function (key, value) {
            if (value !== void 0) {
                return this._func(key, value);
            }
            else {
                return void 0;
            }
        };
        return MapFieldValuesCombinator;
    }(MapFieldValuesOperator));
    MapOutlet.MapFieldValuesCombinator = MapFieldValuesCombinator;

    var ReduceFieldsOperator = (function (_super) {
        __extends(ReduceFieldsOperator, _super);
        function ReduceFieldsOperator() {
            var _this = _super.call(this) || this;
            _this._state = new BTree();
            return _this;
        }
        ReduceFieldsOperator.prototype.get = function () {
            return this._state.reduced(this.identity(), this.accumulate.bind(this), this.combine.bind(this));
        };
        ReduceFieldsOperator.prototype.onReconcileOutputKey = function (key, effect, version) {
            if (effect === 0) {
                if (this._input !== null) {
                    var value = this._input.get(key);
                    if (value !== void 0) {
                        this._state.set(key, value);
                    }
                    else {
                        this._state.delete(key);
                    }
                }
            }
            else if (effect === 1) {
                this._state.delete(key);
            }
        };
        return ReduceFieldsOperator;
    }(AbstractMapInletOutlet));

    var ReduceFieldsCombinator = (function (_super) {
        __extends(ReduceFieldsCombinator, _super);
        function ReduceFieldsCombinator(identity, accumulator, combiner) {
            var _this = _super.call(this) || this;
            _this._identity = identity;
            _this._accumulator = accumulator;
            _this._combiner = combiner;
            return _this;
        }
        ReduceFieldsCombinator.prototype.get = function () {
            return this._state.reduced(this._identity, this._accumulator, this._combiner);
        };
        ReduceFieldsCombinator.prototype.identity = function () {
            return this._identity;
        };
        ReduceFieldsCombinator.prototype.accumulate = function (result, value) {
            return this._accumulator(result, value);
        };
        ReduceFieldsCombinator.prototype.combine = function (result, value) {
            return this._combiner(result, value);
        };
        return ReduceFieldsCombinator;
    }(ReduceFieldsOperator));
    MapOutlet.ReduceFieldsCombinator = ReduceFieldsCombinator;

    var WatchValueOperator = (function (_super) {
        __extends(WatchValueOperator, _super);
        function WatchValueOperator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WatchValueOperator.prototype.onReconcileOutput = function (version) {
            if (this._input !== null) {
                this.evaluate(this._input.get());
            }
        };
        return WatchValueOperator;
    }(AbstractInlet));

    var WatchValueCombinator = (function (_super) {
        __extends(WatchValueCombinator, _super);
        function WatchValueCombinator(func) {
            var _this = _super.call(this) || this;
            _this._func = func;
            return _this;
        }
        WatchValueCombinator.prototype.evaluate = function (value) {
            if (value !== void 0) {
                return this._func(value);
            }
        };
        return WatchValueCombinator;
    }(WatchValueOperator));
    Outlet.WatchValueCombinator = WatchValueCombinator;

    var WatchFieldsOperator = (function (_super) {
        __extends(WatchFieldsOperator, _super);
        function WatchFieldsOperator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WatchFieldsOperator.prototype.onReconcileOutputKey = function (key, effect, version) {
            if (effect === 0) {
                if (this._input !== null) {
                    this.evaluate(key, this._input.get(key));
                }
                else {
                    this.evaluate(key, void 0);
                }
            }
            else if (effect === 1) {
                this.evaluate(key, void 0);
            }
        };
        return WatchFieldsOperator;
    }(AbstractMapInlet));

    var WatchFieldsCombinator = (function (_super) {
        __extends(WatchFieldsCombinator, _super);
        function WatchFieldsCombinator(func) {
            var _this = _super.call(this) || this;
            _this._func = func;
            return _this;
        }
        WatchFieldsCombinator.prototype.evaluate = function (key, value) {
            if (value !== void 0) {
                return this._func(key, value);
            }
        };
        return WatchFieldsCombinator;
    }(WatchFieldsOperator));
    MapOutlet.WatchFieldsCombinator = WatchFieldsCombinator;

    var StreamletInlet = (function (_super) {
        __extends(StreamletInlet, _super);
        function StreamletInlet(streamlet) {
            var _this = _super.call(this) || this;
            _this._streamlet = streamlet;
            return _this;
        }
        StreamletInlet.prototype.streamlet = function () {
            return this._streamlet;
        };
        StreamletInlet.prototype.willInvalidateOutput = function () {
            var streamlet = this._streamlet;
            if (streamlet.willInvalidateInlet) {
                streamlet.willInvalidateInlet(this);
            }
        };
        StreamletInlet.prototype.didInvalidateOutput = function () {
            var streamlet = this._streamlet;
            if (streamlet.didInvalidateInlet) {
                streamlet.didInvalidateInlet(this);
            }
            else {
                streamlet.invalidate();
            }
        };
        StreamletInlet.prototype.willReconcileOutput = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.willReconcileInlet) {
                streamlet.willReconcileInlet(this, version);
            }
        };
        StreamletInlet.prototype.didReconcileOutput = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.didReconcileInlet) {
                streamlet.didReconcileInlet(this, version);
            }
            else {
                streamlet.reconcile(version);
            }
        };
        return StreamletInlet;
    }(AbstractInlet));

    var StreamletOutlet = (function (_super) {
        __extends(StreamletOutlet, _super);
        function StreamletOutlet(streamlet) {
            var _this = _super.call(this) || this;
            _this._streamlet = streamlet;
            return _this;
        }
        StreamletOutlet.prototype.streamlet = function () {
            return this._streamlet;
        };
        StreamletOutlet.prototype.get = function () {
            var streamlet = this._streamlet;
            if (streamlet.getOutput) {
                return streamlet.getOutput(this);
            }
            return void 0;
        };
        StreamletOutlet.prototype.willInvalidateInput = function () {
            var streamlet = this._streamlet;
            if (streamlet.willInvalidateOutlet) {
                streamlet.willInvalidateOutlet(this);
            }
        };
        StreamletOutlet.prototype.didInvalidateInput = function () {
            var streamlet = this._streamlet;
            if (streamlet.didInvalidateOutlet) {
                streamlet.didInvalidateOutlet(this);
            }
            else {
                streamlet.invalidate();
            }
        };
        StreamletOutlet.prototype.willReconcileInput = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.willReconcileOutlet) {
                streamlet.willReconcileOutlet(this, version);
            }
        };
        StreamletOutlet.prototype.didReconcileInput = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.didReconcileOutlet) {
                streamlet.didReconcileOutlet(this, version);
            }
        };
        return StreamletOutlet;
    }(AbstractOutlet));

    var StreamletInoutlet = (function (_super) {
        __extends(StreamletInoutlet, _super);
        function StreamletInoutlet(streamlet) {
            var _this = _super.call(this) || this;
            _this._streamlet = streamlet;
            return _this;
        }
        StreamletInoutlet.prototype.streamlet = function () {
            return this._streamlet;
        };
        StreamletInoutlet.prototype.get = function () {
            var streamlet = this._streamlet;
            if (streamlet.getOutput) {
                var output = streamlet.getOutput(this);
                if (output !== void 0) {
                    return output;
                }
            }
            if (this._input !== null) {
                return this._input.get();
            }
            return void 0;
        };
        StreamletInoutlet.prototype.willInvalidate = function () {
            var streamlet = this._streamlet;
            if (streamlet.willInvalidateOutlet) {
                streamlet.willInvalidateOutlet(this);
            }
        };
        StreamletInoutlet.prototype.didInvalidate = function () {
            var streamlet = this._streamlet;
            if (streamlet.didInvalidateOutlet) {
                streamlet.didInvalidateOutlet(this);
            }
            else {
                streamlet.invalidate();
            }
        };
        StreamletInoutlet.prototype.willUpdate = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.willReconcileOutlet) {
                streamlet.willReconcileOutlet(this, version);
            }
        };
        StreamletInoutlet.prototype.didUpdate = function (version) {
            var streamlet = this._streamlet;
            if (streamlet.didReconcileOutlet) {
                streamlet.didReconcileOutlet(this, version);
            }
        };
        return StreamletInoutlet;
    }(AbstractInoutlet));

    var InletDescriptor = (function () {
        function InletDescriptor(key, name, type) {
            this.key = key;
            this.name = name;
            this.type = type;
        }
        return InletDescriptor;
    }());
    var OutletDescriptor = (function () {
        function OutletDescriptor(key, name, type) {
            this.key = key;
            this.name = name;
            this.type = type;
        }
        return OutletDescriptor;
    }());
    var InoutletDescriptor = (function () {
        function InoutletDescriptor(key, name, type) {
            this.key = key;
            this.name = name;
            this.type = type;
        }
        return InoutletDescriptor;
    }());
    var AbstractStreamlet = (function () {
        function AbstractStreamlet(scope) {
            if (scope === void 0) { scope = null; }
            this.scope = scope;
            this._version = -1;
        }
        AbstractStreamlet.prototype.streamletClass = function () {
            return this.__proto__;
        };
        AbstractStreamlet.prototype.streamletScope = function () {
            return this.scope;
        };
        AbstractStreamlet.prototype.setStreamletScope = function (scope) {
            this.scope = scope;
        };
        AbstractStreamlet.prototype.streamletContext = function () {
            if (this.context) {
                return this.context;
            }
            var scope = this.streamletScope();
            if (scope !== null) {
                return scope.streamletContext();
            }
            return null;
        };
        AbstractStreamlet.prototype.setStreamletContext = function (context) {
            this.context = context;
        };
        AbstractStreamlet.prototype.inlet = function (key) {
            if (key === void 0) {
                return new StreamletInlet(this);
            }
            else {
                return AbstractStreamlet.reflectInletKey(key, this, this.streamletClass());
            }
        };
        AbstractStreamlet.prototype.bindInput = function (key, input) {
            var inlet = this.inlet(key);
            if (inlet === null) {
                throw new Error("" + key);
            }
            inlet.bindInput(input);
        };
        AbstractStreamlet.prototype.unbindInput = function (key) {
            var inlet = this.inlet(key);
            if (inlet === null) {
                throw new Error("" + key);
            }
            inlet.unbindInput();
        };
        AbstractStreamlet.prototype.outlet = function (key) {
            if (key === void 0) {
                return new StreamletOutlet(this);
            }
            else if (typeof key === "string") {
                return AbstractStreamlet.reflectOutletKey(key, this, this.streamletClass());
            }
            else {
                return key;
            }
        };
        AbstractStreamlet.prototype.inoutlet = function () {
            return new StreamletInoutlet(this);
        };
        AbstractStreamlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                this.onInvalidateOutlets();
                this.didInvalidate();
            }
        };
        AbstractStreamlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._version = version;
                this.onReconcileInlets(version);
                this.onReconcile(version);
                this.onReconcileOutlets(version);
                this.didReconcile(version);
            }
        };
        AbstractStreamlet.prototype.getInput = function (inlet, orElse) {
            if (typeof inlet === "string") {
                inlet = this.inlet(inlet);
            }
            var object;
            if (inlet !== null) {
                var input = inlet.input();
                if (input !== null) {
                    object = input.get();
                }
            }
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        AbstractStreamlet.prototype.getOutput = function (outlet) {
            return void 0;
        };
        AbstractStreamlet.prototype.disconnectInputs = function () {
            AbstractStreamlet.disconnectInputs(this, this.streamletClass());
        };
        AbstractStreamlet.disconnectInputs = function (streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    for (var name_1 in streamletClass._inlets) {
                        var inletDescriptor = streamletClass._inlets[name_1];
                        if (inletDescriptor instanceof InletDescriptor) {
                            var inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
                            inlet.disconnectInputs();
                        }
                        else if (inletDescriptor instanceof InoutletDescriptor) {
                            var inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
                            inoutlet.disconnectInputs();
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
        };
        AbstractStreamlet.prototype.disconnectOutputs = function () {
            AbstractStreamlet.disconnectOutputs(this, this.streamletClass());
        };
        AbstractStreamlet.disconnectOutputs = function (streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var name_2 in streamletClass._outlets) {
                        var outletDescriptor = streamletClass._outlets[name_2];
                        if (outletDescriptor instanceof OutletDescriptor) {
                            var outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
                            outlet.disconnectOutputs();
                        }
                        else if (outletDescriptor instanceof InoutletDescriptor) {
                            var inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
                            inoutlet.disconnectOutputs();
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
        };
        AbstractStreamlet.prototype.willInvalidateInlet = function (inlet) {
        };
        AbstractStreamlet.prototype.didInvalidateInlet = function (inlet) {
            this.invalidate();
        };
        AbstractStreamlet.prototype.willReconcileInlet = function (inlet, version) {
        };
        AbstractStreamlet.prototype.didReconcileInlet = function (inlet, version) {
            this.reconcile(version);
        };
        AbstractStreamlet.prototype.willInvalidateOutlet = function (outlet) {
        };
        AbstractStreamlet.prototype.didInvalidateOutlet = function (outlet) {
        };
        AbstractStreamlet.prototype.willReconcileOutlet = function (outlet, version) {
        };
        AbstractStreamlet.prototype.didReconcileOutlet = function (outlet, version) {
        };
        AbstractStreamlet.prototype.willInvalidate = function () {
        };
        AbstractStreamlet.prototype.onInvalidate = function () {
        };
        AbstractStreamlet.prototype.onInvalidateOutlets = function () {
            AbstractStreamlet.invalidateOutlets(this, this.streamletClass());
        };
        AbstractStreamlet.invalidateOutlets = function (streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var name_3 in streamletClass._outlets) {
                        var outletDescriptor = streamletClass._outlets[name_3];
                        if (outletDescriptor instanceof OutletDescriptor) {
                            var outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
                            outlet.invalidateInput();
                        }
                        else if (outletDescriptor instanceof InoutletDescriptor) {
                            var inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
                            inoutlet.invalidateInput();
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
        };
        AbstractStreamlet.prototype.didInvalidate = function () {
        };
        AbstractStreamlet.prototype.willReconcile = function (version) {
        };
        AbstractStreamlet.prototype.onReconcileInlets = function (version) {
            AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());
        };
        AbstractStreamlet.reconcileInlets = function (version, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    for (var name_4 in streamletClass._inlets) {
                        var inletDescriptor = streamletClass._inlets[name_4];
                        if (inletDescriptor instanceof InletDescriptor) {
                            var inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
                            inlet.reconcileOutput(version);
                        }
                        else if (inletDescriptor instanceof InoutletDescriptor) {
                            var inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
                            inoutlet.reconcileOutput(version);
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
        };
        AbstractStreamlet.prototype.onReconcile = function (version) {
        };
        AbstractStreamlet.prototype.onReconcileOutlets = function (version) {
            AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());
        };
        AbstractStreamlet.reconcileOutlets = function (version, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var name_5 in streamletClass._outlets) {
                        var outletDescriptor = streamletClass._outlets[name_5];
                        if (outletDescriptor instanceof OutletDescriptor) {
                            var outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
                            outlet.reconcileInput(version);
                        }
                        else if (outletDescriptor instanceof InoutletDescriptor) {
                            var inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
                            inoutlet.reconcileInput(version);
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
        };
        AbstractStreamlet.prototype.didReconcile = function (version) {
        };
        AbstractStreamlet.reflectEachInlet = function (streamlet, streamletClass, callback, thisArg) {
            var index = 0;
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    for (var name_6 in streamletClass._inlets) {
                        var inletDescriptor = streamletClass._inlets[name_6];
                        var inlet = void 0;
                        if (inletDescriptor instanceof InletDescriptor) {
                            inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
                        }
                        else if (inletDescriptor instanceof InoutletDescriptor) {
                            inlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
                        }
                        else {
                            inlet = null;
                        }
                        var result = callback.call(thisArg, inlet, inletDescriptor.name, index);
                        if (result !== void 0) {
                            return result;
                        }
                        index += 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return void 0;
        };
        AbstractStreamlet.reflectEachOutlet = function (streamlet, streamletClass, callback, thisArg) {
            var index = 0;
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var name_7 in streamletClass._outlets) {
                        var outletDescriptor = streamletClass._outlets[name_7];
                        var outlet = void 0;
                        if (outletDescriptor instanceof OutletDescriptor) {
                            outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
                        }
                        else if (outletDescriptor instanceof InoutletDescriptor) {
                            outlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
                        }
                        else {
                            outlet = null;
                        }
                        var result = callback.call(thisArg, outlet, outletDescriptor.name, index);
                        if (result !== void 0) {
                            return result;
                        }
                        index += 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return void 0;
        };
        AbstractStreamlet.reflectInletCount = function (streamletClass) {
            var count = 0;
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    for (var _ in streamletClass._inlets) {
                        count += 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return count;
        };
        AbstractStreamlet.reflectOutletCount = function (streamletClass) {
            var count = 0;
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var _ in streamletClass._outlets) {
                        count += 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return count;
        };
        AbstractStreamlet.reflectInletIndex = function (index, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    for (var name_8 in streamletClass._inlets) {
                        if (index === 0) {
                            var inletDescriptor = streamletClass._inlets[name_8];
                            if (inletDescriptor instanceof InletDescriptor) {
                                return [inletDescriptor.name, AbstractStreamlet.reflectInletField(streamlet, inletDescriptor)];
                            }
                            else if (inletDescriptor instanceof InoutletDescriptor) {
                                return [inletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor)];
                            }
                            else {
                                return null;
                            }
                        }
                        index -= 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return null;
        };
        AbstractStreamlet.reflectOutletIndex = function (index, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    for (var name_9 in streamletClass._outlets) {
                        if (index === 0) {
                            var outletDescriptor = streamletClass._outlets[name_9];
                            if (outletDescriptor instanceof OutletDescriptor) {
                                return [outletDescriptor.name, AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor)];
                            }
                            else if (outletDescriptor instanceof InoutletDescriptor) {
                                return [outletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor)];
                            }
                            else {
                                return null;
                            }
                        }
                        index -= 1;
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return null;
        };
        AbstractStreamlet.reflectInletKey = function (key, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_inlets")) {
                    var inletDescriptor = streamletClass._inlets[key];
                    if (inletDescriptor !== void 0) {
                        if (inletDescriptor instanceof InletDescriptor) {
                            return AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
                        }
                        else if (inletDescriptor instanceof InoutletDescriptor) {
                            return AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
                        }
                        else {
                            return null;
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return null;
        };
        AbstractStreamlet.reflectOutletKey = function (key, streamlet, streamletClass) {
            while (streamletClass) {
                if (streamletClass.hasOwnProperty("_outlets")) {
                    var outletDescriptor = streamletClass._outlets[key];
                    if (outletDescriptor !== void 0) {
                        if (outletDescriptor instanceof OutletDescriptor) {
                            return AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
                        }
                        else if (outletDescriptor instanceof InoutletDescriptor) {
                            return AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
                        }
                        else {
                            return null;
                        }
                    }
                }
                streamletClass = streamletClass.__proto__;
            }
            return null;
        };
        AbstractStreamlet.reflectInletField = function (streamlet, inletDescriptor) {
            if (inletDescriptor.type === "value") {
                return AbstractStreamlet.reflectValueInletField(streamlet, inletDescriptor.key);
            }
            else if (inletDescriptor.type === "map") {
                return AbstractStreamlet.reflectMapInletField(streamlet, inletDescriptor.key);
            }
            else {
                throw new TypeError(inletDescriptor.type);
            }
        };
        AbstractStreamlet.reflectValueInletField = function (streamlet, key) {
            var inlet = streamlet[key];
            if (!inlet) {
                if (streamlet instanceof AbstractStreamlet) {
                    inlet = streamlet.inlet();
                }
                else {
                    inlet = new StreamletInlet(streamlet);
                }
                streamlet[key] = inlet;
            }
            return inlet;
        };
        AbstractStreamlet.reflectMapInletField = function (streamlet, key) {
            return null;
        };
        AbstractStreamlet.reflectOutletField = function (streamlet, outletDescriptor) {
            if (outletDescriptor.type === "value") {
                return AbstractStreamlet.reflectValueOutletField(streamlet, outletDescriptor.key);
            }
            else if (outletDescriptor.type === "map") {
                return AbstractStreamlet.reflectMapOutletField(streamlet, outletDescriptor.key);
            }
            else {
                throw new TypeError(outletDescriptor.type);
            }
        };
        AbstractStreamlet.reflectValueOutletField = function (streamlet, key) {
            var outlet = streamlet[key];
            if (!outlet) {
                if (streamlet instanceof AbstractStreamlet) {
                    outlet = streamlet.outlet();
                }
                else {
                    outlet = new StreamletOutlet(streamlet);
                }
                streamlet[key] = outlet;
            }
            return outlet;
        };
        AbstractStreamlet.reflectMapOutletField = function (streamlet, key) {
            return null;
        };
        AbstractStreamlet.reflectInoutletField = function (streamlet, inoutletDescriptor) {
            if (inoutletDescriptor.type === "value") {
                return AbstractStreamlet.reflectValueInoutletField(streamlet, inoutletDescriptor.key);
            }
            else if (inoutletDescriptor.type === "map") {
                return AbstractStreamlet.reflectMapInoutletField(streamlet, inoutletDescriptor.key);
            }
            else {
                throw new TypeError(inoutletDescriptor.type);
            }
        };
        AbstractStreamlet.reflectValueInoutletField = function (streamlet, key) {
            var inoutlet = streamlet[key];
            if (!inoutlet) {
                if (streamlet instanceof AbstractStreamlet) {
                    inoutlet = streamlet.inoutlet();
                }
                else {
                    inoutlet = new StreamletInoutlet(streamlet);
                }
                streamlet[key] = inoutlet;
            }
            return inoutlet;
        };
        AbstractStreamlet.reflectMapInoutletField = function (streamlet, key) {
            return null;
        };
        AbstractStreamlet.init = function (streamletClass) {
            if (!streamletClass.hasOwnProperty("_inlets")) {
                streamletClass._inlets = {};
            }
            if (!streamletClass.hasOwnProperty("_outlets")) {
                streamletClass._outlets = {};
            }
            if (!streamletClass.hasOwnProperty("_inoutlets")) {
                streamletClass._inoutlets = {};
            }
        };
        AbstractStreamlet.decorateInlet = function (options, target, key) {
            AbstractStreamlet.init(target);
            var name = options.name !== void 0 ? options.name : key;
            var type = options.type !== void 0 ? options.type : "value";
            var inletDescriptor = new InletDescriptor(key, name, type);
            target._inlets[name] = inletDescriptor;
        };
        AbstractStreamlet.decorateOutlet = function (options, target, key) {
            AbstractStreamlet.init(target);
            var name = options.name !== void 0 ? options.name : key;
            var type = options.type !== void 0 ? options.type : "value";
            var outletDescriptor = new OutletDescriptor(key, name, type);
            target._outlets[name] = outletDescriptor;
        };
        AbstractStreamlet.decorateInoutlet = function (options, target, key) {
            AbstractStreamlet.init(target);
            var name = options.name !== void 0 ? options.name : key;
            var type = options.type !== void 0 ? options.type : "value";
            var inoutletDescriptor = new InoutletDescriptor(key, name, type);
            target._inlets[name] = inoutletDescriptor;
            target._outlets[name] = inoutletDescriptor;
            target._inoutlets[name] = inoutletDescriptor;
        };
        return AbstractStreamlet;
    }());

    function In(target, key) {
        if (arguments.length === 1) {
            if (typeof target === "string") {
                target = { name: target };
            }
            return AbstractStreamlet.decorateInlet.bind(void 0, target);
        }
        else {
            AbstractStreamlet.decorateInlet({}, target, key);
        }
    }

    function Out(target, key) {
        if (arguments.length === 1) {
            if (typeof target === "string") {
                target = { name: target };
            }
            return AbstractStreamlet.decorateOutlet.bind(void 0, target);
        }
        else {
            AbstractStreamlet.decorateOutlet({}, target, key);
        }
    }

    function Inout(target, key) {
        if (arguments.length === 1) {
            if (typeof target === "string") {
                target = { name: target };
            }
            return AbstractStreamlet.decorateInoutlet.bind(void 0, target);
        }
        else {
            AbstractStreamlet.decorateInoutlet({}, target, key);
        }
    }

    var RecordOutlet = {
        is: function (object) {
            if (typeof object === "object" && object) {
                var outlet = object;
                return MapOutlet.is(outlet) && StreamletScope.is(outlet);
            }
            return false;
        },
        Streamlet: void 0,
        Model: void 0,
        Scope: void 0,
        Dataflow: void 0,
    };

    var AbstractRecordOutlet = (function (_super) {
        __extends(AbstractRecordOutlet, _super);
        function AbstractRecordOutlet() {
            var _this = _super.call(this) || this;
            _this._effects = new BTree();
            _this._outlets = new BTree();
            _this._outputs = null;
            _this._version = -1;
            return _this;
        }
        AbstractRecordOutlet.prototype.streamletScope = function () {
            return null;
        };
        AbstractRecordOutlet.prototype.streamletContext = function () {
            var scope = this.streamletScope();
            if (scope !== null) {
                return scope.streamletContext();
            }
            return null;
        };
        AbstractRecordOutlet.prototype.hasOwn = function (key) {
            return this.has(key);
        };
        AbstractRecordOutlet.prototype.get = function (key) {
            if (key === void 0) {
                return this;
            }
            else {
                return _super.prototype.get.call(this, key);
            }
        };
        AbstractRecordOutlet.prototype.outlet = function (key) {
            if (typeof key === "string") {
                key = Text.from(key);
            }
            if (!this.hasOwn(key)) {
                var scope = this.streamletScope();
                if (RecordOutlet.is(scope) && scope.has(key)) {
                    return scope.outlet(key);
                }
            }
            var outlet = this._outlets.get(key);
            if (outlet === void 0) {
                outlet = new KeyOutlet(this, key);
                this._outlets = this._outlets.updated(key, outlet);
                this.invalidateInputKey(key, 0);
            }
            return outlet;
        };
        AbstractRecordOutlet.prototype.outputIterator = function () {
            return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
        };
        AbstractRecordOutlet.prototype.bindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            var newOutputs = new Array(n + 1);
            for (var i = 0; i < n; i += 1) {
                newOutputs[i] = oldOutputs[i];
            }
            newOutputs[n] = output;
            this._outputs = newOutputs;
        };
        AbstractRecordOutlet.prototype.unbindOutput = function (output) {
            var oldOutputs = this._outputs;
            var n = oldOutputs !== null ? oldOutputs.length : 0;
            for (var i = 0; i < n; i += 1) {
                if (oldOutputs[i] === output) {
                    if (n > 1) {
                        var newOutputs = new Array(n - 1);
                        for (var j = 0; j < i; j += 1) {
                            newOutputs[j] = oldOutputs[j];
                        }
                        for (var j = i; j < n - 1; j += 1) {
                            newOutputs[j] = oldOutputs[j + 1];
                        }
                        this._outputs = newOutputs;
                    }
                    else {
                        this._outputs = null;
                    }
                    break;
                }
            }
        };
        AbstractRecordOutlet.prototype.unbindOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.unbindOutputs();
                }, this);
            }
            var oldOutputs = this._outputs;
            if (oldOutputs !== null) {
                this._outputs = null;
                for (var i = 0, n = oldOutputs.length; i < n; i += 1) {
                    oldOutputs[i].unbindInput();
                }
            }
        };
        AbstractRecordOutlet.prototype.disconnectOutputs = function () {
            var outlets = this._outlets;
            if (outlets.isEmpty()) {
                this._outlets = new BTree();
                outlets.forEach(function (key, keyOutlet) {
                    keyOutlet.disconnectOutputs();
                }, this);
            }
            var outputs = this._outputs;
            if (outputs !== null) {
                this._outputs = null;
                for (var i = 0, n = outputs.length; i < n; i += 1) {
                    var output = outputs[i];
                    output.unbindInput();
                    output.disconnectOutputs();
                }
            }
            this.forEach(function (member) {
                if (member instanceof Field) {
                    member = member.toValue();
                }
                if (member instanceof AbstractRecordOutlet) {
                    member.disconnectOutputs();
                }
                else if (member instanceof RecordOutlet.Streamlet) {
                    member.disconnectOutputs();
                }
                else if (RecordOutlet.is(member)) {
                    member.disconnectOutputs();
                }
            }, this);
        };
        AbstractRecordOutlet.prototype.disconnectInputs = function () {
        };
        AbstractRecordOutlet.prototype.invalidateInputKey = function (key, effect) {
            var oldEffects = this._effects;
            if (oldEffects.get(key) !== effect) {
                this.willInvalidateInputKey(key, effect);
                this._effects = oldEffects.updated(key, effect);
                this._version = -1;
                this.onInvalidateInputKey(key, effect);
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    var output = this._outputs[i];
                    if (MapInlet.is(output)) {
                        output.invalidateOutputKey(key, effect);
                    }
                    else {
                        output.invalidateOutput();
                    }
                }
                var outlet = this._outlets.get(key);
                if (outlet !== void 0) {
                    outlet.invalidateInput();
                }
                this.didInvalidateInputKey(key, effect);
            }
        };
        AbstractRecordOutlet.prototype.invalidateInput = function () {
            if (this._version >= 0) {
                this.willInvalidateInput();
                this._version = -1;
                this.onInvalidateInput();
                var n = this._outputs !== null ? this._outputs.length : 0;
                for (var i = 0; i < n; i += 1) {
                    this._outputs[i].invalidateOutput();
                }
                this._outlets.forEach(function (key, outlet) {
                    outlet.invalidateInput();
                }, this);
                this.didInvalidateInput();
            }
        };
        AbstractRecordOutlet.prototype.reconcileInputKey = function (key, version) {
            if (this._version < 0) {
                var oldEffects = this._effects;
                var effect = oldEffects.get(key);
                if (effect !== void 0) {
                    this.willReconcileInputKey(key, effect, version);
                    this._effects = oldEffects.removed(key);
                    this.onReconcileInputKey(key, effect, version);
                    for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                        var output = this._outputs[i];
                        if (MapInlet.is(output)) {
                            output.reconcileOutputKey(key, version);
                        }
                    }
                    var outlet = this._outlets.get(key);
                    if (outlet !== void 0) {
                        outlet.reconcileInput(version);
                    }
                    this.didReconcileInputKey(key, effect, version);
                }
            }
        };
        AbstractRecordOutlet.prototype.reconcileInput = function (version) {
            if (this._version < 0) {
                this.willReconcileInput(version);
                this._effects.forEach(function (key) {
                    this.reconcileInputKey(key, version);
                }, this);
                this._version = version;
                this.onReconcileInput(version);
                for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                    this._outputs[i].reconcileOutput(version);
                }
                this.forEach(function (member) {
                    if (member instanceof Field) {
                        member = member.toValue();
                    }
                    if (member instanceof AbstractRecordOutlet) {
                        member.reconcileInput(version);
                    }
                    else if (member instanceof RecordOutlet.Streamlet) {
                        member.reconcile(version);
                    }
                    else if (RecordOutlet.is(member)) {
                        member.reconcileInput(version);
                    }
                }, this);
                this.didReconcileInput(version);
            }
        };
        AbstractRecordOutlet.prototype.willInvalidateInputKey = function (key, effect) {
        };
        AbstractRecordOutlet.prototype.onInvalidateInputKey = function (key, effect) {
        };
        AbstractRecordOutlet.prototype.didInvalidateInputKey = function (key, effect) {
        };
        AbstractRecordOutlet.prototype.willInvalidateInput = function () {
        };
        AbstractRecordOutlet.prototype.onInvalidateInput = function () {
        };
        AbstractRecordOutlet.prototype.didInvalidateInput = function () {
        };
        AbstractRecordOutlet.prototype.willReconcileInputKey = function (key, effect, version) {
        };
        AbstractRecordOutlet.prototype.onReconcileInputKey = function (key, effect, version) {
        };
        AbstractRecordOutlet.prototype.didReconcileInputKey = function (key, effect, version) {
        };
        AbstractRecordOutlet.prototype.willReconcileInput = function (version) {
        };
        AbstractRecordOutlet.prototype.onReconcileInput = function (version) {
        };
        AbstractRecordOutlet.prototype.didReconcileInput = function (version) {
        };
        AbstractRecordOutlet.prototype.memoize = function () {
            var combinator = new MemoizeMapCombinator();
            combinator.bindInput(this);
            return combinator;
        };
        AbstractRecordOutlet.prototype.filter = function (func) {
            if (typeof func !== "function") {
                return _super.prototype.filter.call(this, func);
            }
            else {
                var combinator = new FilterFieldsCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
        };
        AbstractRecordOutlet.prototype.map = function (func) {
            if (func.length === 1) {
                var combinator = new MapValueCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
            else {
                var combinator = new MapFieldValuesCombinator(func);
                combinator.bindInput(this);
                return combinator;
            }
        };
        AbstractRecordOutlet.prototype.reduce = function (identity, accumulator, combiner) {
            var combinator = new ReduceFieldsCombinator(identity, accumulator, combiner);
            combinator.bindInput(this);
            return combinator;
        };
        AbstractRecordOutlet.prototype.watch = function (func) {
            if (func.length === 1) {
                var combinator = new WatchValueCombinator(func);
                combinator.bindInput(this);
                return this;
            }
            else {
                var combinator = new WatchFieldsCombinator(func);
                combinator.bindInput(this);
                return this;
            }
        };
        return AbstractRecordOutlet;
    }(Record));

    var RecordStreamlet = (function (_super) {
        __extends(RecordStreamlet, _super);
        function RecordStreamlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RecordStreamlet.prototype.isConstant = function () {
            return false;
        };
        RecordStreamlet.prototype.streamletClass = function () {
            return this.__proto__;
        };
        RecordStreamlet.prototype.compile = function () {
            AbstractStreamlet.reflectEachInlet(this, this.streamletClass(), function (inlet, name) {
                if (inlet.input() === null) {
                    this.compileInlet(inlet, name);
                }
            }, this);
        };
        RecordStreamlet.prototype.compileInlet = function (inlet, name) {
            var scope = this.streamletScope();
            if (scope !== null) {
                var input = scope.outlet(name);
                if (input !== null) {
                    inlet.bindInput(input);
                }
            }
        };
        return RecordStreamlet;
    }(Record));
    RecordOutlet.Streamlet = RecordStreamlet;

    var AbstractRecordStreamlet = (function (_super) {
        __extends(AbstractRecordStreamlet, _super);
        function AbstractRecordStreamlet(scope) {
            if (scope === void 0) { scope = null; }
            var _this = _super.call(this) || this;
            _this.scope = scope;
            _this.context = null;
            _this._version = -1;
            return _this;
        }
        AbstractRecordStreamlet.prototype.streamletScope = function () {
            return this.scope;
        };
        AbstractRecordStreamlet.prototype.setStreamletScope = function (scope) {
            this.scope = scope;
        };
        AbstractRecordStreamlet.prototype.streamletContext = function () {
            if (this.context) {
                return this.context;
            }
            var scope = this.streamletScope();
            if (scope !== null) {
                return scope.streamletContext();
            }
            return null;
        };
        AbstractRecordStreamlet.prototype.setStreamletContext = function (context) {
            this.context = context;
        };
        AbstractRecordStreamlet.prototype.isEmpty = function () {
            return this.length !== 0;
        };
        Object.defineProperty(AbstractRecordStreamlet.prototype, "length", {
            get: function () {
                return AbstractStreamlet.reflectOutletCount(this.streamletClass());
            },
            enumerable: true,
            configurable: true
        });
        AbstractRecordStreamlet.prototype.has = function (key) {
            if (key instanceof Text) {
                key = key.value;
            }
            else if (typeof key !== "string") {
                return false;
            }
            var outlet = this.outlet(key);
            return outlet !== null;
        };
        AbstractRecordStreamlet.prototype.get = function (key) {
            if (key instanceof Text) {
                key = key.value;
            }
            else if (typeof key !== "string") {
                return Value.absent();
            }
            var outlet = this.outlet(key);
            if (outlet !== null) {
                var output = outlet.get();
                if (output !== void 0) {
                    return output;
                }
            }
            return Value.absent();
        };
        AbstractRecordStreamlet.prototype.getAttr = function (key) {
            return Value.absent();
        };
        AbstractRecordStreamlet.prototype.getSlot = function (key) {
            return this.get(key);
        };
        AbstractRecordStreamlet.prototype.getField = function (key) {
            if (typeof key === "string") {
                key = Text.from(key);
            }
            else if (!(key instanceof Text)) {
                return void 0;
            }
            var value = this.get(key);
            if (value.isDefined()) {
                return Slot.of(key, value);
            }
            return void 0;
        };
        AbstractRecordStreamlet.prototype.getItem = function (index) {
            if (index instanceof Num) {
                index = index.value;
            }
            var entry = AbstractStreamlet.reflectOutletIndex(index, this, this.streamletClass());
            if (entry !== null) {
                var name_1 = entry[0];
                var output = entry[1].get();
                if (output === void 0) {
                    output = Value.extant();
                }
                return Slot.of(name_1, output);
            }
            return Item.absent();
        };
        AbstractRecordStreamlet.prototype.set = function (key, newValue) {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.setAttr = function (key, newValue) {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.setSlot = function (key, newValue) {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.setItem = function (index, item) {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.splice = function (start, deleteCount) {
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.delete = function (key) {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.clear = function () {
            throw new Error("unsupported");
        };
        AbstractRecordStreamlet.prototype.forEach = function (callback, thisArg) {
            return AbstractStreamlet.reflectEachOutlet(this, this.streamletClass(), function (outlet, name, index) {
                var output = outlet.get();
                if (output !== void 0) {
                    var result = callback.call(thisArg, output, index);
                    if (result !== void 0) {
                        return result;
                    }
                }
            }, this);
        };
        AbstractRecordStreamlet.prototype.inlet = function (key) {
            if (key === void 0) {
                return new StreamletInlet(this);
            }
            else {
                return AbstractStreamlet.reflectInletKey(key, this, this.streamletClass());
            }
        };
        AbstractRecordStreamlet.prototype.bindInput = function (key, input) {
            var inlet = this.inlet(key);
            if (inlet === null) {
                throw new Error("" + key);
            }
            inlet.bindInput(input);
        };
        AbstractRecordStreamlet.prototype.unbindInput = function (key) {
            var inlet = this.inlet(key);
            if (inlet === null) {
                throw new Error("" + key);
            }
            inlet.unbindInput();
        };
        AbstractRecordStreamlet.prototype.outlet = function (key) {
            if (key === void 0) {
                return new StreamletOutlet(this);
            }
            else if (typeof key === "string") {
                return AbstractStreamlet.reflectOutletKey(key, this, this.streamletClass());
            }
            else {
                return key;
            }
        };
        AbstractRecordStreamlet.prototype.inoutlet = function () {
            return new StreamletInoutlet(this);
        };
        AbstractRecordStreamlet.prototype.invalidate = function () {
            if (this._version >= 0) {
                this.willInvalidate();
                this._version = -1;
                this.onInvalidate();
                this.onInvalidateOutlets();
                this.didInvalidate();
            }
        };
        AbstractRecordStreamlet.prototype.reconcile = function (version) {
            if (this._version < 0) {
                this.willReconcile(version);
                this._version = version;
                this.onReconcileInlets(version);
                this.onReconcile(version);
                this.onReconcileOutlets(version);
                this.didReconcile(version);
            }
        };
        AbstractRecordStreamlet.prototype.getInput = function (inlet, orElse) {
            if (typeof inlet === "string") {
                inlet = this.inlet(inlet);
            }
            var object;
            if (inlet !== null) {
                var input = inlet.input();
                if (input !== null) {
                    object = input.get();
                }
            }
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        AbstractRecordStreamlet.prototype.castInput = function (inlet, form, orElse) {
            var input = this.getInput(inlet);
            var object;
            if (input !== void 0) {
                object = form.cast(input);
            }
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        AbstractRecordStreamlet.prototype.coerceInput = function (inlet, form, orElse) {
            var input = this.getInput(inlet);
            var object;
            if (input !== void 0) {
                object = form.cast(input);
            }
            if (object === void 0) {
                object = form.unit();
            }
            if (object === void 0) {
                object = orElse;
            }
            return object;
        };
        AbstractRecordStreamlet.prototype.getOutput = function (outlet) {
            return void 0;
        };
        AbstractRecordStreamlet.prototype.disconnectInputs = function () {
            AbstractStreamlet.disconnectInputs(this, this.streamletClass());
        };
        AbstractRecordStreamlet.prototype.disconnectOutputs = function () {
            AbstractStreamlet.disconnectOutputs(this, this.streamletClass());
        };
        AbstractRecordStreamlet.prototype.willInvalidateInlet = function (inlet) {
        };
        AbstractRecordStreamlet.prototype.didInvalidateInlet = function (inlet) {
            this.invalidate();
        };
        AbstractRecordStreamlet.prototype.willReconcileInlet = function (inlet, version) {
        };
        AbstractRecordStreamlet.prototype.didReconcileInlet = function (inlet, version) {
            this.reconcile(version);
        };
        AbstractRecordStreamlet.prototype.willInvalidateOutlet = function (outlet) {
        };
        AbstractRecordStreamlet.prototype.didInvalidateOutlet = function (outlet) {
        };
        AbstractRecordStreamlet.prototype.willReconcileOutlet = function (outlet, version) {
        };
        AbstractRecordStreamlet.prototype.didReconcileOutlet = function (outlet, version) {
        };
        AbstractRecordStreamlet.prototype.willInvalidate = function () {
        };
        AbstractRecordStreamlet.prototype.onInvalidate = function () {
        };
        AbstractRecordStreamlet.prototype.didInvalidate = function () {
        };
        AbstractRecordStreamlet.prototype.onInvalidateOutlets = function () {
            AbstractStreamlet.invalidateOutlets(this, this.streamletClass());
        };
        AbstractRecordStreamlet.prototype.willReconcile = function (version) {
        };
        AbstractRecordStreamlet.prototype.onReconcileInlets = function (version) {
            AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());
        };
        AbstractRecordStreamlet.prototype.onReconcile = function (version) {
        };
        AbstractRecordStreamlet.prototype.onReconcileOutlets = function (version) {
            AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());
        };
        AbstractRecordStreamlet.prototype.didReconcile = function (version) {
        };
        return AbstractRecordStreamlet;
    }(RecordStreamlet));

    var RecordFieldUpdater = (function (_super) {
        __extends(RecordFieldUpdater, _super);
        function RecordFieldUpdater(record, key) {
            var _this = _super.call(this) || this;
            _this._record = record;
            _this._key = key;
            return _this;
        }
        RecordFieldUpdater.prototype.onInvalidateOutput = function () {
            if (RecordOutlet.is(this._record)) {
                this._record.invalidateInputKey(this._key, 0);
            }
        };
        RecordFieldUpdater.prototype.onReconcileOutput = function (version) {
            if (this._input !== null) {
                var value = this._input.get();
                if (value !== void 0) {
                    this._record.set(this._key, value);
                }
                else {
                    this._record.delete(this._key);
                }
            }
        };
        return RecordFieldUpdater;
    }(AbstractInlet));

    var Transmuter = (function () {
        function Transmuter() {
        }
        Transmuter.system = function () {
            return null;
        };
        return Transmuter;
    }());

    var RecordModel = (function (_super) {
        __extends(RecordModel, _super);
        function RecordModel(state) {
            if (state === void 0) { state = Record.create(); }
            var _this = _super.call(this) || this;
            _this._state = state;
            _this._fieldUpdaters = new BTree();
            return _this;
        }
        RecordModel.prototype.isEmpty = function () {
            return this._state.isEmpty();
        };
        RecordModel.prototype.isArray = function () {
            return this._state.isArray();
        };
        RecordModel.prototype.isObject = function () {
            return this._state.isObject();
        };
        Object.defineProperty(RecordModel.prototype, "length", {
            get: function () {
                return this._state.length;
            },
            enumerable: true,
            configurable: true
        });
        RecordModel.prototype.fieldCount = function () {
            return this._state.fieldCount();
        };
        RecordModel.prototype.valueCount = function () {
            return this._state.valueCount();
        };
        RecordModel.prototype.has = function (key) {
            if (this._state.has(key)) {
                return true;
            }
            else {
                var scope = this.streamletScope();
                return scope instanceof Record ? scope.has(key) : false;
            }
        };
        RecordModel.prototype.hasOwn = function (key) {
            return this._state.has(key);
        };
        RecordModel.prototype.indexOf = function (item, index) {
            return this._state.indexOf(item, index);
        };
        RecordModel.prototype.lastIndexOf = function (item, index) {
            if (index === void 0) { index = 0; }
            return this._state.lastIndexOf(item, index);
        };
        RecordModel.prototype.get = function (key) {
            if (key === void 0) {
                return this;
            }
            else {
                key = Value.fromAny(key);
                var value = this._state.get(key);
                if (!value.isDefined()) {
                    var scope = this.streamletScope();
                    if (scope instanceof Record) {
                        value = scope.get(key);
                    }
                }
                return value;
            }
        };
        RecordModel.prototype.getAttr = function (key) {
            key = Text.fromAny(key);
            var value = this._state.getAttr(key);
            if (!value.isDefined()) {
                var scope = this.streamletScope();
                if (scope instanceof Record) {
                    value = scope.getAttr(key);
                }
            }
            return value;
        };
        RecordModel.prototype.getSlot = function (key) {
            key = Value.fromAny(key);
            var value = this._state.getSlot(key);
            if (!value.isDefined()) {
                var scope = this.streamletScope();
                if (scope instanceof Record) {
                    value = scope.getSlot(key);
                }
            }
            return value;
        };
        RecordModel.prototype.getField = function (key) {
            key = Value.fromAny(key);
            var field = this._state.getField(key);
            if (field === void 0) {
                var scope = this.streamletScope();
                if (scope instanceof Record) {
                    field = scope.getField(key);
                }
            }
            return field;
        };
        RecordModel.prototype.getItem = function (index) {
            return this._state.getItem(index);
        };
        RecordModel.prototype.bindValue = function (key, expr) {
            var fieldUpdater = new RecordFieldUpdater(this, key);
            var valueInput = RecordOutlet.Dataflow.compile(expr, this);
            fieldUpdater.bindInput(valueInput);
            this._fieldUpdaters = this._fieldUpdaters.updated(key, fieldUpdater);
        };
        RecordModel.prototype.set = function (key, newValue) {
            key = Value.fromAny(key);
            if (!this._state.has(key)) {
                var scope = this.streamletScope();
                if (scope instanceof Record && scope.has(key)) {
                    scope.set(key, newValue);
                }
                else {
                    this._state.set(key, newValue);
                }
            }
            else {
                this._state.set(key, newValue);
            }
            this.invalidateInputKey(key, 0);
            return this;
        };
        RecordModel.prototype.setAttr = function (key, newValue) {
            key = Text.fromAny(key);
            if (!this._state.has(key)) {
                var scope = this.streamletScope();
                if (scope instanceof Record && scope.has(key)) {
                    scope.setAttr(key, newValue);
                }
                else {
                    this._state.setAttr(key, newValue);
                }
            }
            else {
                this._state.setAttr(key, newValue);
            }
            this.invalidateInputKey(key, 0);
            return this;
        };
        RecordModel.prototype.setSlot = function (key, newValue) {
            key = Value.fromAny(key);
            if (!this._state.has(key)) {
                var scope = this.streamletScope();
                if (scope instanceof Record && scope.has(key)) {
                    scope.setSlot(key, newValue);
                }
                else {
                    this._state.setSlot(key, newValue);
                }
            }
            else {
                this._state.setSlot(key, newValue);
            }
            this.invalidateInputKey(key, 0);
            return this;
        };
        RecordModel.prototype.setItem = function (index, newItem) {
            var oldItem = this._state.getItem(index);
            newItem = Item.fromAny(newItem);
            this._state.setItem(index, newItem);
            if (oldItem instanceof Field && newItem instanceof Field) {
                if (oldItem.key.equals(newItem.key)) {
                    this.invalidateInputKey(oldItem.key, 0);
                }
                else {
                    this.invalidateInputKey(oldItem.key, 1);
                    this.invalidateInputKey(newItem.key, 0);
                }
            }
            else if (oldItem instanceof Field) {
                this.invalidateInputKey(oldItem.key, 1);
            }
            else if (newItem instanceof Field) {
                this.invalidateInputKey(newItem.key, 0);
            }
            else {
                this.invalidateInput();
            }
            return this;
        };
        RecordModel.prototype.push = function () {
            var newItems = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newItems[_i] = arguments[_i];
            }
            var i = this._state.length;
            var n = this._state.push.apply(this._state, arguments);
            while (i < n) {
                var newItem = this._state.get(i);
                if (newItem instanceof Field) {
                    this.invalidateInputKey(newItem.key, 0);
                }
                i += 1;
            }
            return n;
        };
        RecordModel.prototype.splice = function (start, deleteCount) {
            if (deleteCount === void 0) { deleteCount = 0; }
            var newItems = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newItems[_i - 2] = arguments[_i];
            }
            var n = this._state.length;
            if (start < 0) {
                start = n + start;
            }
            start = Math.max(0, start);
            deleteCount = Math.max(0, deleteCount);
            var deleted = this._state.splice.apply(this._state, arguments);
            for (var i = 0; i < deleted.length; i += 1) {
                var oldItem = deleted[i];
                if (oldItem instanceof Field) {
                    this.invalidateInputKey(oldItem.key, 1);
                }
            }
            for (var i = start; i < start + newItems.length; i += 1) {
                var newItem = this._state.get(i);
                if (newItem instanceof Field) {
                    this.invalidateInputKey(newItem.key, 0);
                }
            }
            return deleted;
        };
        RecordModel.prototype.delete = function (key) {
            var oldItem = this._state.delete(key);
            if (oldItem instanceof Field) {
                this.invalidateInputKey(oldItem.key, 1);
            }
            return oldItem;
        };
        RecordModel.prototype.clear = function () {
            var oldState = this._state.branch();
            this._state.clear();
            oldState.forEach(function (oldItem) {
                if (oldItem instanceof Field) {
                    this.invalidateInputKey(oldItem.key, 1);
                }
            }, this);
        };
        RecordModel.prototype.forEach = function (callback, thisArg) {
            return this._state.forEach(callback, thisArg);
        };
        RecordModel.prototype.keyIterator = function () {
            throw new Error();
        };
        RecordModel.prototype.disconnectInputs = function () {
            var fieldUpdaters = this._fieldUpdaters;
            if (!fieldUpdaters.isEmpty()) {
                this._fieldUpdaters = new BTree();
                fieldUpdaters.forEach(function (key, inlet) {
                    inlet.disconnectInputs();
                }, this);
            }
        };
        RecordModel.prototype.memoize = function () {
            return this;
        };
        RecordModel.prototype.materialize = function (record) {
            record.forEach(function (item) {
                this.materializeItem(item);
            }, this);
        };
        RecordModel.prototype.materializeItem = function (item) {
            if (item instanceof Field) {
                this.materializeField(item);
            }
            else {
                this.materializeValue(item);
            }
        };
        RecordModel.prototype.materializeField = function (field) {
            var value = field.value;
            if (value instanceof RecordStreamlet) {
                value.setStreamletScope(this);
                this._state.push(field);
            }
            else if (value instanceof Record) {
                var child = new RecordOutlet.Scope(this);
                child.materialize(value);
                this._state.push(field.updatedValue(child));
            }
            else {
                this._state.push(field);
            }
        };
        RecordModel.prototype.materializeValue = function (value) {
            if (value instanceof RecordStreamlet) {
                value.setStreamletScope(this);
                this._state.push(value);
            }
            else if (value instanceof Record) {
                var child = new RecordOutlet.Scope(this);
                child.materialize(value);
                this._state.push(child);
            }
            else {
                this._state.push(value);
            }
        };
        RecordModel.prototype.compile = function (record) {
            record.forEach(function (item, index) {
                this.compileItem(item, index);
            }, this);
        };
        RecordModel.prototype.compileItem = function (item, index) {
            if (item instanceof Field) {
                this.compileField(item, index);
            }
            else {
                this.compileValue(item, index);
            }
        };
        RecordModel.prototype.compileField = function (field, index) {
            var key = field.key;
            var value = field.value;
            if (!key.isConstant()) ;
            else if (!value.isConstant()) {
                if (value instanceof RecordStreamlet) {
                    value.compile();
                    this.invalidateInputKey(key, 0);
                }
                else if (value instanceof Record) {
                    this._state.getItem(index).toValue().compile(value);
                    this.invalidateInputKey(key, 0);
                }
                else {
                    field.setValue(Value.extant());
                    this.bindValue(key, value);
                }
            }
            else {
                this.invalidateInputKey(key, 0);
            }
        };
        RecordModel.prototype.compileValue = function (value, index) {
            if (value instanceof RecordStreamlet) {
                value.compile();
            }
            else if (value instanceof Record) {
                this._state.getItem(index).compile(value);
            }
            else if (!value.isConstant()) ;
        };
        RecordModel.prototype.transmute = function (transmuter) {
            if (transmuter === void 0) { transmuter = Transmuter.system(); }
            this.forEach(function (oldItem, index) {
                var newItem = this.transmuteItem(oldItem, transmuter);
                if (oldItem !== newItem) {
                    this.setItem(index, newItem);
                }
            }, this);
        };
        RecordModel.prototype.transmuteItem = function (item, transmuter) {
            if (item instanceof Field) {
                return this.transmuteField(item, transmuter);
            }
            else {
                return this.transmuteValue(item, transmuter);
            }
        };
        RecordModel.prototype.transmuteField = function (field, transmuter) {
            var oldValue = field.value;
            var newValue = this.transmuteValue(oldValue, transmuter);
            if (oldValue !== newValue) {
                return field.updatedValue(newValue);
            }
            else {
                return field;
            }
        };
        RecordModel.prototype.transmuteValue = function (oldValue, transmuter) {
            if (oldValue instanceof RecordModel) {
                var newValue = this.transmuteModel(oldValue);
                if (oldValue === newValue && transmuter) {
                    newValue = transmuter.transmute(oldValue);
                }
                return newValue;
            }
            else {
                return oldValue;
            }
        };
        RecordModel.prototype.transmuteModel = function (model) {
            var scope = this.streamletScope();
            if (scope instanceof RecordModel) {
                return scope.transmuteModel(model);
            }
            else {
                return model;
            }
        };
        RecordModel.from = function (record) {
            var model = new RecordModel();
            model.materialize(record);
            model.compile(record);
            return model;
        };
        RecordModel.of = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return RecordModel.from(Record.of.apply(void 0, arguments));
        };
        RecordModel.globalScope = function () {
            var model = new RecordModel();
            model.materializeField(Slot.of("math", MathModule.scope().branch()));
            return model;
        };
        return RecordModel;
    }(AbstractRecordOutlet));
    RecordOutlet.Model = RecordModel;

    var RecordScope = (function (_super) {
        __extends(RecordScope, _super);
        function RecordScope(scope, state) {
            var _this = _super.call(this, state) || this;
            _this.scope = scope;
            return _this;
        }
        RecordScope.prototype.streamletScope = function () {
            return this.scope;
        };
        RecordScope.from = function (record) {
            var scope = new RecordScope(RecordScope.globalScope());
            scope.materialize(record);
            scope.compile(record);
            return scope;
        };
        RecordScope.of = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return RecordScope.from(Record.of.apply(void 0, arguments));
        };
        return RecordScope;
    }(RecordModel));
    RecordOutlet.Scope = RecordScope;

    var GetOutlet = (function (_super) {
        __extends(GetOutlet, _super);
        function GetOutlet() {
            var _this = _super.call(this) || this;
            _this._keyInlet = new OutletInlet(_this);
            _this._mapInlet = new OutletMapInlet(_this);
            return _this;
        }
        GetOutlet.prototype.keyInlet = function () {
            return this._keyInlet;
        };
        GetOutlet.prototype.mapInlet = function () {
            return this._mapInlet;
        };
        GetOutlet.prototype.get = function () {
            var keyInput = this._keyInlet.input();
            if (keyInput !== null) {
                var key = keyInput.get();
                if (key !== void 0) {
                    var mapInput = this._mapInlet.input();
                    if (mapInput !== null) {
                        var value = mapInput.get(key);
                        if (value !== void 0) {
                            return value;
                        }
                    }
                }
            }
            return Value.absent();
        };
        return GetOutlet;
    }(AbstractOutlet));

    var BinaryOutlet = (function (_super) {
        __extends(BinaryOutlet, _super);
        function BinaryOutlet() {
            var _this = _super.call(this) || this;
            _this._operand1Inlet = new OutletInlet(_this);
            _this._operand2Inlet = new OutletInlet(_this);
            return _this;
        }
        BinaryOutlet.prototype.operand1Inlet = function () {
            return this._operand1Inlet;
        };
        BinaryOutlet.prototype.operand2Inlet = function () {
            return this._operand2Inlet;
        };
        BinaryOutlet.prototype.get = function () {
            var operand1Input = this._operand1Inlet.input();
            var operand2Input = this._operand2Inlet.input();
            if (operand1Input !== null && operand2Input !== null) {
                var argument1 = operand1Input.get();
                var argument2 = operand2Input.get();
                if (argument1 !== void 0 && argument2 !== void 0) {
                    var result = this.evaluate(argument1, argument2);
                    return result.toValue();
                }
            }
            return Value.absent();
        };
        return BinaryOutlet;
    }(AbstractOutlet));

    var UnaryOutlet = (function (_super) {
        __extends(UnaryOutlet, _super);
        function UnaryOutlet() {
            var _this = _super.call(this) || this;
            _this._operandInlet = new OutletInlet(_this);
            return _this;
        }
        UnaryOutlet.prototype.operandInlet = function () {
            return this._operandInlet;
        };
        UnaryOutlet.prototype.get = function () {
            var operandInput = this._operandInlet.input();
            if (operandInput !== null) {
                var argument = operandInput.get();
                if (argument !== void 0) {
                    var result = this.evaluate(argument);
                    return result.toValue();
                }
            }
            return Value.absent();
        };
        return UnaryOutlet;
    }(AbstractOutlet));

    var ConditionalOutlet = (function (_super) {
        __extends(ConditionalOutlet, _super);
        function ConditionalOutlet() {
            var _this = _super.call(this) || this;
            _this._ifInlet = new OutletInlet(_this);
            _this._thenInlet = new OutletInlet(_this);
            _this._elseInlet = new OutletInlet(_this);
            return _this;
        }
        ConditionalOutlet.prototype.ifInlet = function () {
            return this._ifInlet;
        };
        ConditionalOutlet.prototype.thenInlet = function () {
            return this._thenInlet;
        };
        ConditionalOutlet.prototype.elseInlet = function () {
            return this._elseInlet;
        };
        ConditionalOutlet.prototype.get = function () {
            var ifInput = this._ifInlet.input();
            if (ifInput !== null) {
                var ifTerm = ifInput.get();
                if (ifTerm !== void 0) {
                    if (ifTerm.booleanValue(false)) {
                        var thenInput = this._thenInlet.input();
                        if (thenInput !== null) {
                            var thenTerm = thenInput.get();
                            if (thenTerm !== void 0) {
                                return thenTerm;
                            }
                        }
                    }
                    else {
                        var elseInput = this._elseInlet.input();
                        if (elseInput !== null) {
                            var elseTerm = elseInput.get();
                            if (elseTerm !== void 0) {
                                return elseTerm;
                            }
                        }
                    }
                }
            }
            return Value.absent();
        };
        return ConditionalOutlet;
    }(AbstractOutlet));

    var OrOutlet = (function (_super) {
        __extends(OrOutlet, _super);
        function OrOutlet() {
            var _this = _super.call(this) || this;
            _this._operand1Inlet = new OutletInlet(_this);
            _this._operand2Inlet = new OutletInlet(_this);
            return _this;
        }
        OrOutlet.prototype.operand1Inlet = function () {
            return this._operand1Inlet;
        };
        OrOutlet.prototype.operand2Inlet = function () {
            return this._operand2Inlet;
        };
        OrOutlet.prototype.get = function () {
            var operand1Input = this._operand1Inlet.input();
            var argument1 = operand1Input !== null ? operand1Input.get() : void 0;
            if (argument1 !== void 0 && argument1.booleanValue(false)) {
                return argument1;
            }
            var operand2Input = this._operand2Inlet.input();
            var argument2 = operand2Input !== null ? operand2Input.get() : void 0;
            if (argument2 !== void 0) {
                return argument2;
            }
            return Value.absent();
        };
        return OrOutlet;
    }(AbstractOutlet));

    var AndOutlet = (function (_super) {
        __extends(AndOutlet, _super);
        function AndOutlet() {
            var _this = _super.call(this) || this;
            _this._operand1Inlet = new OutletInlet(_this);
            _this._operand2Inlet = new OutletInlet(_this);
            return _this;
        }
        AndOutlet.prototype.operand1Inlet = function () {
            return this._operand1Inlet;
        };
        AndOutlet.prototype.operand2Inlet = function () {
            return this._operand2Inlet;
        };
        AndOutlet.prototype.get = function () {
            var operand1Input = this._operand1Inlet.input();
            var argument1 = operand1Input !== null ? operand1Input.get() : void 0;
            if (argument1 !== void 0) {
                if (argument1.booleanValue(false)) {
                    var operand2Input = this._operand2Inlet.input();
                    var argument2 = operand2Input !== null ? operand2Input.get() : void 0;
                    if (argument2 !== void 0) {
                        return argument2;
                    }
                }
                return argument1;
            }
            return Value.absent();
        };
        return AndOutlet;
    }(AbstractOutlet));

    var BitwiseOrOutlet = (function (_super) {
        __extends(BitwiseOrOutlet, _super);
        function BitwiseOrOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BitwiseOrOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.bitwiseOr(argument2);
        };
        return BitwiseOrOutlet;
    }(BinaryOutlet));

    var BitwiseXorOutlet = (function (_super) {
        __extends(BitwiseXorOutlet, _super);
        function BitwiseXorOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BitwiseXorOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.bitwiseXor(argument2);
        };
        return BitwiseXorOutlet;
    }(BinaryOutlet));

    var BitwiseAndOutlet = (function (_super) {
        __extends(BitwiseAndOutlet, _super);
        function BitwiseAndOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BitwiseAndOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.bitwiseAnd(argument2);
        };
        return BitwiseAndOutlet;
    }(BinaryOutlet));

    var LtOutlet = (function (_super) {
        __extends(LtOutlet, _super);
        function LtOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LtOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.lt(argument2);
        };
        return LtOutlet;
    }(BinaryOutlet));

    var LeOutlet = (function (_super) {
        __extends(LeOutlet, _super);
        function LeOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LeOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.le(argument2);
        };
        return LeOutlet;
    }(BinaryOutlet));

    var EqOutlet = (function (_super) {
        __extends(EqOutlet, _super);
        function EqOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EqOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.eq(argument2);
        };
        return EqOutlet;
    }(BinaryOutlet));

    var NeOutlet = (function (_super) {
        __extends(NeOutlet, _super);
        function NeOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NeOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.ne(argument2);
        };
        return NeOutlet;
    }(BinaryOutlet));

    var GeOutlet = (function (_super) {
        __extends(GeOutlet, _super);
        function GeOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GeOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.ge(argument2);
        };
        return GeOutlet;
    }(BinaryOutlet));

    var GtOutlet = (function (_super) {
        __extends(GtOutlet, _super);
        function GtOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GtOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.gt(argument2);
        };
        return GtOutlet;
    }(BinaryOutlet));

    var PlusOutlet = (function (_super) {
        __extends(PlusOutlet, _super);
        function PlusOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PlusOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.plus(argument2);
        };
        return PlusOutlet;
    }(BinaryOutlet));

    var MinusOutlet = (function (_super) {
        __extends(MinusOutlet, _super);
        function MinusOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MinusOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.minus(argument2);
        };
        return MinusOutlet;
    }(BinaryOutlet));

    var TimesOutlet = (function (_super) {
        __extends(TimesOutlet, _super);
        function TimesOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimesOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.times(argument2);
        };
        return TimesOutlet;
    }(BinaryOutlet));

    var DivideOutlet = (function (_super) {
        __extends(DivideOutlet, _super);
        function DivideOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DivideOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.divide(argument2);
        };
        return DivideOutlet;
    }(BinaryOutlet));

    var ModuloOutlet = (function (_super) {
        __extends(ModuloOutlet, _super);
        function ModuloOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ModuloOutlet.prototype.evaluate = function (argument1, argument2) {
            return argument1.modulo(argument2);
        };
        return ModuloOutlet;
    }(BinaryOutlet));

    var NotOutlet = (function (_super) {
        __extends(NotOutlet, _super);
        function NotOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NotOutlet.prototype.evaluate = function (argument) {
            return argument.not();
        };
        return NotOutlet;
    }(UnaryOutlet));

    var BitwiseNotOutlet = (function (_super) {
        __extends(BitwiseNotOutlet, _super);
        function BitwiseNotOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BitwiseNotOutlet.prototype.evaluate = function (argument) {
            return argument.bitwiseNot();
        };
        return BitwiseNotOutlet;
    }(UnaryOutlet));

    var NegativeOutlet = (function (_super) {
        __extends(NegativeOutlet, _super);
        function NegativeOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NegativeOutlet.prototype.evaluate = function (argument) {
            return argument.negative();
        };
        return NegativeOutlet;
    }(UnaryOutlet));

    var PositiveOutlet = (function (_super) {
        __extends(PositiveOutlet, _super);
        function PositiveOutlet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PositiveOutlet.prototype.evaluate = function (argument) {
            return argument.positive();
        };
        return PositiveOutlet;
    }(UnaryOutlet));

    var InvokeOutlet = (function (_super) {
        __extends(InvokeOutlet, _super);
        function InvokeOutlet(scope) {
            var _this = _super.call(this) || this;
            _this._scope = scope;
            _this._funcInlet = new OutletInlet(_this);
            _this._argsInlet = new OutletInlet(_this);
            return _this;
        }
        InvokeOutlet.prototype.funcInlet = function () {
            return this._funcInlet;
        };
        InvokeOutlet.prototype.argsInlet = function () {
            return this._argsInlet;
        };
        InvokeOutlet.prototype.get = function () {
            var funcInput = this._funcInlet.input();
            var argsInput = this._argsInlet.input();
            if (funcInput !== null && argsInput !== null) {
                var func = funcInput.get();
                if (func instanceof Func) {
                    var args = argsInput.get();
                    if (args !== void 0) {
                        var interpreter = new Interpreter();
                        interpreter.pushScope(this._scope);
                        var result = func.invoke(args, interpreter, void 0);
                        return result.toValue();
                    }
                }
            }
            return Value.absent();
        };
        return InvokeOutlet;
    }(AbstractOutlet));

    var Dataflow = (function () {
        function Dataflow() {
        }
        Dataflow.compile = function (expr, scope) {
            if (scope instanceof KeyOutlet) {
                var value = scope.get();
                if (Outlet.is(value)) {
                    scope = value;
                }
            }
            if (expr.isConstant()) {
                return new ValueInput(expr);
            }
            else if (expr instanceof Selector) {
                return Dataflow.compileSelector(expr, scope);
            }
            else if (expr instanceof Operator) {
                return Dataflow.compileOperator(expr, scope);
            }
            throw new TypeError("" + expr);
        };
        Dataflow.compileSelector = function (selector, scope) {
            if (selector instanceof IdentitySelector) {
                return Dataflow.compileIdentitySelector(scope);
            }
            else if (selector instanceof GetSelector) {
                return Dataflow.compileGetSelector(selector, scope);
            }
            else if (selector instanceof GetAttrSelector) {
                return Dataflow.compileGetAttrSelector(selector, scope);
            }
            else if (selector instanceof GetItemSelector) {
                return Dataflow.compileGetItemSelector(selector, scope);
            }
            else if (selector instanceof KeysSelector) {
                return Dataflow.compileKeysSelector(scope);
            }
            else if (selector instanceof ValuesSelector) {
                return Dataflow.compileValuesSelector(scope);
            }
            else if (selector instanceof ChildrenSelector) {
                return Dataflow.compileChildrenSelector(scope);
            }
            else if (selector instanceof DescendantsSelector) {
                return Dataflow.compileDescendantsSelector(scope);
            }
            else if (selector instanceof FilterSelector) {
                return Dataflow.compileFilterSelector(selector, scope);
            }
            throw new TypeError("" + selector);
        };
        Dataflow.compileIdentitySelector = function (scope) {
            return scope;
        };
        Dataflow.compileGetSelector = function (selector, scope) {
            var key = selector.accessor();
            if (key.isConstant()) {
                if (RecordOutlet.is(scope)) {
                    var outlet = scope.outlet(key);
                    if (outlet !== null) {
                        return Dataflow.compile(selector.then(), outlet);
                    }
                }
                else if (StreamletScope.is(scope)) {
                    var name_1 = key.stringValue(void 0);
                    if (name_1 !== void 0) {
                        var outlet = scope.outlet(name_1);
                        if (outlet !== null) {
                            return Dataflow.compile(selector.then(), outlet);
                        }
                    }
                }
            }
            else {
                var getOutlet = new GetOutlet();
                var outlet = Dataflow.compile(key, scope);
                getOutlet.keyInlet().bindInput(outlet);
                getOutlet.mapInlet().bindInput(scope);
                return getOutlet;
            }
            return null;
        };
        Dataflow.compileGetAttrSelector = function (selector, scope) {
            throw new Error();
        };
        Dataflow.compileGetItemSelector = function (selector, scope) {
            throw new Error();
        };
        Dataflow.compileKeysSelector = function (scope) {
            throw new Error();
        };
        Dataflow.compileValuesSelector = function (scope) {
            throw new Error();
        };
        Dataflow.compileChildrenSelector = function (scope) {
            throw new Error();
        };
        Dataflow.compileDescendantsSelector = function (scope) {
            throw new Error();
        };
        Dataflow.compileFilterSelector = function (selector, scope) {
            throw new Error();
        };
        Dataflow.compileOperator = function (operator, scope) {
            if (operator instanceof ConditionalOperator) {
                return Dataflow.compileConditionalOperator(operator, scope);
            }
            else if (operator instanceof BinaryOperator) {
                return Dataflow.compileBinaryOperator(operator, scope);
            }
            else if (operator instanceof UnaryOperator) {
                return Dataflow.compileUnaryOperator(operator, scope);
            }
            else if (operator instanceof InvokeOperator) {
                return Dataflow.compileInvokeOperator(operator, scope);
            }
            throw new TypeError("" + operator);
        };
        Dataflow.compileConditionalOperator = function (operator, scope) {
            var outlet = new ConditionalOutlet();
            var ifTerm = operator.ifTerm().toValue();
            var thenTerm = operator.thenTerm().toValue();
            var elseTerm = operator.elseTerm().toValue();
            var ifOutlet = Dataflow.compile(ifTerm, scope);
            var thenOutlet = Dataflow.compile(thenTerm, scope);
            var elseOutlet = Dataflow.compile(elseTerm, scope);
            outlet.ifInlet().bindInput(ifOutlet);
            outlet.thenInlet().bindInput(thenOutlet);
            outlet.elseInlet().bindInput(elseOutlet);
            return outlet;
        };
        Dataflow.compileBinaryOperator = function (operator, scope) {
            if (operator instanceof OrOperator) {
                return Dataflow.compileOrOperator(operator, scope);
            }
            else if (operator instanceof AndOperator) {
                return Dataflow.compileAndOperator(operator, scope);
            }
            else if (operator instanceof BitwiseOrOperator) {
                return Dataflow.compileBitwiseOrOperator(operator, scope);
            }
            else if (operator instanceof BitwiseXorOperator) {
                return Dataflow.compileBitwiseXorOperator(operator, scope);
            }
            else if (operator instanceof BitwiseAndOperator) {
                return Dataflow.compileBitwiseAndOperator(operator, scope);
            }
            else if (operator instanceof LtOperator) {
                return Dataflow.compileLtOperator(operator, scope);
            }
            else if (operator instanceof LeOperator) {
                return Dataflow.compileLeOperator(operator, scope);
            }
            else if (operator instanceof EqOperator) {
                return Dataflow.compileEqOperator(operator, scope);
            }
            else if (operator instanceof NeOperator) {
                return Dataflow.compileNeOperator(operator, scope);
            }
            else if (operator instanceof GeOperator) {
                return Dataflow.compileGeOperator(operator, scope);
            }
            else if (operator instanceof GtOperator) {
                return Dataflow.compileGtOperator(operator, scope);
            }
            else if (operator instanceof PlusOperator) {
                return Dataflow.compilePlusOperator(operator, scope);
            }
            else if (operator instanceof MinusOperator) {
                return Dataflow.compileMinusOperator(operator, scope);
            }
            else if (operator instanceof TimesOperator) {
                return Dataflow.compileTimesOperator(operator, scope);
            }
            else if (operator instanceof DivideOperator) {
                return Dataflow.compileDivideOperator(operator, scope);
            }
            else if (operator instanceof ModuloOperator) {
                return Dataflow.compileModuloOperator(operator, scope);
            }
            throw new TypeError("" + operator);
        };
        Dataflow.compileBinaryOutlet = function (operator, outlet, scope) {
            var operand1 = operator.operand1().toValue();
            var operand2 = operator.operand2().toValue();
            var operand1Outlet = Dataflow.compile(operand1, scope);
            var operand2Outlet = Dataflow.compile(operand2, scope);
            outlet.operand1Inlet().bindInput(operand1Outlet);
            outlet.operand2Inlet().bindInput(operand2Outlet);
            return outlet;
        };
        Dataflow.compileOrOperator = function (operator, scope) {
            var outlet = new OrOutlet();
            var operand1 = operator.operand1().toValue();
            var operand2 = operator.operand2().toValue();
            var operand1Outlet = Dataflow.compile(operand1, scope);
            var operand2Outlet = Dataflow.compile(operand2, scope);
            outlet.operand1Inlet().bindInput(operand1Outlet);
            outlet.operand2Inlet().bindInput(operand2Outlet);
            return outlet;
        };
        Dataflow.compileAndOperator = function (operator, scope) {
            var outlet = new AndOutlet();
            var operand1 = operator.operand1().toValue();
            var operand2 = operator.operand2().toValue();
            var operand1Outlet = Dataflow.compile(operand1, scope);
            var operand2Outlet = Dataflow.compile(operand2, scope);
            outlet.operand1Inlet().bindInput(operand1Outlet);
            outlet.operand2Inlet().bindInput(operand2Outlet);
            return outlet;
        };
        Dataflow.compileBitwiseOrOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new BitwiseOrOutlet(), scope);
        };
        Dataflow.compileBitwiseXorOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new BitwiseXorOutlet(), scope);
        };
        Dataflow.compileBitwiseAndOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new BitwiseAndOutlet(), scope);
        };
        Dataflow.compileLtOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new LtOutlet(), scope);
        };
        Dataflow.compileLeOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new LeOutlet(), scope);
        };
        Dataflow.compileEqOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new EqOutlet(), scope);
        };
        Dataflow.compileNeOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new NeOutlet(), scope);
        };
        Dataflow.compileGeOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new GeOutlet(), scope);
        };
        Dataflow.compileGtOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new GtOutlet(), scope);
        };
        Dataflow.compilePlusOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new PlusOutlet(), scope);
        };
        Dataflow.compileMinusOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new MinusOutlet(), scope);
        };
        Dataflow.compileTimesOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new TimesOutlet(), scope);
        };
        Dataflow.compileDivideOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new DivideOutlet(), scope);
        };
        Dataflow.compileModuloOperator = function (operator, scope) {
            return Dataflow.compileBinaryOutlet(operator, new ModuloOutlet(), scope);
        };
        Dataflow.compileUnaryOperator = function (operator, scope) {
            if (operator instanceof NotOperator) {
                return Dataflow.compileNotOperator(operator, scope);
            }
            else if (operator instanceof BitwiseNotOperator) {
                return Dataflow.compileBitwiseNotOperator(operator, scope);
            }
            else if (operator instanceof NegativeOperator) {
                return Dataflow.compileNegativeOperator(operator, scope);
            }
            else if (operator instanceof PositiveOperator) {
                return Dataflow.compilePositiveOperator(operator, scope);
            }
            throw new TypeError("" + operator);
        };
        Dataflow.compileUnaryOutlet = function (operator, outlet, scope) {
            var operand = operator.operand().toValue();
            var operandOutlet = Dataflow.compile(operand, scope);
            outlet.operandInlet().bindInput(operandOutlet);
            return outlet;
        };
        Dataflow.compileNotOperator = function (operator, scope) {
            return Dataflow.compileUnaryOutlet(operator, new NotOutlet(), scope);
        };
        Dataflow.compileBitwiseNotOperator = function (operator, scope) {
            return Dataflow.compileUnaryOutlet(operator, new BitwiseNotOutlet(), scope);
        };
        Dataflow.compileNegativeOperator = function (operator, scope) {
            return Dataflow.compileUnaryOutlet(operator, new NegativeOutlet(), scope);
        };
        Dataflow.compilePositiveOperator = function (operator, scope) {
            return Dataflow.compileUnaryOutlet(operator, new PositiveOutlet(), scope);
        };
        Dataflow.compileInvokeOperator = function (operator, scope) {
            var func = operator.func();
            var args = operator.args();
            var invokeOutlet = new InvokeOutlet(scope);
            var funcOutlet = Dataflow.compile(func, scope);
            var argsOutlet = Dataflow.compile(args, scope);
            invokeOutlet.funcInlet().bindInput(funcOutlet);
            invokeOutlet.argsInlet().bindInput(argsOutlet);
            return invokeOutlet;
        };
        return Dataflow;
    }());
    RecordOutlet.Dataflow = Dataflow;

    var BlockParser = (function (_super) {
        __extends(BlockParser, _super);
        function BlockParser(recon, builder, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        BlockParser.prototype.feed = function (input) {
            return BlockParser.parse(input, this._recon, this._builder, this._keyParser, this._valueParser, this._step);
        };
        BlockParser.parse = function (input, recon, builder, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            block: do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 33 || c === 34 || c === 36 || c === 37
                            || c === 39 || c === 40 || c === 43 || c === 45
                            || c >= 48 && c <= 57 || c === 64
                            || c === 91 || c === 123 || c === 126
                            || Recon.isIdentStartChar(c)) {
                            builder = builder || recon.valueBuilder();
                            step = 2;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 7;
                        }
                        else {
                            if (builder) {
                                return Parser.done(builder.bind());
                            }
                            else {
                                return Parser.done(recon.absent());
                            }
                        }
                    }
                    else if (input.isDone()) {
                        if (builder) {
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.done(recon.absent());
                        }
                    }
                }
                if (step === 2) {
                    if (!keyParser) {
                        keyParser = recon.parseBlockExpression(input);
                    }
                    while (keyParser.isCont() && !input.isEmpty()) {
                        keyParser = keyParser.feed(input);
                    }
                    if (keyParser.isDone()) {
                        step = 3;
                    }
                    else if (keyParser.isError()) {
                        return keyParser;
                    }
                }
                if (step === 3) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 58) {
                            input = input.step();
                            step = 4;
                        }
                        else {
                            builder.push(recon.item(keyParser.bind()));
                            keyParser = void 0;
                            step = 6;
                        }
                    }
                    else if (input.isDone()) {
                        builder.push(recon.item(keyParser.bind()));
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 4) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 5;
                    }
                    else if (input.isDone()) {
                        builder.push(recon.slot(keyParser.bind()));
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 5) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
                        keyParser = void 0;
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 6) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44 || c === 59 || Recon.isNewline(c)) {
                            input = input.step();
                            step = 1;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 7;
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 7) {
                    while (input.isCont()) {
                        c = input.head();
                        if (!Recon.isNewline(c)) {
                            input = input.step();
                        }
                        else {
                            step = 1;
                            continue block;
                        }
                    }
                    if (input.isDone()) {
                        step = 1;
                        continue;
                    }
                }
                break;
            } while (true);
            return new BlockParser(recon, builder, keyParser, valueParser, step);
        };
        return BlockParser;
    }(Parser));

    var AttrParser = (function (_super) {
        __extends(AttrParser, _super);
        function AttrParser(recon, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        AttrParser.prototype.feed = function (input) {
            return AttrParser.parse(input, this._recon, this._keyParser, this._valueParser, this._step);
        };
        AttrParser.parse = function (input, recon, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 64) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(64, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(64, input));
                }
            }
            if (step === 2) {
                if (!keyParser) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 34 || c === 39) {
                            keyParser = recon.parseString(input);
                        }
                        else if (Recon.isIdentStartChar(c)) {
                            keyParser = recon.parseIdent(input);
                        }
                        else {
                            return Parser.error(Diagnostic.expected("attribute name", input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected("attribute name", input));
                    }
                }
                else {
                    keyParser = keyParser.feed(input);
                }
                if (keyParser) {
                    if (keyParser.isDone()) {
                        step = 3;
                    }
                    else if (keyParser.isError()) {
                        return keyParser.asError();
                    }
                }
            }
            if (step === 3) {
                if (input.isCont() && input.head() === 40) {
                    input = input.step();
                    step = 4;
                }
                else if (!input.isEmpty()) {
                    return Parser.done(recon.attr(keyParser.bind()));
                }
            }
            if (step === 4) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        return Parser.done(recon.attr(keyParser.bind()));
                    }
                    else {
                        step = 5;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(")", input));
                }
            }
            if (step === 5) {
                if (!valueParser) {
                    valueParser = recon.parseBlock(input);
                }
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    step = 6;
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 6) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        return Parser.done(recon.attr(keyParser.bind(), valueParser.bind()));
                    }
                    else {
                        return Parser.error(Diagnostic.expected(")", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(")", input));
                }
            }
            return new AttrParser(recon, keyParser, valueParser, step);
        };
        return AttrParser;
    }(Parser));

    var BlockItemParser = (function (_super) {
        __extends(BlockItemParser, _super);
        function BlockItemParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        BlockItemParser.prototype.feed = function (input) {
            return BlockItemParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        BlockItemParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 64) {
                            fieldParser = recon.parseAttr(input);
                            step = 2;
                        }
                        else if (c === 123) {
                            builder = builder || recon.recordBuilder();
                            valueParser = recon.parseRecord(input, builder);
                            step = 5;
                        }
                        else if (c === 91) {
                            builder = builder || recon.recordBuilder();
                            valueParser = recon.parseMarkup(input, builder);
                            step = 5;
                        }
                        else if (Recon.isIdentStartChar(c)) {
                            valueParser = recon.parseIdent(input);
                            step = 4;
                        }
                        else if (c === 34 || c === 39) {
                            valueParser = recon.parseString(input);
                            step = 4;
                        }
                        else if (c === 45 || c >= 48 && c <= 57) {
                            valueParser = recon.parseNumber(input);
                            step = 4;
                        }
                        else if (c === 37) {
                            valueParser = recon.parseData(input);
                            step = 4;
                        }
                        else if (c === 36) {
                            valueParser = recon.parseSelector(input);
                            step = 4;
                        }
                        else if (!builder) {
                            return Parser.done(recon.extant());
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        if (!builder) {
                            return Parser.done(recon.extant());
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                }
                if (step === 2) {
                    while (fieldParser.isCont() && !input.isEmpty()) {
                        fieldParser = fieldParser.feed(input);
                    }
                    if (fieldParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(fieldParser.bind());
                        fieldParser = void 0;
                        step = 3;
                    }
                    else if (fieldParser.isError()) {
                        return fieldParser.asError();
                    }
                }
                if (step === 3) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 1;
                        continue;
                    }
                    else if (input.isDone()) {
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 4) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 5) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 6) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (input.head() === 64) {
                            step = 1;
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.done(builder.bind());
                    }
                }
                break;
            } while (true);
            return new BlockItemParser(recon, builder, fieldParser, valueParser, step);
        };
        return BlockItemParser;
    }(Parser));

    var InlineItemParser = (function (_super) {
        __extends(InlineItemParser, _super);
        function InlineItemParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        InlineItemParser.prototype.feed = function (input) {
            return InlineItemParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        InlineItemParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 64) {
                        fieldParser = recon.parseAttr(input);
                        step = 2;
                    }
                    else if (c === 123) {
                        if (builder) {
                            valueParser = recon.parseRecord(input, builder);
                            step = 5;
                        }
                        else {
                            valueParser = recon.parseRecord(input);
                            step = 4;
                        }
                    }
                    else if (c === 91) {
                        if (builder) {
                            valueParser = recon.parseMarkup(input, builder);
                            step = 5;
                        }
                        else {
                            valueParser = recon.parseMarkup(input);
                            step = 4;
                        }
                    }
                    else if (!builder) {
                        return Parser.done(recon.extant());
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    if (!builder) {
                        return Parser.done(recon.extant());
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
            }
            if (step === 2) {
                while (fieldParser.isCont() && !input.isEmpty()) {
                    fieldParser = fieldParser.feed(input);
                }
                if (fieldParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(fieldParser.bind());
                    fieldParser = void 0;
                    step = 3;
                }
                else if (fieldParser.isError()) {
                    return fieldParser.asError();
                }
            }
            if (step === 3) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 123) {
                        valueParser = recon.parseRecord(input, builder);
                        step = 5;
                    }
                    else if (c === 91) {
                        valueParser = recon.parseMarkup(input, builder);
                        step = 5;
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(builder.bind());
                }
            }
            if (step === 4) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(recon.item(valueParser.bind()));
                    return Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser;
                }
            }
            if (step === 5) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    return Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser;
                }
            }
            return new InlineItemParser(recon, builder, fieldParser, valueParser, step);
        };
        return InlineItemParser;
    }(Parser));

    var RecordParser = (function (_super) {
        __extends(RecordParser, _super);
        function RecordParser(recon, builder, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        RecordParser.prototype.feed = function (input) {
            return RecordParser.parse(input, this._recon, this._builder, this._keyParser, this._valueParser, this._step);
        };
        RecordParser.parse = function (input, recon, builder, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 123) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(123, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(123, input));
                }
            }
            block: do {
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        builder = builder || recon.recordBuilder();
                        if (c === 125) {
                            input = input.step();
                            return Parser.done(builder.bind());
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 8;
                        }
                        else {
                            step = 3;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(125, input));
                    }
                }
                if (step === 3) {
                    if (!keyParser) {
                        keyParser = recon.parseBlockExpression(input);
                    }
                    while (keyParser.isCont() && !input.isEmpty()) {
                        keyParser = keyParser.feed(input);
                    }
                    if (keyParser.isDone()) {
                        step = 4;
                    }
                    else if (keyParser.isError()) {
                        return keyParser;
                    }
                }
                if (step === 4) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 58) {
                            input = input.step();
                            step = 5;
                        }
                        else {
                            builder.push(recon.item(keyParser.bind()));
                            keyParser = void 0;
                            step = 7;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(125, input));
                    }
                }
                if (step === 5) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 6;
                    }
                    else if (input.isDone()) {
                        builder.push(recon.slot(keyParser.bind()));
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 6) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
                        keyParser = void 0;
                        valueParser = void 0;
                        step = 7;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 7) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44 || c === 59 || Recon.isNewline(c)) {
                            input = input.step();
                            step = 2;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 8;
                        }
                        else if (c === 125) {
                            input = input.step();
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.error(Diagnostic.expected("'}', ';', ',', or newline", input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(125, input));
                    }
                }
                if (step === 8) {
                    while (input.isCont()) {
                        c = input.head();
                        if (!Recon.isNewline(c)) {
                            input = input.step();
                        }
                        else {
                            step = 2;
                            continue block;
                        }
                    }
                    if (input.isDone()) {
                        step = 2;
                        continue;
                    }
                }
                break;
            } while (true);
            return new RecordParser(recon, builder, keyParser, valueParser, step);
        };
        return RecordParser;
    }(Parser));

    var MarkupParser = (function (_super) {
        __extends(MarkupParser, _super);
        function MarkupParser(recon, builder, textOutput, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._textOutput = textOutput;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        MarkupParser.prototype.feed = function (input) {
            return MarkupParser.parse(input, this._recon, this._builder, this._textOutput, this._valueParser, this._step);
        };
        MarkupParser.parse = function (input, recon, builder, textOutput, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 91) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(91, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(91, input));
                }
            }
            do {
                if (step === 2) {
                    while (input.isCont()) {
                        c = input.head();
                        if (c !== 64 && c !== 91 && c !== 92 && c !== 93
                            && c !== 123 && c !== 125) {
                            input = input.step();
                            textOutput = textOutput || recon.textOutput();
                            textOutput.write(c);
                        }
                        else {
                            break;
                        }
                    }
                    if (input.isCont()) {
                        if (c === 93) {
                            input = input.step();
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                            }
                            return Parser.done(builder.bind());
                        }
                        else if (c === 64) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseInlineItem(input);
                            step = 3;
                        }
                        else if (c === 123) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseRecord(input, builder);
                            step = 4;
                        }
                        else if (c === 91) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseMarkup(input, builder);
                            step = 4;
                        }
                        else if (c === 92) {
                            input = input.step();
                            step = 5;
                        }
                        else {
                            return Parser.error(Diagnostic.unexpected(input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
                if (step === 3) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 4) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 5) {
                    if (input.isCont()) {
                        c = input.head();
                        textOutput = textOutput || recon.textOutput();
                        if (c === 34 || c === 36 || c === 39 || c === 47
                            || c === 64 || c === 91 || c === 92 || c === 93
                            || c === 123 || c === 125) {
                            input = input.step();
                            textOutput.write(c);
                            step = 2;
                        }
                        else if (c === 98) {
                            input = input.step();
                            textOutput.write(8);
                            step = 2;
                        }
                        else if (c === 102) {
                            input = input.step();
                            textOutput.write(12);
                            step = 2;
                        }
                        else if (c === 110) {
                            input = input.step();
                            textOutput.write(10);
                            step = 2;
                        }
                        else if (c === 114) {
                            input = input.step();
                            textOutput.write(13);
                            step = 2;
                        }
                        else if (c === 116) {
                            input = input.step();
                            textOutput.write(9);
                            step = 2;
                        }
                        else {
                            return Parser.error(Diagnostic.expected("escape character", input));
                        }
                        continue;
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected("escape character", input));
                    }
                }
                break;
            } while (true);
            return new MarkupParser(recon, builder, textOutput, valueParser, step);
        };
        return MarkupParser;
    }(Parser));

    var DataParser = (function (_super) {
        __extends(DataParser, _super);
        function DataParser(recon, base64Parser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._base64Parser = base64Parser;
            _this._step = step;
            return _this;
        }
        DataParser.prototype.feed = function (input) {
            return DataParser.parse(input, this._recon, this._base64Parser, this._step);
        };
        DataParser.parse = function (input, recon, base64Parser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(37, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(37, input));
                }
            }
            if (step === 2) {
                if (!base64Parser) {
                    base64Parser = Base64.standard().parse(input, recon.dataOutput());
                }
                while (base64Parser.isCont() && !input.isEmpty()) {
                    base64Parser = base64Parser.feed(input);
                }
                if (base64Parser.isDone()) {
                    return base64Parser;
                }
                else if (base64Parser.isError()) {
                    return base64Parser;
                }
            }
            return new DataParser(recon, base64Parser, step);
        };
        return DataParser;
    }(Parser));

    var IdentParser = (function (_super) {
        __extends(IdentParser, _super);
        function IdentParser(recon, output, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._step = step;
            return _this;
        }
        IdentParser.prototype.feed = function (input) {
            return IdentParser.parse(input, this._recon, this._output, this._step);
        };
        IdentParser.parse = function (input, recon, output, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (Recon.isIdentStartChar(c)) {
                        input = input.step();
                        output = output || recon.textOutput();
                        output = output.write(c);
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("identifier", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("identifier", input));
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isIdentChar(c))) {
                    input = input.step();
                    output.write(c);
                }
                if (!input.isEmpty()) {
                    return Parser.done(recon.ident(output.bind()));
                }
            }
            return new IdentParser(recon, output, step);
        };
        return IdentParser;
    }(Parser));

    var StringParser = (function (_super) {
        __extends(StringParser, _super);
        function StringParser(recon, output, quote, code, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._quote = quote;
            _this._code = code;
            _this._step = step;
            return _this;
        }
        StringParser.prototype.feed = function (input) {
            return StringParser.parse(input, this._recon, this._output, this._quote, this._code, this._step);
        };
        StringParser.parse = function (input, recon, output, quote, code, step) {
            if (quote === void 0) { quote = 0; }
            if (code === void 0) { code = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 34 || c === 39 && (quote === c || quote === 0)) {
                        input = input.step();
                        output = output || recon.textOutput();
                        quote = c;
                        step = 2;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("string", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("string", input));
                }
            }
            string: do {
                if (step === 2) {
                    while (input.isCont()) {
                        c = input.head();
                        if (c >= 0x20 && c !== quote && c !== 92) {
                            input = input.step();
                            output.write(c);
                        }
                        else {
                            break;
                        }
                    }
                    if (input.isCont()) {
                        if (c === quote) {
                            input = input.step();
                            return Parser.done(output.bind());
                        }
                        else if (c === 92) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return Parser.error(Diagnostic.expected(quote, input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(quote, input));
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 34 || c === 36 || c === 39 || c === 47
                            || c === 64 || c === 91 || c === 92 || c === 93
                            || c === 123 || c === 125) {
                            input = input.step();
                            output.write(c);
                            step = 2;
                            continue;
                        }
                        else if (c === 98) {
                            input = input.step();
                            output.write(8);
                            step = 2;
                            continue;
                        }
                        else if (c === 102) {
                            input = input.step();
                            output.write(12);
                            step = 2;
                            continue;
                        }
                        else if (c === 110) {
                            input = input.step();
                            output.write(10);
                            step = 2;
                            continue;
                        }
                        else if (c === 114) {
                            input = input.step();
                            output.write(13);
                            step = 2;
                            continue;
                        }
                        else if (c === 116) {
                            input = input.step();
                            output.write(9);
                            step = 2;
                            continue;
                        }
                        else if (c === 117) {
                            input = input.step();
                            step = 4;
                        }
                        else {
                            return Parser.error(Diagnostic.expected("escape character", input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected("escape character", input));
                    }
                }
                if (step >= 4) {
                    do {
                        if (input.isCont()) {
                            c = input.head();
                            if (Base16.isDigit(c)) {
                                input = input.step();
                                code = 16 * code + Base16.decodeDigit(c);
                                if (step <= 6) {
                                    step += 1;
                                    continue;
                                }
                                else {
                                    output.write(code);
                                    code = 0;
                                    step = 2;
                                    continue string;
                                }
                            }
                            else {
                                return Parser.error(Diagnostic.expected("hex digit", input));
                            }
                        }
                        else if (input.isDone()) {
                            return Parser.error(Diagnostic.expected("hex digit", input));
                        }
                        break;
                    } while (true);
                }
                break;
            } while (true);
            return new StringParser(recon, output, quote, code, step);
        };
        return StringParser;
    }(Parser));

    var NumberParser = (function (_super) {
        __extends(NumberParser, _super);
        function NumberParser(recon, sign, value, mode, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._sign = sign;
            _this._value = value;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        NumberParser.prototype.feed = function (input) {
            return NumberParser.parse(input, this._recon, this._sign, this._value, this._mode, this._step);
        };
        NumberParser.parse = function (input, recon, sign, value, mode, step) {
            if (sign === void 0) { sign = 1; }
            if (value === void 0) { value = 0; }
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 45) {
                        input = input.step();
                        sign = -1;
                    }
                    step = 2;
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("number", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 48) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c >= 49 && c <= 57) {
                        input = input.step();
                        value = sign * (c - 48);
                        step = 3;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("digit", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        var newValue = 10 * value + sign * (c - 48);
                        if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {
                            value = newValue;
                            input = input.step();
                        }
                        else {
                            return Parser.error(Diagnostic.message("integer overflow", input));
                        }
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    step = 4;
                }
                else if (input.isDone()) {
                    return Parser.done(recon.num(value));
                }
            }
            if (step === 4) {
                if (input.isCont()) {
                    c = input.head();
                    if (mode > 0 && c === 46 || mode > 1 && (c === 69 || c === 101)) {
                        var output = Unicode.stringOutput();
                        if (sign < 0 && value === 0) {
                            output = output.write(45).write(48);
                        }
                        else {
                            output = output.write("" + value);
                        }
                        return DecimalParser.parse(input, recon, output, mode);
                    }
                    else if (c === 120 && sign > 0 && value === 0) {
                        input = input.step();
                        return HexadecimalParser.parse(input, recon);
                    }
                    else {
                        return Parser.done(recon.num(value));
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(recon.num(value));
                }
            }
            return new NumberParser(recon, sign, value, mode, step);
        };
        NumberParser.parseInteger = function (input, recon) {
            return NumberParser.parse(input, recon, void 0, void 0, 0);
        };
        NumberParser.parseDecimal = function (input, recon) {
            return NumberParser.parse(input, recon, void 0, void 0, 1);
        };
        return NumberParser;
    }(Parser));
    var DecimalParser = (function (_super) {
        __extends(DecimalParser, _super);
        function DecimalParser(recon, output, mode, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        DecimalParser.prototype.feed = function (input) {
            return DecimalParser.parse(input, this._recon, this._output, this._mode, this._step);
        };
        DecimalParser.parse = function (input, recon, output, mode, step) {
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 46) {
                        input = input.step();
                        output = output.write(c);
                        step = 2;
                    }
                    else if (mode > 1 && (c === 69 || c === 101)) {
                        input = input.step();
                        output = output.write(c);
                        step = 5;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("decimal or exponent", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("decimal or exponent", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 3;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("digit", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    if (mode > 1) {
                        step = 4;
                    }
                    else {
                        return Parser.done(recon.num(output.bind()));
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(recon.num(output.bind()));
                }
            }
            if (step === 4) {
                c = input.head();
                if (c === 69 || c === 101) {
                    input = input.step();
                    output = output.write(c);
                    step = 5;
                }
                else {
                    return Parser.done(recon.num(output.bind()));
                }
            }
            if (step === 5) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 43 || c === 45) {
                        input = input.step();
                        output = output.write(c);
                    }
                    step = 6;
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 6) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 7;
                    }
                    else {
                        return Parser.error(Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("digit", input));
                }
            }
            if (step === 7) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (!input.isEmpty()) {
                    return Parser.done(recon.num(output.bind()));
                }
            }
            return new DecimalParser(recon, output, mode, step);
        };
        return DecimalParser;
    }(Parser));
    var HexadecimalParser = (function (_super) {
        __extends(HexadecimalParser, _super);
        function HexadecimalParser(recon, value, size) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._value = value;
            _this._size = size;
            return _this;
        }
        HexadecimalParser.prototype.feed = function (input) {
            return HexadecimalParser.parse(input, this._recon, this._value, this._size);
        };
        HexadecimalParser.parse = function (input, recon, value, size) {
            if (value === void 0) { value = 0; }
            if (size === void 0) { size = 0; }
            var c = 0;
            while (input.isCont()) {
                c = input.head();
                if (Base16.isDigit(c)) {
                    input = input.step();
                    value = 16 * value + Base16.decodeDigit(c);
                    size += 1;
                }
                else {
                    break;
                }
            }
            if (!input.isEmpty()) {
                if (size > 0) {
                    if (size <= 8) {
                        return Parser.done(recon.uint32(value));
                    }
                    else {
                        return Parser.done(recon.uint64(value));
                    }
                }
                else {
                    return Parser.error(Diagnostic.expected("hex digit", input));
                }
            }
            return new HexadecimalParser(recon, value, size);
        };
        return HexadecimalParser;
    }(Parser));

    var LambdaFuncParser = (function (_super) {
        __extends(LambdaFuncParser, _super);
        function LambdaFuncParser(recon, builder, bindingsParser, templateParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._bindingsParser = bindingsParser;
            _this._templateParser = templateParser;
            _this._step = step;
            return _this;
        }
        LambdaFuncParser.prototype.feed = function (input) {
            return LambdaFuncParser.parse(input, this._recon, this._builder, this._bindingsParser, this._templateParser, this._step);
        };
        LambdaFuncParser.parse = function (input, recon, builder, bindingsParser, templateParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!bindingsParser) {
                    bindingsParser = recon.parseConditionalOperator(input, builder);
                }
                while (bindingsParser.isCont() && !input.isEmpty()) {
                    bindingsParser = bindingsParser.feed(input);
                }
                if (bindingsParser.isDone()) {
                    step = 2;
                }
                else if (bindingsParser.isError()) {
                    return bindingsParser.asError();
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 62) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        return bindingsParser;
                    }
                }
                else if (input.isDone()) {
                    return bindingsParser;
                }
            }
            if (step === 3) {
                if (!templateParser) {
                    templateParser = recon.parseConditionalOperator(input);
                }
                while (templateParser.isCont() && !input.isEmpty()) {
                    templateParser = templateParser.feed(input);
                }
                if (templateParser.isDone()) {
                    var bindings = bindingsParser.bind();
                    var template = templateParser.bind();
                    return Parser.done(recon.lambda(bindings, template));
                }
                else if (templateParser.isError()) {
                    return templateParser.asError();
                }
            }
            return new LambdaFuncParser(recon, builder, bindingsParser, templateParser, step);
        };
        return LambdaFuncParser;
    }(Parser));

    var ConditionalOperatorParser = (function (_super) {
        __extends(ConditionalOperatorParser, _super);
        function ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._ifParser = ifParser;
            _this._thenParser = thenParser;
            _this._elseParser = elseParser;
            _this._step = step;
            return _this;
        }
        ConditionalOperatorParser.prototype.feed = function (input) {
            return ConditionalOperatorParser.parse(input, this._recon, this._builder, this._ifParser, this._thenParser, this._elseParser, this._step);
        };
        ConditionalOperatorParser.parse = function (input, recon, builder, ifParser, thenParser, elseParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!ifParser) {
                    ifParser = recon.parseOrOperator(input, builder);
                }
                while (ifParser.isCont() && !input.isEmpty()) {
                    ifParser = ifParser.feed(input);
                }
                if (ifParser.isDone()) {
                    step = 2;
                }
                else if (ifParser.isError()) {
                    return ifParser.asError();
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 63) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        return ifParser;
                    }
                }
                else if (input.isDone()) {
                    return ifParser;
                }
            }
            if (step === 3) {
                if (!thenParser) {
                    thenParser = recon.parseConditionalOperator(input, builder);
                }
                while (thenParser.isCont() && !input.isEmpty()) {
                    thenParser = thenParser.feed(input);
                }
                if (thenParser.isDone()) {
                    step = 4;
                }
                else if (thenParser.isError()) {
                    return thenParser.asError();
                }
            }
            if (step === 4) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 58) {
                        input = input.step();
                        step = 5;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(58, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(58, input));
                }
            }
            if (step === 5) {
                if (!elseParser) {
                    elseParser = recon.parseConditionalOperator(input, builder);
                }
                while (elseParser.isCont() && !input.isEmpty()) {
                    elseParser = elseParser.feed(input);
                }
                if (elseParser.isDone()) {
                    var ifTerm = ifParser.bind();
                    var thenTerm = thenParser.bind();
                    var elseTerm = elseParser.bind();
                    return Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));
                }
                else if (elseParser.isError()) {
                    return elseParser.asError();
                }
            }
            return new ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step);
        };
        return ConditionalOperatorParser;
    }(Parser));

    var OrOperatorParser = (function (_super) {
        __extends(OrOperatorParser, _super);
        function OrOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        OrOperatorParser.prototype.feed = function (input) {
            return OrOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        OrOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseAndOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 124) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseAndOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = Parser.done(recon.or(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new OrOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return OrOperatorParser;
    }(Parser));

    var AndOperatorParser = (function (_super) {
        __extends(AndOperatorParser, _super);
        function AndOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        AndOperatorParser.prototype.feed = function (input) {
            return AndOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        AndOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseOrOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 38) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseOrOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = Parser.done(recon.and(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new AndOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return AndOperatorParser;
    }(Parser));

    var BitwiseOrOperatorParser = (function (_super) {
        __extends(BitwiseOrOperatorParser, _super);
        function BitwiseOrOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseOrOperatorParser.prototype.feed = function (input) {
            return BitwiseOrOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseOrOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseXorOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 124) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 124) {
                            return lhsParser;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
                if (step === 4) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseXorOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = Parser.done(recon.bitwiseOr(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseOrOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseOrOperatorParser;
    }(Parser));

    var BitwiseXorOperatorParser = (function (_super) {
        __extends(BitwiseXorOperatorParser, _super);
        function BitwiseXorOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseXorOperatorParser.prototype.feed = function (input) {
            return BitwiseXorOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseXorOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseAndOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 94) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseAndOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = Parser.done(recon.bitwiseXor(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseXorOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseXorOperatorParser;
    }(Parser));

    var BitwiseAndOperatorParser = (function (_super) {
        __extends(BitwiseAndOperatorParser, _super);
        function BitwiseAndOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseAndOperatorParser.prototype.feed = function (input) {
            return BitwiseAndOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseAndOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseComparisonOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 38) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 38) {
                            return lhsParser;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
                if (step === 4) {
                    if (!rhsParser) {
                        rhsParser = recon.parseComparisonOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = Parser.done(recon.bitwiseAnd(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseAndOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseAndOperatorParser;
    }(Parser));

    var ComparisonOperatorParser = (function (_super) {
        __extends(ComparisonOperatorParser, _super);
        function ComparisonOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        ComparisonOperatorParser.prototype.feed = function (input) {
            return ComparisonOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        ComparisonOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!lhsParser) {
                    lhsParser = recon.parseAttrExpression(input, builder);
                }
                while (lhsParser.isCont() && !input.isEmpty()) {
                    lhsParser = lhsParser.feed(input);
                }
                if (lhsParser.isDone()) {
                    step = 2;
                }
                else if (lhsParser.isError()) {
                    return lhsParser.asError();
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 33) {
                        input = input.step();
                        step = 3;
                    }
                    else if (c === 60) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c === 62) {
                        input = input.step();
                        step = 5;
                    }
                    else if (c === 61) {
                        input = input.step();
                        step = 6;
                    }
                    else {
                        return lhsParser;
                    }
                }
                else if (input.isDone()) {
                    return lhsParser;
                }
            }
            if (step === 3) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "!=";
                        step = 7;
                    }
                    else {
                        operator = "!";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 4) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "<=";
                        step = 7;
                    }
                    else {
                        operator = "<";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 5) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = ">=";
                        step = 7;
                    }
                    else {
                        operator = ">";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 6) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "==";
                        step = 7;
                    }
                    else if (c === 62) {
                        return lhsParser;
                    }
                    else {
                        operator = "=";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            if (step === 7) {
                if (!rhsParser) {
                    rhsParser = recon.parseAttrExpression(input, builder);
                }
                while (rhsParser.isCont() && !input.isEmpty()) {
                    rhsParser = rhsParser.feed(input);
                }
                if (rhsParser.isDone()) {
                    var lhs = lhsParser.bind();
                    var rhs = rhsParser.bind();
                    if (operator === "<") {
                        return Parser.done(recon.lt(lhs, rhs));
                    }
                    else if (operator === "<=") {
                        return Parser.done(recon.le(lhs, rhs));
                    }
                    else if (operator === "==") {
                        return Parser.done(recon.eq(lhs, rhs));
                    }
                    else if (operator === "!=") {
                        return Parser.done(recon.ne(lhs, rhs));
                    }
                    else if (operator === ">=") {
                        return Parser.done(recon.ge(lhs, rhs));
                    }
                    else if (operator === ">") {
                        return Parser.done(recon.gt(lhs, rhs));
                    }
                    else {
                        return Parser.error(Diagnostic.message(operator, input));
                    }
                }
                else if (rhsParser.isError()) {
                    return rhsParser.asError();
                }
            }
            return new ComparisonOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return ComparisonOperatorParser;
    }(Parser));

    var AttrExpressionParser = (function (_super) {
        __extends(AttrExpressionParser, _super);
        function AttrExpressionParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        AttrExpressionParser.prototype.feed = function (input) {
            return AttrExpressionParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        AttrExpressionParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 64) {
                            step = 2;
                        }
                        else if (c === 123 || c === 91) {
                            builder = builder || recon.recordBuilder();
                            step = 5;
                        }
                        else if (c === 40) {
                            step = 4;
                        }
                        else if (c === 33 || c === 34 || c === 36 || c === 37
                            || c === 39 || c === 43 || c === 45
                            || c >= 48 && c <= 57 || c === 126
                            || Recon.isIdentStartChar(c)) {
                            step = 3;
                        }
                        else if (!builder) {
                            return Parser.done(recon.extant());
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        if (!builder) {
                            return Parser.done(recon.extant());
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                }
                if (step === 2) {
                    if (!fieldParser) {
                        fieldParser = recon.parseAttr(input);
                    }
                    while (fieldParser.isCont() && !input.isEmpty()) {
                        fieldParser = fieldParser.feed(input);
                    }
                    if (fieldParser.isDone()) {
                        builder = builder || recon.recordBuilder();
                        builder.push(fieldParser.bind());
                        fieldParser = void 0;
                        step = 1;
                        continue;
                    }
                    else if (fieldParser.isError()) {
                        return fieldParser.asError();
                    }
                }
                if (step === 3) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 4) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input, builder);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        if (!builder) {
                            builder = recon.valueBuilder();
                            builder.push(recon.item(valueParser.bind()));
                        }
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 5) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input, builder);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 6) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 64) {
                            step = 1;
                            continue;
                        }
                        else {
                            return Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.done(builder.bind());
                    }
                }
                break;
            } while (true);
            return new AttrExpressionParser(recon, builder, fieldParser, valueParser, step);
        };
        return AttrExpressionParser;
    }(Parser));

    var AdditiveOperatorParser = (function (_super) {
        __extends(AdditiveOperatorParser, _super);
        function AdditiveOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        AdditiveOperatorParser.prototype.feed = function (input) {
            return AdditiveOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        AdditiveOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseMultiplicativeOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 43) {
                            input = input.step();
                            operator = "+";
                            step = 3;
                        }
                        else if (c === 45) {
                            input = input.step();
                            operator = "-";
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseMultiplicativeOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        if (operator === "+") {
                            lhsParser = Parser.done(recon.plus(lhs, rhs));
                        }
                        else if (operator === "-") {
                            lhsParser = Parser.done(recon.minus(lhs, rhs));
                        }
                        else {
                            return Parser.error(Diagnostic.message(operator, input));
                        }
                        rhsParser = void 0;
                        operator = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new AdditiveOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return AdditiveOperatorParser;
    }(Parser));

    var MultiplicativeOperatorParser = (function (_super) {
        __extends(MultiplicativeOperatorParser, _super);
        function MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        MultiplicativeOperatorParser.prototype.feed = function (input) {
            return MultiplicativeOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        MultiplicativeOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parsePrefixOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 42) {
                            input = input.step();
                            operator = "*";
                            step = 3;
                        }
                        else if (c === 47) {
                            input = input.step();
                            operator = "/";
                            step = 3;
                        }
                        else if (c === 37) {
                            input = input.step();
                            operator = "%";
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parsePrefixOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        if (operator === "*") {
                            lhsParser = Parser.done(recon.times(lhs, rhs));
                        }
                        else if (operator === "/") {
                            lhsParser = Parser.done(recon.divide(lhs, rhs));
                        }
                        else if (operator === "%") {
                            lhsParser = Parser.done(recon.modulo(lhs, rhs));
                        }
                        else {
                            return Parser.error(Diagnostic.message(operator, input));
                        }
                        rhsParser = void 0;
                        operator = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return MultiplicativeOperatorParser;
    }(Parser));

    var PrefixOperatorParser = (function (_super) {
        __extends(PrefixOperatorParser, _super);
        function PrefixOperatorParser(recon, builder, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._operator = operator;
            _this._operandParser = rhsParser;
            _this._step = step;
            return _this;
        }
        PrefixOperatorParser.prototype.feed = function (input) {
            return PrefixOperatorParser.parse(input, this._recon, this._builder, this._operator, this._operandParser, this._step);
        };
        PrefixOperatorParser.parse = function (input, recon, builder, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 33) {
                        input = input.step();
                        operator = "!";
                    }
                    else if (c === 126) {
                        input = input.step();
                        operator = "~";
                    }
                    else if (c === 45) {
                        input = input.step();
                        operator = "-";
                    }
                    else if (c === 43) {
                        input = input.step();
                        operator = "+";
                    }
                    else {
                        return recon.parseInvokeOperator(input, builder);
                    }
                    step = 2;
                }
                else if (input.isDone()) {
                    return recon.parseInvokeOperator(input, builder);
                }
            }
            if (step === 2) {
                if (!rhsParser) {
                    rhsParser = recon.parsePrefixOperator(input, builder);
                }
                while (rhsParser.isCont() && !input.isEmpty()) {
                    rhsParser = rhsParser.feed(input);
                }
                if (rhsParser.isDone()) {
                    var operand = rhsParser.bind();
                    if (!recon.isDistinct(operand)) {
                        return Parser.error(Diagnostic.expected("value", input));
                    }
                    else if (operator === "!") {
                        return Parser.done(recon.not(operand));
                    }
                    else if (operator === "~") {
                        return Parser.done(recon.bitwiseNot(operand));
                    }
                    else if (operator === "-") {
                        return Parser.done(recon.negative(operand));
                    }
                    else if (operator === "+") {
                        return Parser.done(recon.positive(operand));
                    }
                    else {
                        return Parser.error(Diagnostic.message(operator, input));
                    }
                }
                else if (rhsParser.isError()) {
                    return rhsParser.asError();
                }
            }
            return new PrefixOperatorParser(recon, builder, operator, rhsParser, step);
        };
        return PrefixOperatorParser;
    }(Parser));

    var InvokeOperatorParser = (function (_super) {
        __extends(InvokeOperatorParser, _super);
        function InvokeOperatorParser(recon, builder, exprParser, argsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._exprParser = exprParser;
            _this._argsParser = argsParser;
            _this._step = step;
            return _this;
        }
        InvokeOperatorParser.prototype.feed = function (input) {
            return InvokeOperatorParser.parse(input, this._recon, this._builder, this._exprParser, this._argsParser, this._step);
        };
        InvokeOperatorParser.parse = function (input, recon, builder, exprParser, argsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!exprParser) {
                    exprParser = recon.parsePrimary(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    step = 2;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            do {
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 40) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return exprParser;
                        }
                    }
                    else if (input.isDone()) {
                        return exprParser;
                    }
                }
                if (step === 3) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 41) {
                            input = input.step();
                            var expr = exprParser.bind();
                            exprParser = Parser.done(recon.invoke(expr, recon.extant()));
                            step = 2;
                            continue;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(41, input));
                    }
                }
                if (step === 4) {
                    if (!argsParser) {
                        argsParser = recon.parseBlock(input);
                    }
                    while (argsParser.isCont() && !input.isEmpty()) {
                        argsParser = argsParser.feed(input);
                    }
                    if (argsParser.isDone()) {
                        step = 5;
                    }
                    else if (argsParser.isError()) {
                        return argsParser.asError();
                    }
                }
                if (step === 5) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 41) {
                            input = input.step();
                            var expr = exprParser.bind();
                            var args = argsParser.bind();
                            exprParser = Parser.done(recon.invoke(expr, args));
                            argsParser = void 0;
                            step = 2;
                            continue;
                        }
                        else {
                            return Parser.error(Diagnostic.expected(41, input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(41, input));
                    }
                }
                break;
            } while (true);
            return new InvokeOperatorParser(recon, builder, exprParser, argsParser, step);
        };
        return InvokeOperatorParser;
    }(Parser));

    var PrimaryParser = (function (_super) {
        __extends(PrimaryParser, _super);
        function PrimaryParser(recon, builder, exprParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._exprParser = exprParser;
            _this._step = step;
            return _this;
        }
        PrimaryParser.prototype.feed = function (input) {
            return PrimaryParser.parse(input, this._recon, this._builder, this._exprParser, this._step);
        };
        PrimaryParser.parse = function (input, recon, builder, exprParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 40) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        step = 2;
                    }
                }
                else if (input.isDone()) {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!exprParser) {
                    exprParser = recon.parseLiteral(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    return exprParser;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            if (step === 3) {
                if (!exprParser) {
                    exprParser = recon.parseBlockExpression(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    step = 4;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            do {
                if (step === 4) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44) {
                            input = input.step();
                            if (exprParser) {
                                if (!builder) {
                                    builder = recon.recordBuilder();
                                    builder.push(recon.item(exprParser.bind()));
                                }
                                exprParser = void 0;
                            }
                            step = 5;
                        }
                        else if (c === 41) {
                            input = input.step();
                            if (exprParser) {
                                return exprParser;
                            }
                            else {
                                return Parser.done(builder.bind());
                            }
                        }
                        else {
                            return Parser.error(Diagnostic.expected(41, input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(41, input));
                    }
                }
                if (step === 5) {
                    if (!exprParser) {
                        exprParser = recon.parseBlockExpression(input, builder);
                    }
                    while (exprParser.isCont() && !input.isEmpty()) {
                        exprParser = exprParser.feed(input);
                    }
                    if (exprParser.isDone()) {
                        exprParser = void 0;
                        step = 4;
                        continue;
                    }
                    else if (exprParser.isError()) {
                        return exprParser.asError();
                    }
                }
                break;
            } while (true);
            return new PrimaryParser(recon, builder, exprParser, step);
        };
        return PrimaryParser;
    }(Parser));

    var LiteralParser = (function (_super) {
        __extends(LiteralParser, _super);
        function LiteralParser(recon, builder, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        LiteralParser.prototype.feed = function (input) {
            return LiteralParser.parse(input, this._recon, this._builder, this._valueParser, this._step);
        };
        LiteralParser.parse = function (input, recon, builder, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 40) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c === 123) {
                        builder = builder || recon.recordBuilder();
                        valueParser = recon.parseRecord(input, builder);
                        step = 3;
                    }
                    else if (c === 91) {
                        builder = builder || recon.recordBuilder();
                        valueParser = recon.parseMarkup(input, builder);
                        step = 3;
                    }
                    else if (Recon.isIdentStartChar(c)) {
                        valueParser = recon.parseIdent(input);
                        step = 2;
                    }
                    else if (c === 34 || c === 39) {
                        valueParser = recon.parseString(input);
                        step = 2;
                    }
                    else if (c === 45 || c >= 48 && c <= 57) {
                        valueParser = recon.parseNumber(input);
                        step = 2;
                    }
                    else if (c === 37) {
                        valueParser = recon.parseData(input);
                        step = 2;
                    }
                    else if (c === 36) {
                        valueParser = recon.parseSelector(input);
                        step = 2;
                    }
                    else if (!builder) {
                        return Parser.done(recon.extant());
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    if (!builder) {
                        return Parser.done(recon.extant());
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
            }
            if (step === 2) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(recon.item(valueParser.bind()));
                    return Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 3) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    return Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 4) {
                if (!valueParser) {
                    valueParser = recon.parseBlockExpression(input);
                }
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    step = 5;
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 5) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        return Parser.done(builder.bind());
                    }
                    else {
                        return Parser.error(Diagnostic.expected(41, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(41, input));
                }
            }
            return new LiteralParser(recon, builder, valueParser, step);
        };
        return LiteralParser;
    }(Parser));

    var SelectorParser = (function (_super) {
        __extends(SelectorParser, _super);
        function SelectorParser(recon, builder, selector, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._selector = selector;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        SelectorParser.prototype.feed = function (input) {
            return SelectorParser.parse(input, this._recon, this._builder, this._selector, this._valueParser, this._step);
        };
        SelectorParser.parse = function (input, recon, builder, selector, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont() && c === 36) {
                    input = input.step();
                    selector = selector || recon.selector();
                    step = 2;
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(36, input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 91) {
                        input = input.step();
                        step = 8;
                    }
                    else if (c === 64) {
                        input = input.step();
                        step = 7;
                    }
                    else if (c === 58) {
                        input = input.step();
                        step = 6;
                    }
                    else if (c === 42) {
                        input = input.step();
                        step = 5;
                    }
                    else if (c === 35) {
                        input = input.step();
                        step = 4;
                    }
                    else {
                        step = 3;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
            }
            do {
                if (step === 3) {
                    if (!valueParser) {
                        valueParser = recon.parseLiteral(input, recon.valueBuilder());
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.get(selector, valueParser.bind());
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 4) {
                    if (!valueParser) {
                        valueParser = recon.parseInteger(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.value(recon.getItem(selector, valueParser.bind()));
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 5) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 58) {
                            input = input.step();
                            selector = recon.keys(selector);
                            step = 10;
                        }
                        else if (c === 42) {
                            input = input.step();
                            selector = recon.descendants(selector);
                            step = 10;
                        }
                        else {
                            selector = recon.children(selector);
                            step = 10;
                        }
                    }
                    else if (input.isDone()) {
                        selector = recon.children(selector);
                        step = 10;
                    }
                }
                if (step === 6) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 42) {
                            input = input.step();
                            selector = recon.values(selector);
                            step = 10;
                        }
                        else {
                            return Parser.error(Diagnostic.expected(42, input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(42, input));
                    }
                }
                if (step === 7) {
                    if (!valueParser) {
                        valueParser = recon.parseIdent(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.getAttr(selector, valueParser.bind());
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 8) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        step = 9;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 9) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 93) {
                            input = input.step();
                            selector = recon.filter(selector, valueParser.bind());
                            valueParser = void 0;
                            step = 10;
                        }
                        else {
                            return Parser.error(Diagnostic.expected(93, input));
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.expected(93, input));
                    }
                }
                if (step === 10) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 91) {
                            input = input.step();
                            step = 8;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 4;
                            continue;
                        }
                        else if (c === 46) {
                            input = input.step();
                            step = 11;
                        }
                        else if (builder) {
                            builder.push(recon.item(selector));
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.done(selector);
                        }
                    }
                    else if (input.isDone()) {
                        if (builder) {
                            builder.push(recon.item(selector));
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.done(selector);
                        }
                    }
                }
                if (step === 11) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 64) {
                            input = input.step();
                            step = 7;
                            continue;
                        }
                        else if (c === 58) {
                            input = input.step();
                            step = 6;
                            continue;
                        }
                        else if (c === 42) {
                            input = input.step();
                            step = 5;
                            continue;
                        }
                        else {
                            step = 3;
                            continue;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
                break;
            } while (true);
            return new SelectorParser(recon, builder, selector, valueParser, step);
        };
        return SelectorParser;
    }(Parser));

    var ReconParser = (function () {
        function ReconParser() {
        }
        ReconParser.prototype.parseBlock = function (input) {
            return BlockParser.parse(input, this);
        };
        ReconParser.prototype.parseAttr = function (input) {
            return AttrParser.parse(input, this);
        };
        ReconParser.prototype.parseBlockItem = function (input) {
            return BlockItemParser.parse(input, this);
        };
        ReconParser.prototype.parseInlineItem = function (input) {
            return InlineItemParser.parse(input, this);
        };
        ReconParser.prototype.parseRecord = function (input, builder) {
            return RecordParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseMarkup = function (input, builder) {
            return MarkupParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseData = function (input) {
            return DataParser.parse(input, this);
        };
        ReconParser.prototype.parseIdent = function (input) {
            return IdentParser.parse(input, this);
        };
        ReconParser.prototype.parseString = function (input) {
            return StringParser.parse(input, this);
        };
        ReconParser.prototype.parseNumber = function (input) {
            return NumberParser.parse(input, this);
        };
        ReconParser.prototype.parseInteger = function (input) {
            return NumberParser.parseInteger(input, this);
        };
        ReconParser.prototype.parseBlockExpression = function (input, builder) {
            return this.parseLambdaFunc(input, builder);
        };
        ReconParser.prototype.parseLambdaFunc = function (input, builder) {
            return LambdaFuncParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseConditionalOperator = function (input, builder) {
            return ConditionalOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseOrOperator = function (input, builder) {
            return OrOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAndOperator = function (input, builder) {
            return AndOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseOrOperator = function (input, builder) {
            return BitwiseOrOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseXorOperator = function (input, builder) {
            return BitwiseXorOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseAndOperator = function (input, builder) {
            return BitwiseAndOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseComparisonOperator = function (input, builder) {
            return ComparisonOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAttrExpression = function (input, builder) {
            return AttrExpressionParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAdditiveOperator = function (input, builder) {
            return AdditiveOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseMultiplicativeOperator = function (input, builder) {
            return MultiplicativeOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parsePrefixOperator = function (input, builder) {
            return PrefixOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseInvokeOperator = function (input, builder) {
            return InvokeOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parsePrimary = function (input, builder) {
            return PrimaryParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseLiteral = function (input, builder) {
            return LiteralParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseSelector = function (input, builder) {
            return SelectorParser.parse(input, this, builder);
        };
        ReconParser.prototype.blockParser = function () {
            return new BlockParser(this);
        };
        ReconParser.prototype.parseBlockString = function (string) {
            var input = Unicode.stringInput(string);
            while (input.isCont() && Recon.isWhitespace(input.head())) {
                input = input.step();
            }
            var parser = this.parseBlock(input);
            if (parser.isDone()) {
                while (input.isCont() && Recon.isWhitespace(input.head())) {
                    input = input.step();
                }
            }
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        ReconParser.prototype.parseNumberString = function (string) {
            var input = Unicode.stringInput(string);
            while (input.isCont() && Recon.isWhitespace(input.head())) {
                input = input.step();
            }
            var parser = this.parseNumber(input);
            if (parser.isDone()) {
                while (input.isCont() && Recon.isWhitespace(input.head())) {
                    input = input.step();
                }
            }
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        return ReconParser;
    }());

    var ReconStructureParser = (function (_super) {
        __extends(ReconStructureParser, _super);
        function ReconStructureParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReconStructureParser.prototype.isDistinct = function (value) {
            return value.isDistinct();
        };
        ReconStructureParser.prototype.item = function (value) {
            return value;
        };
        ReconStructureParser.prototype.value = function (item) {
            return item.toValue();
        };
        ReconStructureParser.prototype.attr = function (key, value) {
            return Attr.of.apply(Attr, arguments);
        };
        ReconStructureParser.prototype.slot = function (key, value) {
            return Slot.of.apply(Slot, arguments);
        };
        ReconStructureParser.prototype.valueBuilder = function () {
            return Value.builder();
        };
        ReconStructureParser.prototype.recordBuilder = function () {
            return Record.create();
        };
        ReconStructureParser.prototype.dataOutput = function () {
            return Data.output();
        };
        ReconStructureParser.prototype.textOutput = function () {
            return Text.output();
        };
        ReconStructureParser.prototype.ident = function (value) {
            if (value instanceof Text) {
                var string = value.stringValue();
                if (string === "true") {
                    return Bool.from(true);
                }
                else if (string === "false") {
                    return Bool.from(false);
                }
            }
            return value;
        };
        ReconStructureParser.prototype.num = function (value) {
            if (typeof value === "number") {
                return Num.from(value);
            }
            else if (typeof value === "string") {
                return Num.from(+value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        ReconStructureParser.prototype.uint32 = function (value) {
            return Num.uint32(value);
        };
        ReconStructureParser.prototype.uint64 = function (value) {
            return Num.uint64(value);
        };
        ReconStructureParser.prototype.bool = function (value) {
            return Bool.from(value);
        };
        ReconStructureParser.prototype.selector = function () {
            return Selector.identity();
        };
        ReconStructureParser.prototype.extant = function () {
            return Value.extant();
        };
        ReconStructureParser.prototype.absent = function () {
            return Value.absent();
        };
        ReconStructureParser.prototype.conditional = function (ifTerm, thenTerm, elseTerm) {
            return ifTerm.conditional(thenTerm, elseTerm);
        };
        ReconStructureParser.prototype.or = function (lhs, rhs) {
            return lhs.or(rhs);
        };
        ReconStructureParser.prototype.and = function (lhs, rhs) {
            return lhs.and(rhs);
        };
        ReconStructureParser.prototype.bitwiseOr = function (lhs, rhs) {
            return lhs.bitwiseOr(rhs);
        };
        ReconStructureParser.prototype.bitwiseXor = function (lhs, rhs) {
            return lhs.bitwiseXor(rhs);
        };
        ReconStructureParser.prototype.bitwiseAnd = function (lhs, rhs) {
            return lhs.bitwiseAnd(rhs);
        };
        ReconStructureParser.prototype.lt = function (lhs, rhs) {
            return lhs.lt(rhs);
        };
        ReconStructureParser.prototype.le = function (lhs, rhs) {
            return lhs.le(rhs);
        };
        ReconStructureParser.prototype.eq = function (lhs, rhs) {
            return lhs.eq(rhs);
        };
        ReconStructureParser.prototype.ne = function (lhs, rhs) {
            return lhs.ne(rhs);
        };
        ReconStructureParser.prototype.ge = function (lhs, rhs) {
            return lhs.ge(rhs);
        };
        ReconStructureParser.prototype.gt = function (lhs, rhs) {
            return lhs.gt(rhs);
        };
        ReconStructureParser.prototype.plus = function (lhs, rhs) {
            return lhs.plus(rhs);
        };
        ReconStructureParser.prototype.minus = function (lhs, rhs) {
            return lhs.minus(rhs);
        };
        ReconStructureParser.prototype.times = function (lhs, rhs) {
            return lhs.times(rhs);
        };
        ReconStructureParser.prototype.divide = function (lhs, rhs) {
            return lhs.divide(rhs);
        };
        ReconStructureParser.prototype.modulo = function (lhs, rhs) {
            return lhs.modulo(rhs);
        };
        ReconStructureParser.prototype.not = function (rhs) {
            return rhs.not();
        };
        ReconStructureParser.prototype.bitwiseNot = function (rhs) {
            return rhs.bitwiseNot();
        };
        ReconStructureParser.prototype.negative = function (rhs) {
            return rhs.negative();
        };
        ReconStructureParser.prototype.positive = function (rhs) {
            return rhs.positive();
        };
        ReconStructureParser.prototype.invoke = function (func, args) {
            return func.invoke(args).toValue();
        };
        ReconStructureParser.prototype.lambda = function (bindings, template) {
            return bindings.lambda(template);
        };
        ReconStructureParser.prototype.get = function (selector, key) {
            return selector.get(key);
        };
        ReconStructureParser.prototype.getAttr = function (selector, key) {
            return selector.getAttr(key);
        };
        ReconStructureParser.prototype.getItem = function (selector, index) {
            return selector.getItem(index);
        };
        ReconStructureParser.prototype.children = function (selector) {
            return Selector.literal(selector).children();
        };
        ReconStructureParser.prototype.descendants = function (selector) {
            return Selector.literal(selector).descendants();
        };
        ReconStructureParser.prototype.keys = function (selector) {
            return Selector.literal(selector).keys();
        };
        ReconStructureParser.prototype.values = function (selector) {
            return Selector.literal(selector).values();
        };
        ReconStructureParser.prototype.filter = function (selector, predicate) {
            return selector.filter(predicate);
        };
        return ReconStructureParser;
    }(ReconParser));

    var AttrWriter = (function (_super) {
        __extends(AttrWriter, _super);
        function AttrWriter(recon, key, value, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._value = value;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        AttrWriter.prototype.pull = function (output) {
            return AttrWriter.write(output, this._recon, this._key, this._value, this._part, this._step);
        };
        AttrWriter.sizeOf = function (recon, key, value) {
            var size = 0;
            size += 1;
            size += recon.sizeOfValue(key);
            if (!recon.isExtant(recon.item(value))) {
                size += 1;
                size += recon.sizeOfBlockValue(value);
                size += 1;
            }
            return size;
        };
        AttrWriter.write = function (output, recon, key, value, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(64);
                step = 2;
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    if (recon.isExtant(recon.item(value))) {
                        return Writer.done();
                    }
                    else {
                        step = 3;
                    }
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3 && output.isCont()) {
                output = output.write(40);
                step = 4;
            }
            if (step === 4) {
                if (!part) {
                    part = recon.writeBlockValue(value, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 5;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 5 && output.isCont()) {
                output = output.write(41);
                return Writer.done();
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new AttrWriter(recon, key, value, part, step);
        };
        return AttrWriter;
    }(Writer));

    var SlotWriter = (function (_super) {
        __extends(SlotWriter, _super);
        function SlotWriter(recon, key, value, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._value = value;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        SlotWriter.prototype.pull = function (output) {
            return SlotWriter.write(output, this._recon, this._key, this._value, this._part, this._step);
        };
        SlotWriter.sizeOf = function (recon, key, value) {
            var size = 0;
            size += recon.sizeOfValue(key);
            size += 1;
            if (!recon.isExtant(recon.item(value))) {
                size += recon.sizeOfValue(value);
            }
            return size;
        };
        SlotWriter.write = function (output, recon, key, value, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(58);
                if (recon.isExtant(recon.item(value))) {
                    return Writer.done();
                }
                else {
                    step = 3;
                }
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(value, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new SlotWriter(recon, key, value, part, step);
        };
        return SlotWriter;
    }(Writer));

    var BlockWriter = (function (_super) {
        __extends(BlockWriter, _super);
        function BlockWriter(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._items = items;
            _this._inBlock = inBlock;
            _this._inMarkup = inMarkup;
            _this._inBraces = inBraces;
            _this._inBrackets = inBrackets;
            _this._first = first;
            _this._markupSafe = markupSafe;
            _this._item = item;
            _this._next = next;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        BlockWriter.prototype.pull = function (output) {
            return BlockWriter.write(output, this._recon, this._items, this._inBlock, this._inMarkup, this._inBraces, this._inBrackets, this._first, this._markupSafe, this._item, this._next, this._part, this._step);
        };
        BlockWriter.sizeOf = function (recon, items, inBlock, inMarkup) {
            var size = 0;
            var inBraces = false;
            var inBrackets = false;
            var first = true;
            var markupSafe = true;
            var next;
            while (next || items.hasNext()) {
                var item = void 0;
                if (!next) {
                    item = items.next().value;
                }
                else {
                    item = next;
                    next = void 0;
                }
                if (items.hasNext()) {
                    next = items.next().value;
                }
                if (recon.isExpression(item)) {
                    markupSafe = false;
                }
                if (inBrackets && recon.isAttr(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    size += 1;
                    inBrackets = false;
                }
                if (recon.isAttr(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    else if (inBrackets) {
                        size += 1;
                        inBrackets = false;
                    }
                    size += recon.sizeOfItem(item);
                    first = false;
                }
                else if (inBrackets && recon.isText(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    size += recon.sizeOfMarkupText(item);
                }
                else if (inBraces) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += BlockWriter.sizeOfBlockItem(recon, item);
                }
                else if (inBrackets) {
                    if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
                        size += recon.sizeOfBlock(recon.items(item), false, true);
                        if (next && recon.isText(next)) {
                            size += recon.sizeOfMarkupText(next);
                            next = void 0;
                        }
                        else if (next && !recon.isAttr(next)) {
                            size += 1;
                            inBraces = true;
                            first = true;
                        }
                        else {
                            size += 1;
                            inBrackets = false;
                        }
                    }
                    else {
                        size += 1;
                        size += recon.sizeOfItem(item);
                        inBraces = true;
                        first = false;
                    }
                }
                else if (markupSafe && recon.isText(item) && next && !recon.isField(next)
                    && !recon.isText(next) && !recon.isBool(next)) {
                    size += 1;
                    size += recon.sizeOfMarkupText(item);
                    inBrackets = true;
                }
                else if (inBlock && !inBraces) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += BlockWriter.sizeOfBlockItem(recon, item);
                }
                else if (inMarkup && recon.isText(item) && !next) {
                    size += 1;
                    size += recon.sizeOfMarkupText(item);
                    size += 1;
                }
                else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)
                    && (!first && !next || next && recon.isAttr(next))) {
                    if (!first && (recon.isText(item) && recon.isIdent(item)
                        || recon.isNum(item) || recon.isBool(item))) {
                        size += 1;
                    }
                    size += recon.sizeOfItem(item);
                }
                else {
                    size += 1;
                    size += recon.sizeOfItem(item);
                    inBraces = true;
                    first = false;
                }
            }
            if (inBraces) {
                size += 1;
            }
            if (inBrackets) {
                size += 1;
            }
            return size;
        };
        BlockWriter.sizeOfBlockItem = function (recon, item) {
            var size = 0;
            if (recon.isField(item)) {
                size += recon.sizeOfSlot(recon.key(item), recon.value(item));
            }
            else {
                size += recon.sizeOfItem(item);
            }
            return size;
        };
        BlockWriter.write = function (output, recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step) {
            if (inBraces === void 0) { inBraces = false; }
            if (inBrackets === void 0) { inBrackets = false; }
            if (first === void 0) { first = true; }
            if (markupSafe === void 0) { markupSafe = true; }
            if (step === void 0) { step = 1; }
            do {
                if (step === 1) {
                    if (!next && !items.hasNext()) {
                        step = 10;
                        break;
                    }
                    else {
                        if (!next) {
                            item = items.next().value;
                        }
                        else {
                            item = next;
                            next = void 0;
                        }
                        if (items.hasNext()) {
                            next = items.next().value;
                        }
                        if (recon.isExpression(item)) {
                            markupSafe = false;
                        }
                        step = 2;
                    }
                }
                if (step === 2 && output.isCont()) {
                    if (inBrackets && recon.isAttr(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        step = 3;
                    }
                    else {
                        step = 4;
                    }
                }
                if (step === 3 && output.isCont()) {
                    output = output.write(93);
                    inBrackets = false;
                    step = 4;
                }
                if (step === 4 && output.isCont()) {
                    if (recon.isAttr(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        else if (inBrackets) {
                            output = output.write(93);
                            inBrackets = false;
                        }
                        part = recon.writeItem(item, output);
                        first = false;
                        step = 7;
                    }
                    else if (inBrackets && recon.isText(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        part = recon.writeMarkupText(item, output);
                        step = 7;
                    }
                    else if (inBraces) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = BlockWriter.writeBlockItem(output, recon, item);
                        step = 7;
                    }
                    else if (inBrackets) {
                        if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
                            part = recon.writeBlock(recon.items(item), output, false, true);
                            step = 5;
                        }
                        else {
                            output = output.write(123);
                            part = recon.writeItem(item, output);
                            inBraces = true;
                            first = false;
                            step = 7;
                        }
                    }
                    else if (markupSafe && recon.isText(item) && next && !recon.isField(next)
                        && !recon.isText(next) && !recon.isBool(next)) {
                        output = output.write(91);
                        part = recon.writeMarkupText(item, output);
                        inBrackets = true;
                        step = 7;
                    }
                    else if (inBlock && !inBraces) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = BlockWriter.writeBlockItem(output, recon, item);
                        step = 7;
                    }
                    else if (inMarkup && recon.isText(item) && !next) {
                        output = output.write(91);
                        part = recon.writeMarkupText(item, output);
                        step = 8;
                    }
                    else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)
                        && (!first && !next || next && recon.isAttr(next))) {
                        if (!first && (recon.isText(item) && recon.isIdent(item)
                            || recon.isNum(item) || recon.isBool(item))) {
                            output = output.write(32);
                        }
                        part = recon.writeItem(item, output);
                        step = 7;
                    }
                    else {
                        output = output.write(123);
                        part = recon.writeItem(item, output);
                        inBraces = true;
                        first = false;
                        step = 7;
                    }
                }
                if (step === 5) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 6;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 6 && output.isCont()) {
                    if (next && recon.isText(next)) {
                        part = recon.writeMarkupText(next, output);
                        next = void 0;
                        step = 7;
                    }
                    else if (next && !recon.isAttr(next)) {
                        output = output.write(123);
                        inBraces = true;
                        first = true;
                        step = 1;
                        continue;
                    }
                    else {
                        output = output.write(93);
                        inBrackets = false;
                        step = 1;
                        continue;
                    }
                }
                if (step === 7) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 1;
                        continue;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 8) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 9;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 9 && output.isCont()) {
                    output = output.write(93);
                    step = 1;
                    continue;
                }
                break;
            } while (true);
            if (step === 10) {
                if (inBraces) {
                    if (output.isCont()) {
                        output = output.write(125);
                        step = 11;
                    }
                }
                else {
                    step = 11;
                }
            }
            if (step === 11) {
                if (inBrackets) {
                    if (output.isCont()) {
                        output = output.write(93);
                        return Writer.done();
                    }
                }
                else {
                    return Writer.done();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new BlockWriter(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step);
        };
        BlockWriter.writeBlockItem = function (output, recon, item) {
            if (recon.isField(item)) {
                return recon.writeSlot(recon.key(item), recon.value(item), output);
            }
            else {
                return recon.writeItem(item, output);
            }
        };
        return BlockWriter;
    }(Writer));

    var PrimaryWriter = (function (_super) {
        __extends(PrimaryWriter, _super);
        function PrimaryWriter(recon, items, inParens, first, item, next, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._items = items;
            _this._inParens = inParens;
            _this._first = first;
            _this._item = item;
            _this._next = next;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        PrimaryWriter.prototype.pull = function (output) {
            return PrimaryWriter.write(output, this._recon, this._items, this._inParens, this._first, this._item, this._next, this._part, this._step);
        };
        PrimaryWriter.sizeOf = function (recon, items) {
            var size = 0;
            var inParens = false;
            var first = true;
            var next;
            while (next || items.hasNext()) {
                var item = void 0;
                if (!next) {
                    item = items.next().value;
                }
                else {
                    item = next;
                    next = void 0;
                }
                if (items.hasNext()) {
                    next = items.next().value;
                }
                if (!inParens && !first) {
                    size += 1;
                }
                if (recon.isAttr(item)) {
                    if (inParens) {
                        size += 1;
                        inParens = false;
                    }
                    size += recon.sizeOfItem(item);
                    first = false;
                }
                else if (inParens) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += recon.sizeOfBlockItem(item);
                }
                else if (recon.isValue(item) && !recon.isRecord(item)
                    && (!first && !next || next && recon.isAttr(next))) {
                    size += recon.sizeOfItem(item);
                }
                else {
                    size += 1;
                    size += recon.sizeOfItem(item);
                    inParens = true;
                    first = false;
                }
            }
            if (inParens) {
                size += 1;
            }
            return size;
        };
        PrimaryWriter.write = function (output, recon, items, inParens, first, item, next, part, step) {
            if (inParens === void 0) { inParens = false; }
            if (first === void 0) { first = true; }
            if (step === void 0) { step = 1; }
            do {
                if (step === 1) {
                    if (!next && !items.hasNext()) {
                        step = 5;
                        break;
                    }
                    else {
                        if (!next) {
                            item = items.next().value;
                        }
                        else {
                            item = next;
                            next = void 0;
                        }
                        if (items.hasNext()) {
                            next = items.next().value;
                        }
                        step = 2;
                    }
                }
                if (step === 2 && output.isCont()) {
                    if (!inParens && !first) {
                        output = output.write(32);
                    }
                    step = 3;
                }
                if (step === 3 && output.isCont()) {
                    if (recon.isAttr(item)) {
                        if (inParens) {
                            output = output.write(41);
                            inParens = false;
                        }
                        part = recon.writeItem(item, output);
                        first = false;
                        step = 4;
                    }
                    else if (inParens) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = recon.writeBlockItem(item, output);
                        step = 4;
                    }
                    else if (recon.isValue(item) && !recon.isRecord(item)
                        && (!first && !next || next && recon.isAttr(next))) {
                        part = recon.writeItem(item, output);
                        step = 4;
                    }
                    else {
                        output = output.write(40);
                        part = recon.writeItem(item, output);
                        inParens = true;
                        first = false;
                        step = 4;
                    }
                }
                if (step === 4) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 1;
                        continue;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                break;
            } while (true);
            if (step === 5) {
                if (inParens) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return Writer.done();
                    }
                }
                else {
                    return Writer.done();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new PrimaryWriter(recon, items, inParens, first, item, next, part, step);
        };
        return PrimaryWriter;
    }(Writer));

    var MarkupTextWriter = (function (_super) {
        __extends(MarkupTextWriter, _super);
        function MarkupTextWriter(text, index, escape, step) {
            var _this = _super.call(this) || this;
            _this._text = text;
            _this._index = index;
            _this._escape = escape;
            _this._step = step;
            return _this;
        }
        MarkupTextWriter.prototype.pull = function (output) {
            return MarkupTextWriter.write(output, this._text, this._index, this._escape, this._step);
        };
        MarkupTextWriter.sizeOf = function (text) {
            var size = 0;
            for (var i = 0, n = text.length; i < n; i = text.offsetByCodePoints(i, 1)) {
                var c = text.codePointAt(i);
                if (c === void 0) {
                    c = text.charCodeAt(i);
                }
                if (c === 36 || c === 64 || c === 91 || c === 92
                    || c === 93 || c === 123 || c === 125 || c === 8
                    || c === 12 || c === 10 || c === 13 || c === 9) {
                    size += 2;
                }
                else if (c < 0x20) {
                    size += 6;
                }
                else {
                    size += Utf8.sizeOf(c);
                }
            }
            return size;
        };
        MarkupTextWriter.write = function (output, text, index, escape, step) {
            if (index === void 0) { index = 0; }
            if (escape === void 0) { escape = 0; }
            if (step === void 0) { step = 1; }
            var length = text.length;
            while (output.isCont()) {
                if (step === 1) {
                    if (index < length) {
                        var c = text.codePointAt(index);
                        if (c === void 0) {
                            c = text.charCodeAt(index);
                        }
                        index = text.offsetByCodePoints(index, 1);
                        if (c === 36 || c === 64 || c === 91 || c === 92
                            || c === 93 || c === 123 || c === 125) {
                            output = output.write(92);
                            escape = c;
                            step = 2;
                        }
                        else if (c === 8) {
                            output = output.write(92);
                            escape = 98;
                            step = 2;
                        }
                        else if (c === 12) {
                            output = output.write(92);
                            escape = 102;
                            step = 2;
                        }
                        else if (c === 10) {
                            output = output.write(92);
                            escape = 110;
                            step = 2;
                        }
                        else if (c === 13) {
                            output = output.write(92);
                            escape = 114;
                            step = 2;
                        }
                        else if (c === 9) {
                            output = output.write(92);
                            escape = 116;
                            step = 2;
                        }
                        else if (c < 0x20) {
                            output = output.write(92);
                            escape = c;
                            step = 3;
                        }
                        else {
                            output = output.write(c);
                        }
                    }
                    else {
                        return Writer.done();
                    }
                }
                else if (step === 2) {
                    output = output.write(escape);
                    escape = 0;
                    step = 1;
                }
                else if (step === 3) {
                    output = output.write(117);
                    step = 4;
                }
                else if (step === 4) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));
                    step = 5;
                }
                else if (step === 5) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));
                    step = 6;
                }
                else if (step === 6) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));
                    step = 7;
                }
                else if (step === 7) {
                    output = output.write(Base16.uppercase().encodeDigit(escape & 0xf));
                    escape = 0;
                    step = 1;
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new MarkupTextWriter(text, index, escape, step);
        };
        return MarkupTextWriter;
    }(Writer));

    var DataWriter = (function (_super) {
        __extends(DataWriter, _super);
        function DataWriter(array, part, step) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        DataWriter.prototype.pull = function (output) {
            return DataWriter.write(output, this._array, this._part, this._step);
        };
        DataWriter.sizeOf = function (length) {
            return 1 + ((Math.floor(length * 4 / 3) + 3) & ~3);
        };
        DataWriter.write = function (output, array, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(37);
                step = 2;
            }
            if (step === 2) {
                if (!part) {
                    part = Base64.standard().writeUint8Array(array, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    return Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new DataWriter(array, part, step);
        };
        return DataWriter;
    }(Writer));

    var IdentWriter = (function (_super) {
        __extends(IdentWriter, _super);
        function IdentWriter(ident, index) {
            var _this = _super.call(this) || this;
            _this._ident = ident;
            _this._index = index;
            return _this;
        }
        IdentWriter.prototype.pull = function (output) {
            return IdentWriter.write(output, this._ident, this._index);
        };
        IdentWriter.sizeOf = function (ident) {
            return Utf8.sizeOf(ident);
        };
        IdentWriter.write = function (output, ident, index) {
            if (index === void 0) { index = 0; }
            var c;
            var length = ident.length;
            if (length === 0) {
                return Writer.error(new WriterException("empty identifier"));
            }
            if (index === 0 && output.isCont()) {
                c = ident.codePointAt(0);
                if (c === void 0) {
                    c = ident.charCodeAt(0);
                }
                if (Recon.isIdentStartChar(c)) {
                    output = output.write(c);
                    index = ident.offsetByCodePoints(0, 1);
                }
            }
            while (index < length && output.isCont()) {
                c = ident.codePointAt(index);
                if (c === void 0) {
                    c = ident.charCodeAt(index);
                }
                if (Recon.isIdentChar(c)) {
                    output = output.write(c);
                    index = ident.offsetByCodePoints(index, 1);
                }
                else {
                    return Writer.error(new WriterException("invalid identifier"));
                }
            }
            if (index >= length) {
                return Writer.done();
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new IdentWriter(ident, index);
        };
        return IdentWriter;
    }(Writer));

    var StringWriter$1 = (function (_super) {
        __extends(StringWriter, _super);
        function StringWriter(string, index, escape, step) {
            var _this = _super.call(this) || this;
            _this._string = string;
            _this._index = index;
            _this._escape = escape;
            _this._step = step;
            return _this;
        }
        StringWriter.prototype.pull = function (output) {
            return StringWriter.write(output, this._string, this._index, this._escape, this._step);
        };
        StringWriter.sizeOf = function (string) {
            var size = 0;
            size += 1;
            for (var i = 0, n = string.length; i < n; i = string.offsetByCodePoints(i, 1)) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c === 34 || c === 92 || c === 8 || c === 12
                    || c === 10 || c === 13 || c === 9) {
                    size += 2;
                }
                else if (c < 0x20) {
                    size += 6;
                }
                else {
                    size += Utf8.sizeOf(c);
                }
            }
            size += 1;
            return size;
        };
        StringWriter.write = function (output, string, index, escape, step) {
            if (index === void 0) { index = 0; }
            if (escape === void 0) { escape = 0; }
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(34);
                step = 2;
            }
            var length = string.length;
            while (step >= 2 && step <= 8 && output.isCont()) {
                if (step === 2) {
                    if (index < length) {
                        var c = string.codePointAt(index);
                        if (c === void 0) {
                            c = string.charCodeAt(index);
                        }
                        index = string.offsetByCodePoints(index, 1);
                        if (c === 34 || c === 92) {
                            output = output.write(92);
                            escape = c;
                            step = 3;
                        }
                        else if (c === 8) {
                            output = output.write(92);
                            escape = 98;
                            step = 3;
                        }
                        else if (c === 12) {
                            output = output.write(92);
                            escape = 102;
                            step = 3;
                        }
                        else if (c === 10) {
                            output = output.write(92);
                            escape = 110;
                            step = 3;
                        }
                        else if (c === 13) {
                            output = output.write(92);
                            escape = 114;
                            step = 3;
                        }
                        else if (c === 9) {
                            output = output.write(92);
                            escape = 116;
                            step = 3;
                        }
                        else if (c < 0x20) {
                            output = output.write('\\');
                            escape = c;
                            step = 4;
                        }
                        else {
                            output = output.write(c);
                        }
                    }
                    else {
                        step = 9;
                        break;
                    }
                }
                else if (step === 3) {
                    output = output.write(escape);
                    escape = 0;
                    step = 2;
                }
                else if (step === 4) {
                    output = output.write(117);
                    step = 5;
                }
                else if (step === 5) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));
                    step = 6;
                }
                else if (step === 6) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));
                    step = 7;
                }
                else if (step === 7) {
                    output = output.write(Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));
                    step = 8;
                }
                else if (step === 8) {
                    output = output.write(Base16.uppercase().encodeDigit(escape & 0xf));
                    escape = 0;
                    step = 2;
                }
            }
            if (step === 9 && output.isCont()) {
                output = output.write(34);
                return Writer.done();
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new StringWriter(string, index, escape, step);
        };
        return StringWriter;
    }(Writer));

    var LambdaFuncWriter = (function (_super) {
        __extends(LambdaFuncWriter, _super);
        function LambdaFuncWriter(recon, bindings, template, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._bindings = bindings;
            _this._template = template;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        LambdaFuncWriter.prototype.pull = function (output) {
            return LambdaFuncWriter.write(output, this._recon, this._bindings, this._template, this._part, this._step);
        };
        LambdaFuncWriter.sizeOf = function (recon, bindings, template) {
            var size = 0;
            size += recon.sizeOfPrimary(bindings);
            size += 4;
            size += recon.sizeOfValue(template);
            return size;
        };
        LambdaFuncWriter.write = function (output, recon, bindings, template, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writePrimary(bindings, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(32);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(61);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(62);
                step = 5;
            }
            if (step === 5 && output.isCont()) {
                output = output.write(32);
                step = 6;
            }
            if (step === 6) {
                if (part == null) {
                    part = recon.writeValue(template, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new LambdaFuncWriter(recon, bindings, template, part, step);
        };
        return LambdaFuncWriter;
    }(Writer));

    var ConditionalOperatorWriter = (function (_super) {
        __extends(ConditionalOperatorWriter, _super);
        function ConditionalOperatorWriter(recon, ifTerm, thenTerm, elseTerm, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._ifTerm = ifTerm;
            _this._thenTerm = thenTerm;
            _this._elseTerm = elseTerm;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        ConditionalOperatorWriter.prototype.pull = function (output) {
            return ConditionalOperatorWriter.write(output, this._recon, this._ifTerm, this._thenTerm, this._elseTerm, this._precedence, this._part, this._step);
        };
        ConditionalOperatorWriter.sizeOf = function (recon, ifTerm, thenTerm, elseTerm, precedence) {
            var size = 0;
            if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                size += 1;
                size += recon.sizeOfItem(ifTerm);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(ifTerm);
            }
            size += 3;
            size += recon.sizeOfItem(thenTerm);
            size += 3;
            size += recon.sizeOfItem(elseTerm);
            return size;
        };
        ConditionalOperatorWriter.write = function (output, recon, ifTerm, thenTerm, elseTerm, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(ifTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(32);
                step = 5;
            }
            if (step === 5 && output.isCont()) {
                output = output.write(63);
                step = 6;
            }
            if (step === 6 && output.isCont()) {
                output = output.write(32);
                step = 7;
            }
            if (step === 7) {
                if (!part) {
                    part = recon.writeItem(thenTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 8;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 8 && output.isCont()) {
                output = output.write(32);
                step = 9;
            }
            if (step === 9 && output.isCont()) {
                output = output.write(58);
                step = 10;
            }
            if (step === 10 && output.isCont()) {
                output = output.write(32);
                step = 11;
            }
            if (step === 11) {
                if (!part) {
                    part = recon.writeItem(elseTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new ConditionalOperatorWriter(recon, ifTerm, thenTerm, elseTerm, precedence, part, step);
        };
        return ConditionalOperatorWriter;
    }(Writer));

    var InfixOperatorWriter = (function (_super) {
        __extends(InfixOperatorWriter, _super);
        function InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._lhs = lhs;
            _this._operator = operator;
            _this._rhs = rhs;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        InfixOperatorWriter.prototype.pull = function (output) {
            return InfixOperatorWriter.write(output, this._recon, this._lhs, this._operator, this._rhs, this._precedence, this._part, this._step);
        };
        InfixOperatorWriter.sizeOf = function (recon, lhs, operator, rhs, precedence) {
            var size = 0;
            if (recon.precedence(lhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(lhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(lhs);
            }
            size += 1;
            size += Utf8.sizeOf(operator);
            size += 1;
            if (recon.precedence(rhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(rhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(rhs);
            }
            return size;
        };
        InfixOperatorWriter.write = function (output, recon, lhs, operator, rhs, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(lhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(lhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(lhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(32);
                step = 5;
            }
            if (step === 5) {
                if (!part) {
                    part = Unicode.writeString(operator, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 6;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 6 && output.isCont()) {
                output = output.write(32);
                step = 7;
            }
            if (step === 7) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 8;
                    }
                }
                else {
                    step = 8;
                }
            }
            if (step === 8) {
                if (!part) {
                    part = recon.writeItem(rhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 9;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 9) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return Writer.done();
                    }
                }
                else {
                    return Writer.done();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step);
        };
        return InfixOperatorWriter;
    }(Writer));

    var PrefixOperatorWriter = (function (_super) {
        __extends(PrefixOperatorWriter, _super);
        function PrefixOperatorWriter(recon, operator, rhs, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._operator = operator;
            _this._rhs = rhs;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        PrefixOperatorWriter.prototype.pull = function (output) {
            return PrefixOperatorWriter.write(output, this._recon, this._operator, this._rhs, this._precedence, this._part, this._step);
        };
        PrefixOperatorWriter.sizeOf = function (recon, operator, rhs, precedence) {
            var size = 0;
            size += Utf8.sizeOf(operator);
            if (recon.precedence(rhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(rhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(rhs);
            }
            return size;
        };
        PrefixOperatorWriter.write = function (output, recon, operator, rhs, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = Unicode.writeString(operator, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 3;
                    }
                }
                else {
                    step = 3;
                }
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeItem(rhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return Writer.done();
                    }
                }
                else {
                    return Writer.done();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new PrefixOperatorWriter(recon, operator, rhs, precedence, part, step);
        };
        return PrefixOperatorWriter;
    }(Writer));

    var InvokeOperatorWriter = (function (_super) {
        __extends(InvokeOperatorWriter, _super);
        function InvokeOperatorWriter(recon, func, args, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._func = func;
            _this._args = args;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        InvokeOperatorWriter.prototype.pull = function (output) {
            return InvokeOperatorWriter.write(output, this._recon, this._func, this._args, this._part, this._step);
        };
        InvokeOperatorWriter.sizeOf = function (recon, func, args) {
            var size = 0;
            size += recon.sizeOfValue(func);
            size += 1;
            size += recon.sizeOfBlockValue(args);
            size += 1;
            return size;
        };
        InvokeOperatorWriter.write = function (output, recon, func, args, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writeValue(func, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(40);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeBlockValue(args, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(41);
                return Writer.done();
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new InvokeOperatorWriter(recon, func, args, part, step);
        };
        return InvokeOperatorWriter;
    }(Writer));

    var LiteralSelectorWriter = (function (_super) {
        __extends(LiteralSelectorWriter, _super);
        function LiteralSelectorWriter(recon, item, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._item = item;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        LiteralSelectorWriter.prototype.pull = function (output) {
            return LiteralSelectorWriter.write(output, this._recon, this._item, this._then, this._part, this._step);
        };
        LiteralSelectorWriter.sizeOf = function (recon, item, then) {
            var size = 0;
            if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                size += 1;
                size += recon.sizeOfItem(item);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(item);
            }
            size += recon.sizeOfThen(then);
            return size;
        };
        LiteralSelectorWriter.write = function (output, recon, item, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(item, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4) {
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new LiteralSelectorWriter(recon, item, then, part, step);
        };
        return LiteralSelectorWriter;
    }(Writer));

    var GetSelectorWriter = (function (_super) {
        __extends(GetSelectorWriter, _super);
        function GetSelectorWriter(recon, key, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetSelectorWriter.prototype.pull = function (output) {
            return GetSelectorWriter.write(output, this._recon, this._key, this._then, this._part, this._step);
        };
        GetSelectorWriter.sizeOf = function (recon, key, then) {
            var size = 1;
            if (recon.isRecord(recon.item(key))) {
                size += 1;
                size += recon.sizeOfBlockValue(key);
                size += 1;
            }
            else {
                size += recon.sizeOfValue(key);
            }
            size += recon.sizeOfThen(then);
            return size;
        };
        GetSelectorWriter.write = function (output, recon, key, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3) {
                if (recon.isRecord(recon.item(key))) {
                    if (output.isCont()) {
                        output = output.write(123);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4) {
                if (!part) {
                    if (recon.isRecord(recon.item(key))) {
                        part = recon.writeBlockValue(key, output);
                    }
                    else {
                        part = recon.writeValue(key, output);
                    }
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 5;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 5) {
                if (recon.isRecord(recon.item(key))) {
                    if (output.isCont()) {
                        output = output.write(125);
                        step = 6;
                    }
                }
                else {
                    step = 6;
                }
            }
            if (step === 6) {
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new GetSelectorWriter(recon, key, then, part, step);
        };
        GetSelectorWriter.writeThen = function (output, recon, key, then) {
            return GetSelectorWriter.write(output, recon, key, then, void 0, 2);
        };
        return GetSelectorWriter;
    }(Writer));

    var GetAttrSelectorWriter = (function (_super) {
        __extends(GetAttrSelectorWriter, _super);
        function GetAttrSelectorWriter(recon, key, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetAttrSelectorWriter.prototype.pull = function (output) {
            return GetAttrSelectorWriter.write(output, this._recon, this._key, this._then, this._part, this._step);
        };
        GetAttrSelectorWriter.sizeOf = function (recon, key, then) {
            var size = 2;
            size += recon.sizeOfValue(key);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetAttrSelectorWriter.write = function (output, recon, key, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(64);
                step = 4;
            }
            if (step === 4) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return recon.writeThen(then, output);
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new GetAttrSelectorWriter(recon, key, then, part, step);
        };
        GetAttrSelectorWriter.writeThen = function (output, recon, key, then) {
            return GetAttrSelectorWriter.write(output, recon, key, then, void 0, 2);
        };
        return GetAttrSelectorWriter;
    }(Writer));

    var GetItemSelectorWriter = (function (_super) {
        __extends(GetItemSelectorWriter, _super);
        function GetItemSelectorWriter(recon, index, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._index = index;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetItemSelectorWriter.prototype.pull = function (output) {
            return GetItemSelectorWriter.write(output, this._recon, this._index, this._then, this._part, this._step);
        };
        GetItemSelectorWriter.sizeOf = function (recon, index, then) {
            var size = 2;
            size += recon.sizeOfValue(index);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetItemSelectorWriter.sizeOfThen = function (recon, index, then) {
            var size = 1;
            size += recon.sizeOfValue(index);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetItemSelectorWriter.write = function (output, recon, index, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(35);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(index, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return recon.writeThen(then, output);
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new GetItemSelectorWriter(recon, index, then, part, step);
        };
        GetItemSelectorWriter.writeThen = function (output, recon, index, then) {
            return GetItemSelectorWriter.write(output, recon, index, then, void 0, 2);
        };
        return GetItemSelectorWriter;
    }(Writer));

    var KeysSelectorWriter = (function (_super) {
        __extends(KeysSelectorWriter, _super);
        function KeysSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        KeysSelectorWriter.prototype.pull = function (output) {
            return KeysSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        KeysSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        KeysSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(58);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new KeysSelectorWriter(recon, then, step);
        };
        KeysSelectorWriter.writeThen = function (output, recon, then) {
            return KeysSelectorWriter.write(output, recon, then, 2);
        };
        return KeysSelectorWriter;
    }(Writer));

    var ValuesSelectorWriter = (function (_super) {
        __extends(ValuesSelectorWriter, _super);
        function ValuesSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        ValuesSelectorWriter.prototype.pull = function (output) {
            return ValuesSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        ValuesSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        ValuesSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(58);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new ValuesSelectorWriter(recon, then, step);
        };
        ValuesSelectorWriter.writeThen = function (output, recon, then) {
            return ValuesSelectorWriter.write(output, recon, then, 2);
        };
        return ValuesSelectorWriter;
    }(Writer));

    var ChildrenSelectorWriter = (function (_super) {
        __extends(ChildrenSelectorWriter, _super);
        function ChildrenSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        ChildrenSelectorWriter.prototype.pull = function (output) {
            return ChildrenSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        ChildrenSelectorWriter.sizeOf = function (recon, then) {
            var size = 2;
            size += recon.sizeOfThen(then);
            return size;
        };
        ChildrenSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new ChildrenSelectorWriter(recon, then, step);
        };
        ChildrenSelectorWriter.writeThen = function (output, recon, then) {
            return ChildrenSelectorWriter.write(output, recon, then, 2);
        };
        return ChildrenSelectorWriter;
    }(Writer));

    var DescendantsSelectorWriter = (function (_super) {
        __extends(DescendantsSelectorWriter, _super);
        function DescendantsSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        DescendantsSelectorWriter.prototype.pull = function (output) {
            return DescendantsSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        DescendantsSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        DescendantsSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new DescendantsSelectorWriter(recon, then, step);
        };
        DescendantsSelectorWriter.writeThen = function (output, recon, then) {
            return DescendantsSelectorWriter.write(output, recon, then, 2);
        };
        return DescendantsSelectorWriter;
    }(Writer));

    var FilterSelectorWriter = (function (_super) {
        __extends(FilterSelectorWriter, _super);
        function FilterSelectorWriter(recon, predicate, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._predicate = predicate;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        FilterSelectorWriter.prototype.pull = function (output) {
            return FilterSelectorWriter.write(output, this._recon, this._predicate, this._then, this._part, this._step);
        };
        FilterSelectorWriter.sizeOf = function (recon, predicate, then) {
            var size = 2;
            size += recon.sizeOfValue(predicate);
            size += 1;
            size += recon.sizeOfThen(then);
            return size;
        };
        FilterSelectorWriter.sizeOfThen = function (recon, predicate, then) {
            var size = 1;
            size += recon.sizeOfValue(predicate);
            size += 1;
            size += recon.sizeOfThen(then);
            return size;
        };
        FilterSelectorWriter.write = function (output, recon, predicate, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(91);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(predicate, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(93);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return Writer.error(new WriterException("truncated"));
            }
            else if (output.isError()) {
                return Writer.error(output.trap());
            }
            return new FilterSelectorWriter(recon, predicate, then, part, step);
        };
        FilterSelectorWriter.writeThen = function (output, recon, predicate, then) {
            return FilterSelectorWriter.write(output, recon, predicate, then, void 0, 2);
        };
        return FilterSelectorWriter;
    }(Writer));

    var ReconWriter = (function () {
        function ReconWriter() {
        }
        ReconWriter.prototype.sizeOfAttr = function (key, value) {
            return AttrWriter.sizeOf(this, key, value);
        };
        ReconWriter.prototype.writeAttr = function (key, value, output) {
            return AttrWriter.write(output, this, key, value);
        };
        ReconWriter.prototype.sizeOfSlot = function (key, value) {
            return SlotWriter.sizeOf(this, key, value);
        };
        ReconWriter.prototype.writeSlot = function (key, value, output) {
            return SlotWriter.write(output, this, key, value);
        };
        ReconWriter.prototype.sizeOfBlock = function (item, inBlock, inMarkup) {
            if (arguments.length === 3) {
                return BlockWriter.sizeOf(this, item, inBlock, inMarkup);
            }
            else {
                var items = this.items(item);
                if (items.hasNext()) {
                    return BlockWriter.sizeOf(this, items, this.isBlockSafe(this.items(item)), false);
                }
                else {
                    return 2;
                }
            }
        };
        ReconWriter.prototype.writeBlock = function (item, output, inBlock, inMarkup) {
            if (arguments.length === 4) {
                return BlockWriter.write(output, this, item, inBlock, inMarkup);
            }
            else {
                var items = this.items(item);
                if (items.hasNext()) {
                    return BlockWriter.write(output, this, items, this.isBlockSafe(this.items(item)), false);
                }
                else {
                    return Unicode.writeString("{}", output);
                }
            }
        };
        ReconWriter.prototype.sizeOfRecord = function (item) {
            var items = this.items(item);
            if (items.hasNext()) {
                return BlockWriter.sizeOf(this, items, false, false);
            }
            else {
                return 2;
            }
        };
        ReconWriter.prototype.writeRecord = function (item, output) {
            var items = this.items(item);
            if (items.hasNext()) {
                return BlockWriter.write(output, this, items, false, false);
            }
            else {
                return Unicode.writeString("{}", output);
            }
        };
        ReconWriter.prototype.sizeOfPrimary = function (value) {
            if (this.isRecord(this.item(value))) {
                var items = this.items(this.item(value));
                if (items.hasNext()) {
                    return PrimaryWriter.sizeOf(this, items);
                }
            }
            else if (!this.isExtant(this.item(value))) {
                return this.sizeOfValue(value);
            }
            return 2;
        };
        ReconWriter.prototype.writePrimary = function (value, output) {
            if (this.isRecord(this.item(value))) {
                var items = this.items(this.item(value));
                if (items.hasNext()) {
                    return PrimaryWriter.write(output, this, items);
                }
            }
            else if (!this.isExtant(this.item(value))) {
                return this.writeValue(value, output);
            }
            return Unicode.writeString("()", output);
        };
        ReconWriter.prototype.isBlockSafe = function (items) {
            while (items.hasNext()) {
                if (this.isAttr(items.next().value)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.isMarkupSafe = function (items) {
            if (!items.hasNext() || !this.isAttr(items.next().value)) {
                return false;
            }
            while (items.hasNext()) {
                if (this.isAttr(items.next().value)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.sizeOfMarkupText = function (item) {
            if (typeof item !== "string") {
                item = this.string(item);
            }
            return MarkupTextWriter.sizeOf(item);
        };
        ReconWriter.prototype.writeMarkupText = function (item, output) {
            if (typeof item !== "string") {
                item = this.string(item);
            }
            return MarkupTextWriter.write(output, item);
        };
        ReconWriter.prototype.sizeOfData = function (length) {
            return DataWriter.sizeOf(length);
        };
        ReconWriter.prototype.writeData = function (value, output) {
            if (value) {
                return DataWriter.write(output, value);
            }
            else {
                return Unicode.writeString("%", output);
            }
        };
        ReconWriter.prototype.isIdent = function (value) {
            if (typeof value !== "string") {
                value = this.string(value);
            }
            var n = value.length;
            var c;
            if (n === 0 || (c = value.codePointAt(0), c !== void 0 && !Recon.isIdentStartChar(c))) {
                return false;
            }
            for (var i = value.offsetByCodePoints(0, 1); i < n; i = value.offsetByCodePoints(i, 1)) {
                c = value.codePointAt(i);
                if (c === void 0 || !Recon.isIdentChar(c)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.sizeOfText = function (value) {
            if (this.isIdent(value)) {
                return IdentWriter.sizeOf(value);
            }
            else {
                return StringWriter$1.sizeOf(value);
            }
        };
        ReconWriter.prototype.writeText = function (value, output) {
            if (this.isIdent(value)) {
                return IdentWriter.write(output, value);
            }
            else {
                return StringWriter$1.write(output, value);
            }
        };
        ReconWriter.prototype.sizeOfNum = function (value) {
            if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
                var size = Base10.countDigits(value);
                if (value < 0) {
                    size += 1;
                }
                return size;
            }
            else {
                return ("" + value).length;
            }
        };
        ReconWriter.prototype.writeNum = function (value, output) {
            if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
                return Base10.writeInteger(value, output);
            }
            else {
                return Unicode.writeString("" + value, output);
            }
        };
        ReconWriter.prototype.sizeOfUint32 = function (value) {
            return 10;
        };
        ReconWriter.prototype.writeUint32 = function (value, output) {
            return Base16.lowercase().writeIntegerLiteral(value, output, 8);
        };
        ReconWriter.prototype.sizeOfUint64 = function (value) {
            return 18;
        };
        ReconWriter.prototype.writeUint64 = function (value, output) {
            return Base16.lowercase().writeIntegerLiteral(value, output, 16);
        };
        ReconWriter.prototype.sizeOfBool = function (value) {
            return value ? 4 : 5;
        };
        ReconWriter.prototype.writeBool = function (value, output) {
            return Unicode.writeString(value ? "true" : "false", output);
        };
        ReconWriter.prototype.sizeOfLambdaFunc = function (bindings, template) {
            return LambdaFuncWriter.sizeOf(this, bindings, template);
        };
        ReconWriter.prototype.writeLambdaFunc = function (bindings, template, output) {
            return LambdaFuncWriter.write(output, this, bindings, template);
        };
        ReconWriter.prototype.sizeOfConditionalOperator = function (ifTerm, thenTerm, elseTerm, precedence) {
            return ConditionalOperatorWriter.sizeOf(this, ifTerm, thenTerm, elseTerm, precedence);
        };
        ReconWriter.prototype.writeConditionalOperator = function (ifTerm, thenTerm, elseTerm, precedence, output) {
            return ConditionalOperatorWriter.write(output, this, ifTerm, thenTerm, elseTerm, precedence);
        };
        ReconWriter.prototype.sizeOfInfixOperator = function (lhs, operator, rhs, precedence) {
            return InfixOperatorWriter.sizeOf(this, lhs, operator, rhs, precedence);
        };
        ReconWriter.prototype.writeInfixOperator = function (lhs, operator, rhs, precedence, output) {
            return InfixOperatorWriter.write(output, this, lhs, operator, rhs, precedence);
        };
        ReconWriter.prototype.sizeOfPrefixOperator = function (operator, rhs, precedence) {
            return PrefixOperatorWriter.sizeOf(this, operator, rhs, precedence);
        };
        ReconWriter.prototype.writePrefixOperator = function (operator, rhs, precedence, output) {
            return PrefixOperatorWriter.write(output, this, operator, rhs, precedence);
        };
        ReconWriter.prototype.sizeOfInvokeOperator = function (func, args) {
            return InvokeOperatorWriter.sizeOf(this, func, args);
        };
        ReconWriter.prototype.writeInvokeOperator = function (func, args, output) {
            return InvokeOperatorWriter.write(output, this, func, args);
        };
        ReconWriter.prototype.sizeOfIdentitySelector = function () {
            return 0;
        };
        ReconWriter.prototype.writeIdentitySelector = function (output) {
            return Writer.done();
        };
        ReconWriter.prototype.sizeOfThenIdentitySelector = function () {
            return 0;
        };
        ReconWriter.prototype.writeThenIdentitySelector = function (output) {
            return Writer.done();
        };
        ReconWriter.prototype.sizeOfLiteralSelector = function (item, then) {
            return LiteralSelectorWriter.sizeOf(this, item, then);
        };
        ReconWriter.prototype.writeLiteralSelector = function (item, then, output) {
            return LiteralSelectorWriter.write(output, this, item, then);
        };
        ReconWriter.prototype.sizeOfThenLiteralSelector = function (item, then) {
            return 0;
        };
        ReconWriter.prototype.writeThenLiteralSelector = function (item, then, output) {
            return Writer.done();
        };
        ReconWriter.prototype.sizeOfGetSelector = function (key, then) {
            return GetSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeGetSelector = function (key, then, output) {
            return GetSelectorWriter.write(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfThenGetSelector = function (key, then) {
            return GetSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeThenGetSelector = function (key, then, output) {
            return GetSelectorWriter.writeThen(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfGetAttrSelector = function (key, then) {
            return GetAttrSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeGetAttrSelector = function (key, then, output) {
            return GetAttrSelectorWriter.write(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfThenGetAttrSelector = function (key, then) {
            return GetAttrSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeThenGetAttrSelector = function (key, then, output) {
            return GetAttrSelectorWriter.writeThen(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfGetItemSelector = function (index, then) {
            return GetItemSelectorWriter.sizeOf(this, index, then);
        };
        ReconWriter.prototype.writeGetItemSelector = function (index, then, output) {
            return GetItemSelectorWriter.write(output, this, index, then);
        };
        ReconWriter.prototype.sizeOfThenGetItemSelector = function (index, then) {
            return GetItemSelectorWriter.sizeOfThen(this, index, then);
        };
        ReconWriter.prototype.writeThenGetItemSelector = function (index, then, output) {
            return GetItemSelectorWriter.writeThen(output, this, index, then);
        };
        ReconWriter.prototype.sizeOfKeysSelector = function (then) {
            return KeysSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeKeysSelector = function (then, output) {
            return KeysSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenKeysSelector = function (then) {
            return KeysSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenKeysSelector = function (then, output) {
            return KeysSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfValuesSelector = function (then) {
            return ValuesSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeValuesSelector = function (then, output) {
            return ValuesSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenValuesSelector = function (then) {
            return ValuesSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenValuesSelector = function (then, output) {
            return ValuesSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfChildrenSelector = function (then) {
            return ChildrenSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeChildrenSelector = function (then, output) {
            return ChildrenSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenChildrenSelector = function (then) {
            return ChildrenSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenChildrenSelector = function (then, output) {
            return ChildrenSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfDescendantsSelector = function (then) {
            return DescendantsSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeDescendantsSelector = function (then, output) {
            return DescendantsSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenDescendantsSelector = function (then) {
            return DescendantsSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenDescendantsSelector = function (then, output) {
            return DescendantsSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfFilterSelector = function (predicate, then) {
            return FilterSelectorWriter.sizeOf(this, predicate, then);
        };
        ReconWriter.prototype.writeFilterSelector = function (predicate, then, output) {
            return FilterSelectorWriter.write(output, this, predicate, then);
        };
        ReconWriter.prototype.sizeOfThenFilterSelector = function (predicate, then) {
            return FilterSelectorWriter.sizeOfThen(this, predicate, then);
        };
        ReconWriter.prototype.writeThenFilterSelector = function (predicate, then, output) {
            return FilterSelectorWriter.writeThen(output, this, predicate, then);
        };
        ReconWriter.prototype.sizeOfExtant = function () {
            return 0;
        };
        ReconWriter.prototype.writeExtant = function (output) {
            return Writer.done();
        };
        ReconWriter.prototype.sizeOfAbsent = function () {
            return 0;
        };
        ReconWriter.prototype.writeAbsent = function (output) {
            return Writer.done();
        };
        return ReconWriter;
    }());

    var ReconStructureWriter = (function (_super) {
        __extends(ReconStructureWriter, _super);
        function ReconStructureWriter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReconStructureWriter.prototype.isField = function (item) {
            return item instanceof Field;
        };
        ReconStructureWriter.prototype.isAttr = function (item) {
            return item instanceof Attr;
        };
        ReconStructureWriter.prototype.isSlot = function (item) {
            return item instanceof Slot;
        };
        ReconStructureWriter.prototype.isValue = function (item) {
            return item instanceof Value;
        };
        ReconStructureWriter.prototype.isRecord = function (item) {
            return item instanceof Record;
        };
        ReconStructureWriter.prototype.isText = function (item) {
            return item instanceof Text;
        };
        ReconStructureWriter.prototype.isNum = function (item) {
            return item instanceof Num;
        };
        ReconStructureWriter.prototype.isBool = function (item) {
            return item instanceof Bool;
        };
        ReconStructureWriter.prototype.isExpression = function (item) {
            return item instanceof Expression;
        };
        ReconStructureWriter.prototype.isExtant = function (item) {
            return item instanceof Extant;
        };
        ReconStructureWriter.prototype.items = function (item) {
            return item.iterator();
        };
        ReconStructureWriter.prototype.item = function (value) {
            return value;
        };
        ReconStructureWriter.prototype.key = function (item) {
            return item.key;
        };
        ReconStructureWriter.prototype.value = function (item) {
            return item.toValue();
        };
        ReconStructureWriter.prototype.string = function (item) {
            return item.stringValue("");
        };
        ReconStructureWriter.prototype.precedence = function (item) {
            return item.precedence();
        };
        ReconStructureWriter.prototype.sizeOfItem = function (item) {
            if (item instanceof Field) {
                if (item instanceof Attr) {
                    return this.sizeOfAttr(item.key, item.value);
                }
                else if (item instanceof Slot) {
                    return this.sizeOfSlot(item.key, item.value);
                }
            }
            else if (item instanceof Value) {
                return this.sizeOfValue(item);
            }
            throw new WriterException("No Recon serialization for " + item);
        };
        ReconStructureWriter.prototype.writeItem = function (item, output) {
            if (item instanceof Field) {
                if (item instanceof Attr) {
                    return this.writeAttr(item.key, item.value, output);
                }
                else if (item instanceof Slot) {
                    return this.writeSlot(item.key, item.value, output);
                }
            }
            else if (item instanceof Value) {
                return this.writeValue(item, output);
            }
            return Writer.error(new WriterException("No Recon serialization for " + item));
        };
        ReconStructureWriter.prototype.sizeOfValue = function (value) {
            if (value instanceof Record) {
                return this.sizeOfRecord(value);
            }
            else if (value instanceof Data) {
                return this.sizeOfData(value.size);
            }
            else if (value instanceof Text) {
                return this.sizeOfText(value.value);
            }
            else if (value instanceof Num) {
                if (value.isUint32()) {
                    return this.sizeOfUint32(value.value);
                }
                else if (value.isUint64()) {
                    return this.sizeOfUint64(value.value);
                }
                else {
                    return this.sizeOfNum(value.value);
                }
            }
            else if (value instanceof Bool) {
                return this.sizeOfBool(value.value);
            }
            else if (value instanceof Selector) {
                return this.sizeOfSelector(value);
            }
            else if (value instanceof Operator) {
                return this.sizeOfOperator(value);
            }
            else if (value instanceof Func) {
                return this.sizeOfFunc(value);
            }
            else if (value instanceof Extant) {
                return this.sizeOfExtant();
            }
            else if (value instanceof Absent) {
                return this.sizeOfAbsent();
            }
            throw new WriterException("No Recon serialization for " + value);
        };
        ReconStructureWriter.prototype.writeValue = function (value, output) {
            if (value instanceof Record) {
                return this.writeRecord(value, output);
            }
            else if (value instanceof Data) {
                return this.writeData(value.asUint8Array(), output);
            }
            else if (value instanceof Text) {
                return this.writeText(value.value, output);
            }
            else if (value instanceof Num) {
                if (value.isUint32()) {
                    return this.writeUint32(value.value, output);
                }
                else if (value.isUint64()) {
                    return this.writeUint64(value.value, output);
                }
                else {
                    return this.writeNum(value.value, output);
                }
            }
            else if (value instanceof Bool) {
                return this.writeBool(value.value, output);
            }
            else if (value instanceof Selector) {
                return this.writeSelector(value, output);
            }
            else if (value instanceof Operator) {
                return this.writeOperator(value, output);
            }
            else if (value instanceof Func) {
                return this.writeFunc(value, output);
            }
            else if (value instanceof Extant) {
                return this.writeExtant(output);
            }
            else if (value instanceof Absent) {
                return this.writeAbsent(output);
            }
            return Writer.error(new WriterException("No Recon serialization for " + value));
        };
        ReconStructureWriter.prototype.sizeOfSelector = function (selector) {
            if (selector instanceof IdentitySelector) {
                return this.sizeOfIdentitySelector();
            }
            else if (selector instanceof LiteralSelector) {
                return this.sizeOfLiteralSelector(selector.item(), selector.then());
            }
            else if (selector instanceof GetSelector) {
                return this.sizeOfGetSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof GetAttrSelector) {
                return this.sizeOfGetAttrSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof GetItemSelector) {
                return this.sizeOfGetItemSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof KeysSelector) {
                return this.sizeOfKeysSelector(selector.then());
            }
            else if (selector instanceof ValuesSelector) {
                return this.sizeOfValuesSelector(selector.then());
            }
            else if (selector instanceof ChildrenSelector) {
                return this.sizeOfChildrenSelector(selector.then());
            }
            else if (selector instanceof DescendantsSelector) {
                return this.sizeOfDescendantsSelector(selector.then());
            }
            else if (selector instanceof FilterSelector) {
                return this.sizeOfFilterSelector(selector.predicate(), selector.then());
            }
            throw new WriterException("No Recon serialization for " + selector);
        };
        ReconStructureWriter.prototype.writeSelector = function (selector, output) {
            if (selector instanceof IdentitySelector) {
                return this.writeIdentitySelector(output);
            }
            else if (selector instanceof LiteralSelector) {
                return this.writeLiteralSelector(selector.item(), selector.then(), output);
            }
            else if (selector instanceof GetSelector) {
                return this.writeGetSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof GetAttrSelector) {
                return this.writeGetAttrSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof GetItemSelector) {
                return this.writeGetItemSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof KeysSelector) {
                return this.writeKeysSelector(selector.then(), output);
            }
            else if (selector instanceof ValuesSelector) {
                return this.writeValuesSelector(selector.then(), output);
            }
            else if (selector instanceof ChildrenSelector) {
                return this.writeChildrenSelector(selector.then(), output);
            }
            else if (selector instanceof DescendantsSelector) {
                return this.writeDescendantsSelector(selector.then(), output);
            }
            else if (selector instanceof FilterSelector) {
                return this.writeFilterSelector(selector.predicate(), selector.then(), output);
            }
            return Writer.error(new WriterException("No Recon serialization for " + selector));
        };
        ReconStructureWriter.prototype.sizeOfOperator = function (operator) {
            if (operator instanceof BinaryOperator) {
                return this.sizeOfInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence());
            }
            else if (operator instanceof UnaryOperator) {
                return this.sizeOfPrefixOperator(operator.operator(), operator.operand(), operator.precedence());
            }
            else if (operator instanceof InvokeOperator) {
                return this.sizeOfInvokeOperator(operator.func(), operator.args());
            }
            else if (operator instanceof ConditionalOperator) {
                return this.sizeOfConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence());
            }
            throw new WriterException("No Recon serialization for " + operator);
        };
        ReconStructureWriter.prototype.writeOperator = function (operator, output) {
            if (operator instanceof BinaryOperator) {
                return this.writeInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence(), output);
            }
            else if (operator instanceof UnaryOperator) {
                return this.writePrefixOperator(operator.operator(), operator.operand(), operator.precedence(), output);
            }
            else if (operator instanceof InvokeOperator) {
                return this.writeInvokeOperator(operator.func(), operator.args(), output);
            }
            else if (operator instanceof ConditionalOperator) {
                return this.writeConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence(), output);
            }
            return Writer.error(new WriterException("No Recon serialization for " + operator));
        };
        ReconStructureWriter.prototype.sizeOfFunc = function (func) {
            if (func instanceof LambdaFunc) {
                return this.sizeOfLambdaFunc(func.bindings(), func.template());
            }
            else if (func instanceof BridgeFunc) {
                return 0;
            }
            throw new WriterException("No Recon serialization for " + func);
        };
        ReconStructureWriter.prototype.writeFunc = function (func, output) {
            if (func instanceof LambdaFunc) {
                return this.writeLambdaFunc(func.bindings(), func.template(), output);
            }
            else if (func instanceof BridgeFunc) {
                return Writer.done();
            }
            return Writer.error(new WriterException("No Recon serialization for " + func));
        };
        ReconStructureWriter.prototype.sizeOfBlockItem = function (item) {
            if (item instanceof Field) {
                return this.sizeOfItem(item);
            }
            else if (item instanceof Value) {
                return this.sizeOfBlockValue(item);
            }
            throw new WriterException("No Recon serialization for " + item);
        };
        ReconStructureWriter.prototype.writeBlockItem = function (item, output) {
            if (item instanceof Field) {
                return this.writeItem(item, output);
            }
            else if (item instanceof Value) {
                return this.writeBlockValue(item, output);
            }
            return Writer.error(new WriterException("No Recon serialization for " + item));
        };
        ReconStructureWriter.prototype.sizeOfBlockValue = function (value) {
            if (value instanceof Record) {
                return this.sizeOfBlock(value);
            }
            return this.sizeOfValue(value);
        };
        ReconStructureWriter.prototype.writeBlockValue = function (value, output) {
            if (value instanceof Record) {
                return this.writeBlock(value, output);
            }
            return this.writeValue(value, output);
        };
        ReconStructureWriter.prototype.sizeOfThen = function (then) {
            if (then instanceof Selector) {
                if (then instanceof IdentitySelector) {
                    return this.sizeOfThenIdentitySelector();
                }
                else if (then instanceof LiteralSelector) {
                    return this.sizeOfThenLiteralSelector(then.item(), then.then());
                }
                else if (then instanceof GetSelector) {
                    return this.sizeOfThenGetSelector(then.accessor(), then.then());
                }
                else if (then instanceof GetAttrSelector) {
                    return this.sizeOfThenGetAttrSelector(then.accessor(), then.then());
                }
                else if (then instanceof GetItemSelector) {
                    return this.sizeOfThenGetItemSelector(then.accessor(), then.then());
                }
                else if (then instanceof KeysSelector) {
                    return this.sizeOfThenKeysSelector(then.then());
                }
                else if (then instanceof ValuesSelector) {
                    return this.sizeOfThenValuesSelector(then.then());
                }
                else if (then instanceof ChildrenSelector) {
                    return this.sizeOfThenChildrenSelector(then.then());
                }
                else if (then instanceof DescendantsSelector) {
                    return this.sizeOfThenDescendantsSelector(then.then());
                }
                else if (then instanceof FilterSelector) {
                    return this.sizeOfThenFilterSelector(then.predicate(), then.then());
                }
            }
            throw new WriterException("No Recon serialization for " + then);
        };
        ReconStructureWriter.prototype.writeThen = function (then, output) {
            if (then instanceof Selector) {
                if (then instanceof IdentitySelector) {
                    return this.writeThenIdentitySelector(output);
                }
                else if (then instanceof LiteralSelector) {
                    return this.writeThenLiteralSelector(then.item(), then.then(), output);
                }
                else if (then instanceof GetSelector) {
                    return this.writeThenGetSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof GetAttrSelector) {
                    return this.writeThenGetAttrSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof GetItemSelector) {
                    return this.writeThenGetItemSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof KeysSelector) {
                    return this.writeThenKeysSelector(then.then(), output);
                }
                else if (then instanceof ValuesSelector) {
                    return this.writeThenValuesSelector(then.then(), output);
                }
                else if (then instanceof ChildrenSelector) {
                    return this.writeThenChildrenSelector(then.then(), output);
                }
                else if (then instanceof DescendantsSelector) {
                    return this.writeThenDescendantsSelector(then.then(), output);
                }
                else if (then instanceof FilterSelector) {
                    return this.writeThenFilterSelector(then.predicate(), then.then(), output);
                }
            }
            return Writer.error(new WriterException("No Recon serialization for " + then));
        };
        return ReconStructureWriter;
    }(ReconWriter));

    var Recon = (function () {
        function Recon() {
        }
        Recon.isSpace = function (c) {
            return c === 0x20 || c === 0x9;
        };
        Recon.isNewline = function (c) {
            return c === 0xa || c === 0xd;
        };
        Recon.isWhitespace = function (c) {
            return Recon.isSpace(c) || Recon.isNewline(c);
        };
        Recon.isIdentStartChar = function (c) {
            return c >= 65 && c <= 90
                || c === 95
                || c >= 97 && c <= 122
                || c >= 0xc0 && c <= 0xd6
                || c >= 0xd8 && c <= 0xf6
                || c >= 0xf8 && c <= 0x2ff
                || c >= 0x370 && c <= 0x37d
                || c >= 0x37f && c <= 0x1fff
                || c >= 0x200c && c <= 0x200d
                || c >= 0x2070 && c <= 0x218f
                || c >= 0x2c00 && c <= 0x2fef
                || c >= 0x3001 && c <= 0xd7ff
                || c >= 0xf900 && c <= 0xfdcf
                || c >= 0xfdf0 && c <= 0xfffd
                || c >= 0x10000 && c <= 0xeffff;
        };
        Recon.isIdentChar = function (c) {
            return c === 45
                || c >= 48 && c <= 57
                || c >= 65 && c <= 90
                || c === 95
                || c >= 97 && c <= 122
                || c === 0xb7
                || c >= 0xc0 && c <= 0xd6
                || c >= 0xd8 && c <= 0xf6
                || c >= 0xf8 && c <= 0x37d
                || c >= 0x37f && c <= 0x1fff
                || c >= 0x200c && c <= 0x200d
                || c >= 0x203f && c <= 0x2040
                || c >= 0x2070 && c <= 0x218f
                || c >= 0x2c00 && c <= 0x2fef
                || c >= 0x3001 && c <= 0xd7ff
                || c >= 0xf900 && c <= 0xfdcf
                || c >= 0xfdf0 && c <= 0xfffd
                || c >= 0x10000 && c <= 0xeffff;
        };
        Recon.structureParser = function () {
            if (!Recon._structureParser) {
                Recon._structureParser = new ReconStructureParser();
            }
            return Recon._structureParser;
        };
        Recon.structureWriter = function () {
            if (!Recon._structureWriter) {
                Recon._structureWriter = new ReconStructureWriter();
            }
            return Recon._structureWriter;
        };
        Recon.parse = function (recon) {
            return Recon.structureParser().parseBlockString(recon);
        };
        Recon.parser = function () {
            return Recon.structureParser().blockParser();
        };
        Recon.sizeOf = function (item) {
            return Recon.structureWriter().sizeOfItem(item);
        };
        Recon.sizeOfBlock = function (item) {
            return Recon.structureWriter().sizeOfBlockItem(item);
        };
        Recon.write = function (item, output) {
            return Recon.structureWriter().writeItem(item, output);
        };
        Recon.writeBlock = function (item, output) {
            return Recon.structureWriter().writeBlockItem(item, output);
        };
        Recon.toString = function (item) {
            var output = Unicode.stringOutput();
            Recon.write(item, output);
            return output.bind();
        };
        Recon.toBlockString = function (item) {
            var output = Unicode.stringOutput();
            Recon.writeBlock(item, output);
            return output.bind();
        };
        Recon.toData = function (item) {
            var output = Utf8.encodedOutput(Data.output());
            Recon.write(item, output);
            return output.bind();
        };
        Recon.toBlockData = function (item) {
            var output = Utf8.encodedOutput(Data.output());
            Recon.writeBlock(item, output);
            return output.bind();
        };
        return Recon;
    }());
    Item.prototype.toRecon = function () {
        return Recon.toString(this);
    };
    Item.prototype.toReconBlock = function () {
        return Recon.toBlockString(this);
    };
    Value.parseRecon = function (recon) {
        return Recon.parse(recon);
    };

    var Shape = {
        fromAny: function (shape) {
            if (shape instanceof Shape.R2) {
                return shape;
            }
            else if (typeof shape === "object" && shape) {
                if (Array.isArray(shape)) {
                    if (shape.length === 2) {
                        return new Shape.R2.Point(shape[0], shape[1]);
                    }
                    else {
                        throw new TypeError("" + shape);
                    }
                }
                var point = shape;
                if (typeof point.x === "number" && typeof point.y === "number") {
                    return new Shape.R2.Point(point.x, point.y);
                }
                var segment = shape;
                if (typeof segment.x0 === "number" && typeof segment.y0 === "number"
                    && typeof segment.x1 === "number" && typeof segment.y1 === "number") {
                    return new Shape.R2.Segment(segment.x0, segment.y0, segment.x1, segment.y1);
                }
                var box = shape;
                if (typeof box.xMin === "number" && typeof box.yMin === "number"
                    && typeof box.xMax === "number" && typeof box.yMax === "number") {
                    return new Shape.R2.Box(box.xMin, box.yMin, box.xMax, box.yMax);
                }
                var circle = shape;
                if (typeof circle.cx === "number" && typeof circle.cy === "number"
                    && typeof circle.r === "number") {
                    return new Shape.R2.Circle(circle.cx, circle.cy, circle.r);
                }
            }
            throw new TypeError("" + shape);
        },
        is: function (object) {
            if (typeof object === "object" && object) {
                var shape = object;
                return typeof shape.contains === "function"
                    && typeof shape.intersects === "function";
            }
            return false;
        },
        R2: void 0,
    };

    var R2Shape = (function () {
        function R2Shape() {
        }
        R2Shape.prototype.union = function (that) {
            that = R2Shape.fromAny(that);
            return new R2Shape.Box(Math.min(this.xMin, that.xMin), Math.min(this.yMin, that.yMin), Math.max(this.xMax, that.xMax), Math.max(this.yMax, that.yMax));
        };
        R2Shape.fromAny = function (shape) {
            return Shape.fromAny(shape);
        };
        return R2Shape;
    }());
    Shape.R2 = R2Shape;

    var VectorR2 = (function () {
        function VectorR2(x, y) {
            this._x = x;
            this._y = y;
        }
        Object.defineProperty(VectorR2.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VectorR2.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        VectorR2.prototype.plus = function (that) {
            return new VectorR2(this._x + that.x, this._y + that.y);
        };
        VectorR2.prototype.opposite = function () {
            return new VectorR2(-this._x, -this._y);
        };
        VectorR2.prototype.minus = function (that) {
            return new VectorR2(this._x - that.x, this._y - that.y);
        };
        VectorR2.prototype.times = function (scalar) {
            return new VectorR2(this._x * scalar, this._y * scalar);
        };
        VectorR2.prototype.toAny = function () {
            return {
                x: this._x,
                y: this._y,
            };
        };
        VectorR2.prototype.canEqual = function (that) {
            return true;
        };
        VectorR2.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof VectorR2) {
                return that.canEqual(this) && this._x === that._x && this._y === that._y;
            }
            return false;
        };
        VectorR2.prototype.hashCode = function () {
            if (VectorR2._hashSeed === void 0) {
                VectorR2._hashSeed = Murmur3.seed(VectorR2);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(VectorR2._hashSeed, Murmur3.hash(this._x)), Murmur3.hash(this._y)));
        };
        VectorR2.prototype.debug = function (output) {
            output.write("VectorR2").write(46).write("of").write(40)
                .debug(this._x).write(", ").debug(this._y).write(41);
        };
        VectorR2.prototype.toString = function () {
            return Format.debug(this);
        };
        VectorR2.zero = function () {
            if (VectorR2._zero === void 0) {
                VectorR2._zero = new VectorR2(0, 0);
            }
            return VectorR2._zero;
        };
        VectorR2.of = function (x, y) {
            return new VectorR2(x, y);
        };
        VectorR2.fromAny = function (vector) {
            if (vector instanceof VectorR2) {
                return vector;
            }
            else if (typeof vector === "object" && vector) {
                return new VectorR2(vector.x, vector.y);
            }
            throw new TypeError("" + vector);
        };
        return VectorR2;
    }());

    var PointR2 = (function (_super) {
        __extends(PointR2, _super);
        function PointR2(x, y) {
            var _this = _super.call(this) || this;
            _this._x = x;
            _this._y = y;
            return _this;
        }
        Object.defineProperty(PointR2.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointR2.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointR2.prototype, "xMin", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointR2.prototype, "yMin", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointR2.prototype, "xMax", {
            get: function () {
                return this._x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointR2.prototype, "yMax", {
            get: function () {
                return this._y;
            },
            enumerable: true,
            configurable: true
        });
        PointR2.prototype.plus = function (vector) {
            return new PointR2(this._x + vector.x, this._y + vector.y);
        };
        PointR2.prototype.minus = function (that) {
            var x = this._x - that._x;
            var y = this._y - that._y;
            if (that instanceof VectorR2) {
                return new PointR2(x, y);
            }
            else {
                return new VectorR2(x, y);
            }
        };
        PointR2.prototype.contains = function (that, y) {
            if (typeof that === "number") {
                return this._x === that && this._y === y;
            }
            else {
                that = Shape.fromAny(that);
                if (that instanceof PointR2) {
                    return this._x === that._x && this._y === that._y;
                }
                else if (that instanceof R2Shape) {
                    return this._x <= that.xMin && that.xMax <= this._x
                        && this._y <= that.yMin && that.yMax <= this._y;
                }
                return false;
            }
        };
        PointR2.prototype.intersects = function (that) {
            that = Shape.fromAny(that);
            return that.intersects(this);
        };
        PointR2.prototype.transform = function (f) {
            return new PointR2(f.transformX(this.x, this.y), f.transformY(this.x, this.y));
        };
        PointR2.prototype.toAny = function () {
            return {
                x: this._x,
                y: this._y,
            };
        };
        PointR2.prototype.canEqual = function (that) {
            return true;
        };
        PointR2.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof PointR2) {
                return that.canEqual(this) && this._x === that._x && this._y === that._y;
            }
            return false;
        };
        PointR2.prototype.hashCode = function () {
            if (PointR2._hashSeed === void 0) {
                PointR2._hashSeed = Murmur3.seed(PointR2);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(PointR2._hashSeed, Murmur3.hash(this._x)), Murmur3.hash(this._y)));
        };
        PointR2.prototype.debug = function (output) {
            output.write("PointR2").write(46).write("of").write(40)
                .debug(this._x).write(", ").debug(this._y).write(41);
        };
        PointR2.prototype.toString = function () {
            return Format.debug(this);
        };
        PointR2.origin = function () {
            if (PointR2._origin === void 0) {
                PointR2._origin = new PointR2(0, 0);
            }
            return PointR2._origin;
        };
        PointR2.of = function (x, y) {
            return new PointR2(x, y);
        };
        PointR2.fromAny = function (point) {
            if (point instanceof PointR2) {
                return point;
            }
            else if (typeof point === "object" && point) {
                var x = void 0;
                var y = void 0;
                if (Array.isArray(point)) {
                    x = point[0];
                    y = point[1];
                }
                else {
                    x = point.x;
                    y = point.y;
                }
                return new PointR2(x, y);
            }
            throw new TypeError("" + point);
        };
        return PointR2;
    }(R2Shape));
    R2Shape.Point = PointR2;

    var SegmentR2 = (function (_super) {
        __extends(SegmentR2, _super);
        function SegmentR2(x0, y0, x1, y1) {
            var _this = _super.call(this) || this;
            _this._x0 = x0;
            _this._y0 = y0;
            _this._x1 = x1;
            _this._y1 = y1;
            return _this;
        }
        Object.defineProperty(SegmentR2.prototype, "x0", {
            get: function () {
                return this._x0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "y0", {
            get: function () {
                return this._y0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "x1", {
            get: function () {
                return this._x1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "y1", {
            get: function () {
                return this._y1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "xMin", {
            get: function () {
                return Math.min(this._x0, this._x1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "yMin", {
            get: function () {
                return Math.min(this._y0, this._y1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "xMax", {
            get: function () {
                return Math.max(this._x0, this._x1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SegmentR2.prototype, "yMax", {
            get: function () {
                return Math.max(this._y0, this._y1);
            },
            enumerable: true,
            configurable: true
        });
        SegmentR2.prototype.contains = function (that, y) {
            if (typeof that === "number") {
                return SegmentR2.contains(this._x0, this._y0, this._x1, this._y1, that, y);
            }
            else {
                that = Shape.fromAny(that);
                if (that instanceof R2Shape) {
                    if (that instanceof PointR2) {
                        return this.containsPoint(that);
                    }
                    else if (that instanceof SegmentR2) {
                        return this.containsSegment(that);
                    }
                }
                return false;
            }
        };
        SegmentR2.prototype.containsPoint = function (that) {
            return SegmentR2.contains(this._x0, this._y0, this._x1, this._y1, that._x, that._y);
        };
        SegmentR2.prototype.containsSegment = function (that) {
            return SegmentR2.contains(this._x0, this._y0, this._x1, this._y1, that._x0, that._y0)
                && SegmentR2.contains(this._x0, this._y0, this._x1, this._y1, that._x1, that._y1);
        };
        SegmentR2.prototype.intersects = function (that) {
            that = Shape.fromAny(that);
            if (that instanceof R2Shape) {
                if (that instanceof PointR2) {
                    return this.intersectsPoint(that);
                }
                else if (that instanceof SegmentR2) {
                    return this.intersectsSegment(that);
                }
                else {
                    return that.intersects(this);
                }
            }
            return false;
        };
        SegmentR2.prototype.intersectsPoint = function (that) {
            return SegmentR2.contains(this._x0, this._y0, this._x1, this._y1, that._x, that._y);
        };
        SegmentR2.prototype.intersectsSegment = function (that) {
            return SegmentR2.intersects(this._x0, this._y0, this._x1 - this._x0, this._y1 - this._y0, that._x0, that._y0, that._x1 - that._x0, that._y1 - that._y0);
        };
        SegmentR2.prototype.transform = function (f) {
            return new SegmentR2(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0), f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1));
        };
        SegmentR2.contains = function (ax, ay, bx, by, cx, cy) {
            return (ax <= cx && cx <= bx || bx <= cx && cx <= ax)
                && (ay <= cy && cy <= by || by <= cy && cy <= ay)
                && (bx - ax) * (cy - ay) === (cx - ax) * (by - ay);
        };
        SegmentR2.intersects = function (px, py, rx, ry, qx, qy, sx, sy) {
            var pqx = qx - px;
            var pqy = qy - py;
            var pqr = pqx * ry - pqy * rx;
            var rs = rx * sy - ry * sx;
            if (pqr === 0 && rs === 0) {
                var rr = rx * rx + ry * ry;
                var sr = sx * rx + sy * ry;
                var t0 = (pqx * rx + pqy * ry) / rr;
                var t1 = t0 + sr / rr;
                return sr >= 0 ? 0 < t1 && t0 < 1 : 0 < t0 && t1 < 1;
            }
            else if (rs === 0) {
                return false;
            }
            else {
                var pqs = pqx * sy - pqy * sx;
                var t = pqs / rs;
                var u = pqr / rs;
                return 0 <= t && t <= 1 && 0 <= u && u <= 1;
            }
        };
        SegmentR2.prototype.toAny = function () {
            return {
                x0: this._x0,
                y0: this._y0,
                x1: this._x1,
                y1: this._y1,
            };
        };
        SegmentR2.prototype.canEqual = function (that) {
            return true;
        };
        SegmentR2.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof SegmentR2) {
                return that.canEqual(this) && this._x0 === that._x0 && this._y0 === that._y0
                    && this._x1 === that._x1 && this._y1 === that._y1;
            }
            return false;
        };
        SegmentR2.prototype.hashCode = function () {
            if (SegmentR2._hashSeed === void 0) {
                SegmentR2._hashSeed = Murmur3.seed(SegmentR2);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(SegmentR2._hashSeed, Murmur3.hash(this._x0)), Murmur3.hash(this._y0)), Murmur3.hash(this._x1)), Murmur3.hash(this._y1)));
        };
        SegmentR2.prototype.debug = function (output) {
            output.write("SegmentR2").write(46).write("of").write(40)
                .debug(this._x0).write(", ").debug(this._y0).write(", ")
                .debug(this._x1).write(", ").debug(this._y1).write(41);
        };
        SegmentR2.prototype.toString = function () {
            return Format.debug(this);
        };
        SegmentR2.of = function (x0, y0, x1, y1) {
            return new SegmentR2(x0, y0, x1, y1);
        };
        SegmentR2.fromAny = function (segment) {
            if (segment instanceof SegmentR2) {
                return segment;
            }
            else if (typeof segment === "object" && segment) {
                return new SegmentR2(segment.x0, segment.y0, segment.x1, segment.y1);
            }
            throw new TypeError("" + segment);
        };
        return SegmentR2;
    }(R2Shape));
    R2Shape.Segment = SegmentR2;

    var CircleR2 = (function (_super) {
        __extends(CircleR2, _super);
        function CircleR2(x, y, r) {
            var _this = _super.call(this) || this;
            _this._cx = x;
            _this._cy = y;
            _this._r = r;
            return _this;
        }
        Object.defineProperty(CircleR2.prototype, "cx", {
            get: function () {
                return this._cx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "cy", {
            get: function () {
                return this._cy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "r", {
            get: function () {
                return this._r;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "xMin", {
            get: function () {
                return this._cx - this._r;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "yMin", {
            get: function () {
                return this._cy - this._r;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "xMax", {
            get: function () {
                return this._cx + this._r;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CircleR2.prototype, "yMax", {
            get: function () {
                return this._cy + this._r;
            },
            enumerable: true,
            configurable: true
        });
        CircleR2.prototype.contains = function (that, y) {
            if (typeof that === "number") {
                var dx = that - this._cx;
                var dy = y - this._cy;
                return dx * dx + dy * dy <= this._r * this._r;
            }
            else {
                that = Shape.fromAny(that);
                if (that instanceof R2Shape) {
                    if (that instanceof PointR2) {
                        return this.containsPoint(that);
                    }
                    else if (that instanceof SegmentR2) {
                        return this.containsSegment(that);
                    }
                    else if (that instanceof BoxR2) {
                        return this.containsBox(that);
                    }
                    else if (that instanceof CircleR2) {
                        return this.containsCircle(that);
                    }
                }
                return false;
            }
        };
        CircleR2.prototype.containsPoint = function (that) {
            var dx = that._x - this._cx;
            var dy = that._y - this._cy;
            return dx * dx + dy * dy <= this._r * this._r;
        };
        CircleR2.prototype.containsSegment = function (that) {
            var dx0 = that._x0 - this._cx;
            var dy0 = that._y0 - this._cy;
            var dx1 = that._x1 - this._cx;
            var dy1 = that._y1 - this._cy;
            var r2 = this._r * this._r;
            return dx0 * dx0 + dy0 * dy0 <= r2
                && dx1 * dx1 + dy1 * dy1 <= r2;
        };
        CircleR2.prototype.containsBox = function (that) {
            var dxMin = that._xMin - this._cx;
            var dyMin = that._yMin - this._cy;
            var dxMax = that._xMax - this._cx;
            var dyMax = that._yMax - this._cy;
            var r2 = this._r * this._r;
            return dxMin * dxMin + dyMin * dyMin <= r2
                && dxMin * dxMin + dyMax * dyMax <= r2
                && dxMax * dxMax + dyMin * dyMin <= r2
                && dxMax * dxMax + dyMax * dyMax <= r2;
        };
        CircleR2.prototype.containsCircle = function (that) {
            var dx = that._cx - this._cx;
            var dy = that._cy - this._cy;
            return dx * dx + dy * dy + that._r * that._r <= this._r * this._r;
        };
        CircleR2.prototype.intersects = function (that) {
            that = Shape.fromAny(that);
            if (that instanceof R2Shape) {
                if (that instanceof PointR2) {
                    return this.intersectsPoint(that);
                }
                else if (that instanceof SegmentR2) {
                    return this.intersectsSegment(that);
                }
                else if (that instanceof BoxR2) {
                    return this.intersectsBox(that);
                }
                else if (that instanceof CircleR2) {
                    return this.intersectsCircle(that);
                }
                else {
                    return that.intersects(this);
                }
            }
            return false;
        };
        CircleR2.prototype.intersectsPoint = function (that) {
            var dx = that._x - this._cx;
            var dy = that._y - this._cy;
            return dx * dx + dy * dy <= this._r * this._r;
        };
        CircleR2.prototype.intersectsSegment = function (that) {
            var cx = this._cx;
            var cy = this._cy;
            var r = this._r;
            var x0 = that._x0;
            var y0 = that._y0;
            var x1 = that._x1;
            var y1 = that._y1;
            var dx = x1 - x0;
            var dy = y1 - y0;
            var l = Math.sqrt(dx * dx + dy * dy);
            var unitX = dx / l;
            var unitY = dy / l;
            var d = (cx - x0) * unitY - (cy - y0) * unitX;
            if (d < -r || r < d) {
                return false;
            }
            else {
                var dcx0 = x0 - cx;
                var dcy0 = y0 - cy;
                var dcx1 = x1 - cx;
                var dcy1 = y1 - cy;
                var r2 = r * r;
                if (dcx0 * dcx0 + dcy0 * dcy0 <= r2 || dcx1 * dcx1 + dcy1 * dcy1 <= r2) {
                    return true;
                }
                else {
                    var uc = unitX * cx + unitY * cy;
                    var u0 = unitX * x0 + unitY * y0;
                    var u1 = unitX * x1 + unitY * y1;
                    return u0 < uc && uc <= u1 || u1 < uc && uc <= u0;
                }
            }
        };
        CircleR2.prototype.intersectsBox = function (that) {
            var dx = (this._cx < that._xMin ? that._xMin : that._xMax < this._cx ? that._xMax : this._cx) - this._cx;
            var dy = (this._cy < that._yMin ? that._yMin : that._yMax < this._cy ? that._yMax : this._cy) - this._cy;
            return dx * dx + dy * dy <= this._r * this._r;
        };
        CircleR2.prototype.intersectsCircle = function (that) {
            var dx = that._cx - this._cx;
            var dy = that._cy - this._cy;
            var rr = this._r + that._r;
            return dx * dx + dy * dy <= rr * rr;
        };
        CircleR2.prototype.transform = function (f) {
            var cx = f.transformX(this.cx, this.cy);
            var cy = f.transformY(this.cx, this.cy);
            var rx = f.transformX(this.cx + this.r, this.cy);
            var ry = f.transformY(this.cx + this.r, this.cy);
            var dx = rx - cx;
            var dy = ry - cy;
            var r = Math.sqrt(dx * dx + dy * dy);
            return new CircleR2(cx, cy, r);
        };
        CircleR2.prototype.toAny = function () {
            return {
                cx: this._cx,
                cy: this._cy,
                r: this._r,
            };
        };
        CircleR2.prototype.canEqual = function (that) {
            return true;
        };
        CircleR2.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof CircleR2) {
                return that.canEqual(this) && this._cx === that._cx && this._cy === that._cy && this._r === that._r;
            }
            return false;
        };
        CircleR2.prototype.hashCode = function () {
            if (CircleR2._hashSeed === void 0) {
                CircleR2._hashSeed = Murmur3.seed(CircleR2);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(CircleR2._hashSeed, Murmur3.hash(this._cx)), Murmur3.hash(this._cy)), Murmur3.hash(this._r)));
        };
        CircleR2.prototype.debug = function (output) {
            output.write("CircleR2").write(46).write("of").write(40)
                .debug(this._cx).write(", ").debug(this._cy).write(", ").debug(this._r).write(41);
        };
        CircleR2.prototype.toString = function () {
            return Format.debug(this);
        };
        CircleR2.of = function (cx, cy, r) {
            return new CircleR2(cx, cy, r);
        };
        CircleR2.fromAny = function (circle) {
            if (circle instanceof CircleR2) {
                return circle;
            }
            else if (typeof circle === "object" && circle) {
                return new CircleR2(circle.cx, circle.cy, circle.r);
            }
            throw new TypeError("" + circle);
        };
        return CircleR2;
    }(R2Shape));
    R2Shape.Circle = CircleR2;

    var BoxR2 = (function (_super) {
        __extends(BoxR2, _super);
        function BoxR2(xMin, yMin, xMax, yMax) {
            var _this = _super.call(this) || this;
            _this._xMin = xMin <= xMax ? xMin : xMax;
            _this._yMin = yMin <= yMax ? yMin : yMax;
            _this._xMax = xMin <= xMax ? xMax : xMin;
            _this._yMax = yMin <= yMax ? yMax : yMin;
            return _this;
        }
        Object.defineProperty(BoxR2.prototype, "xMin", {
            get: function () {
                return this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "yMin", {
            get: function () {
                return this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "xMax", {
            get: function () {
                return this._xMax;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "yMax", {
            get: function () {
                return this._yMax;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "x", {
            get: function () {
                return this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "y", {
            get: function () {
                return this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "width", {
            get: function () {
                return this._xMax - this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "height", {
            get: function () {
                return this._yMax - this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "top", {
            get: function () {
                return this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "right", {
            get: function () {
                return this._xMax;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "bottom", {
            get: function () {
                return this._yMax;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoxR2.prototype, "left", {
            get: function () {
                return this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        BoxR2.prototype.contains = function (that, y) {
            if (typeof that === "number") {
                return this._xMin <= that && that <= this._xMax
                    && this._yMin <= y && y <= this._yMax;
            }
            else {
                that = Shape.fromAny(that);
                if (that instanceof R2Shape) {
                    if (that instanceof PointR2) {
                        return this.containsPoint(that);
                    }
                    else if (that instanceof SegmentR2) {
                        return this.containsSegment(that);
                    }
                    else if (that instanceof BoxR2) {
                        return this.containsBox(that);
                    }
                    else if (that instanceof CircleR2) {
                        return this.containsCircle(that);
                    }
                    else {
                        return this._xMin <= that.xMin && that.xMax <= this._xMax
                            && this._yMin <= that.yMin && that.yMax <= this._yMax;
                    }
                }
                return false;
            }
        };
        BoxR2.prototype.containsPoint = function (that) {
            return this._xMin <= that._x && that._x <= this._xMax
                && this._yMin <= that._y && that._y <= this._yMax;
        };
        BoxR2.prototype.containsSegment = function (that) {
            return this._xMin <= that._x0 && that._x0 <= this._xMax
                && this._yMin <= that._y0 && that._y0 <= this._yMax
                && this._xMin <= that._x1 && that._x1 <= this._xMax
                && this._yMin <= that._y1 && that._y1 <= this._yMax;
        };
        BoxR2.prototype.containsBox = function (that) {
            return this._xMin <= that._xMin && that._xMax <= this._xMax
                && this._yMin <= that._yMin && that._yMax <= this._yMax;
        };
        BoxR2.prototype.containsCircle = function (that) {
            return this._xMin <= that._cx - that._r && that._cx + that._r <= this._xMax
                && this._yMin <= that._cy - that._r && that._cy + that._r <= this._yMax;
        };
        BoxR2.prototype.intersects = function (that) {
            that = Shape.fromAny(that);
            if (that instanceof R2Shape) {
                if (that instanceof PointR2) {
                    return this.intersectsPoint(that);
                }
                else if (that instanceof SegmentR2) {
                    return this.intersectsSegment(that);
                }
                else if (that instanceof BoxR2) {
                    return this.intersectsBox(that);
                }
                else if (that instanceof CircleR2) {
                    return this.intersectsCircle(that);
                }
                else {
                    return that.intersects(this);
                }
            }
            return false;
        };
        BoxR2.prototype.intersectsPoint = function (that) {
            return this._xMin <= that._x && that._x <= this._xMax
                && this._yMin <= that._y && that._y <= this._yMax;
        };
        BoxR2.prototype.intersectsSegment = function (that) {
            var xMin = this._xMin;
            var yMin = this._yMin;
            var xMax = this._xMax;
            var yMax = this._yMax;
            var x0 = that._x0;
            var y0 = that._y0;
            var x1 = that._x1;
            var y1 = that._y1;
            if (x0 < xMin && x1 < xMin || x0 > xMax && x1 > xMax ||
                y0 < yMin && y1 < yMin || y0 > yMax && y1 > yMax) {
                return false;
            }
            else if (x0 > xMin && x0 < xMax && y0 > yMin && y0 < yMax) {
                return true;
            }
            else if ((BoxR2.intersectsSegment(x0 - xMin, x1 - xMin, x0, y0, x1, y1) && BoxR2._hitY > yMin && BoxR2._hitY < yMax)
                || (BoxR2.intersectsSegment(y0 - yMin, y1 - yMin, x0, y0, x1, y1) && BoxR2._hitX > xMin && BoxR2._hitX < xMax)
                || (BoxR2.intersectsSegment(x0 - xMax, x1 - xMax, x0, y0, x1, y1) && BoxR2._hitY > yMin && BoxR2._hitY < yMax)
                || (BoxR2.intersectsSegment(y0 - yMax, y1 - yMax, x0, y0, x1, y1) && BoxR2._hitX > xMin && BoxR2._hitX < xMax)) {
                return true;
            }
            else {
                return false;
            }
        };
        BoxR2.intersectsSegment = function (d0, d1, x0, y0, x1, y1) {
            if (d0 !== d1 || d0 * d1 < 0) {
                var scale = -d0 / (d1 - d0);
                BoxR2._hitX = x0 + (x1 - x0) * scale;
                BoxR2._hitY = y0 + (y1 - y0) * scale;
                return true;
            }
            return false;
        };
        BoxR2.prototype.intersectsBox = function (that) {
            return this._xMin <= that._xMax && that._xMin <= this._xMax
                && this._yMin <= that._yMax && that._yMin <= this._yMax;
        };
        BoxR2.prototype.intersectsCircle = function (that) {
            var dx = (that._cx < this._xMin ? this._xMin : this._xMax < that._cx ? this._xMax : that._cx) - that._cx;
            var dy = (that._cy < this._yMin ? this._yMin : this._yMax < that._cy ? this._yMax : that._cy) - that._cy;
            return dx * dx + dy * dy <= that._r * that._r;
        };
        BoxR2.prototype.union = function (that) {
            return _super.prototype.union.call(this, that);
        };
        BoxR2.prototype.transform = function (f) {
            return new BoxR2(f.transformX(this.xMin, this.yMin), f.transformY(this.xMin, this.yMin), f.transformX(this.xMax, this.yMax), f.transformY(this.xMax, this.yMax));
        };
        BoxR2.prototype.toAny = function () {
            return {
                xMin: this._xMin,
                yMin: this._yMin,
                xMax: this._xMax,
                yMax: this._yMax,
            };
        };
        BoxR2.prototype.canEqual = function (that) {
            return true;
        };
        BoxR2.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof BoxR2) {
                return that.canEqual(this) && this._xMin === that._xMin && this._yMin === that._yMin
                    && this._xMax === that._xMax && this._yMax === that._yMax;
            }
            return false;
        };
        BoxR2.prototype.hashCode = function () {
            if (BoxR2._hashSeed === void 0) {
                BoxR2._hashSeed = Murmur3.seed(BoxR2);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(BoxR2._hashSeed, Murmur3.hash(this.xMin)), Murmur3.hash(this.yMin)), Murmur3.hash(this.xMax)), Murmur3.hash(this.yMax)));
        };
        BoxR2.prototype.debug = function (output) {
            output.write("BoxR2").write(46).write("of").write(40)
                .debug(this.xMin).write(", ").debug(this.yMin).write(", ")
                .debug(this.xMax).write(", ").debug(this.yMax).write(41);
        };
        BoxR2.prototype.toString = function () {
            return Format.debug(this);
        };
        BoxR2.empty = function () {
            if (!BoxR2._empty) {
                BoxR2._empty = new BoxR2(0, 0, 0, 0);
            }
            return BoxR2._empty;
        };
        BoxR2.of = function (xMin, yMin, xMax, yMax) {
            return new BoxR2(xMin, yMin, xMax, yMax);
        };
        BoxR2.fromAny = function (box) {
            if (box instanceof BoxR2) {
                return box;
            }
            else if (typeof box === "object" && box) {
                return new BoxR2(box.xMin, box.yMin, box.xMax, box.yMax);
            }
            throw new TypeError("" + box);
        };
        BoxR2._hitX = 0;
        BoxR2._hitY = 0;
        return BoxR2;
    }(R2Shape));
    R2Shape.Box = BoxR2;

    var TimeZone = (function () {
        function TimeZone(name, offset) {
            this._name = name;
            this._offset = offset;
        }
        TimeZone.prototype.isUTC = function () {
            return this._offset === 0;
        };
        TimeZone.prototype.isLocal = function () {
            return this._offset === -new Date().getTimezoneOffset();
        };
        TimeZone.prototype.name = function () {
            return this._name;
        };
        TimeZone.prototype.offset = function () {
            return this._offset;
        };
        TimeZone.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof TimeZone) {
                return this._offset === that._offset;
            }
            return false;
        };
        TimeZone.prototype.hashCode = function () {
            if (TimeZone._hashSeed === void 0) {
                TimeZone._hashSeed = Murmur3.seed(TimeZone);
            }
            return Murmur3.mash(Murmur3.mix(TimeZone._hashSeed, Murmur3.hash(this._offset)));
        };
        TimeZone.prototype.debug = function (output) {
            output = output.write("TimeZone").write(46);
            if (this._name === "UTC" && this._offset === 0) {
                output = output.write("utc").write(40).write(41);
            }
            else if (this._name === void 0) {
                output = output.write("forOffset").write(40)
                    .debug(this._offset).write(41);
            }
            else {
                output = output.write("from").write(40)
                    .debug(this._name).write(", ").debug(this._offset).write(41);
            }
        };
        TimeZone.prototype.toString = function () {
            return Format.debug(this);
        };
        TimeZone.utc = function () {
            if (!TimeZone._utc) {
                TimeZone._utc = new TimeZone("UTC", 0);
            }
            return TimeZone._utc;
        };
        TimeZone.local = function () {
            if (!TimeZone._local) {
                TimeZone._local = TimeZone.forOffset(-new Date().getTimezoneOffset());
            }
            return TimeZone._local;
        };
        TimeZone.forName = function (name) {
            switch (name) {
                case "UTC": return TimeZone.utc();
                default: return void 0;
            }
        };
        TimeZone.forOffset = function (offset) {
            switch (offset) {
                case 0: return TimeZone.utc();
                default: return new TimeZone(void 0, offset);
            }
        };
        TimeZone.from = function (name, offset) {
            if (name === "UTC" && offset === 0) {
                return TimeZone.utc();
            }
            else {
                return new TimeZone(name, offset);
            }
        };
        TimeZone.fromAny = function (value) {
            if (value instanceof TimeZone) {
                return value;
            }
            else if (typeof value === "string") {
                var zone = TimeZone.forName(value);
                if (zone !== void 0) {
                    return zone;
                }
            }
            else if (typeof value === "number") {
                return TimeZone.forOffset(value);
            }
            throw new TypeError("" + value);
        };
        TimeZone.fromValue = function (value) {
            var name = value.stringValue(void 0);
            if (name !== void 0) {
                return TimeZone.forName(name);
            }
            var offset = value.numberValue(void 0);
            if (offset !== void 0) {
                return TimeZone.forOffset(offset);
            }
            return void 0;
        };
        TimeZone.form = function (unit) {
            if (unit !== void 0) {
                unit = TimeZone.fromAny(unit);
            }
            if (unit !== TimeZone.utc()) {
                return new TimeZone.Form(unit);
            }
            else {
                if (!TimeZone._form) {
                    TimeZone._form = new TimeZone.Form(TimeZone.utc());
                }
                return TimeZone._form;
            }
        };
        return TimeZone;
    }());

    var TimeZoneForm = (function (_super) {
        __extends(TimeZoneForm, _super);
        function TimeZoneForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        TimeZoneForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new TimeZoneForm(unit);
            }
        };
        TimeZoneForm.prototype.mold = function (zone) {
            zone = TimeZone.fromAny(zone);
            var name = zone.name();
            if (name !== void 0) {
                return Text.from(name);
            }
            else {
                return Num.from(zone._offset);
            }
        };
        TimeZoneForm.prototype.cast = function (item) {
            var value = item.toValue();
            return TimeZone.fromValue(value);
        };
        return TimeZoneForm;
    }(Form));
    TimeZone.Form = TimeZoneForm;

    var DateTimeLocale = (function () {
        function DateTimeLocale(periods, weekdays, shortWeekdays, months, shortMonths) {
            if (periods === void 0) { periods = DateTimeLocale.Periods; }
            if (weekdays === void 0) { weekdays = DateTimeLocale.Weekdays; }
            if (shortWeekdays === void 0) { shortWeekdays = DateTimeLocale.ShortWeekdays; }
            if (months === void 0) { months = DateTimeLocale.Months; }
            if (shortMonths === void 0) { shortMonths = DateTimeLocale.ShortMonths; }
            this.periods = periods;
            this.weekdays = weekdays;
            this.shortWeekdays = shortWeekdays;
            this.months = months;
            this.shortMonths = shortMonths;
        }
        DateTimeLocale.standard = function () {
            if (!DateTimeLocale._standard) {
                DateTimeLocale._standard = new DateTimeLocale();
            }
            return DateTimeLocale._standard;
        };
        DateTimeLocale.Periods = [
            "AM",
            "PM",
        ];
        DateTimeLocale.Weekdays = [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
        ];
        DateTimeLocale.ShortWeekdays = [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
        ];
        DateTimeLocale.Months = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ];
        DateTimeLocale.ShortMonths = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
        ];
        return DateTimeLocale;
    }());

    var DateTime = (function () {
        function DateTime(time, zone) {
            if (zone === void 0) { zone = TimeZone.utc(); }
            this._time = time;
            this._zone = zone;
        }
        DateTime.prototype.time = function (time) {
            if (time === void 0) {
                return this._time;
            }
            else {
                return new DateTime(time, this._zone);
            }
        };
        DateTime.prototype.zone = function (zone) {
            if (zone === void 0) {
                return this._zone;
            }
            else {
                return new DateTime(this._time, zone);
            }
        };
        DateTime.prototype.year = function (year, month, day, hour, minute, second, millisecond) {
            var date = this.toUTCLocalDate();
            if (year === void 0) {
                return date.getUTCFullYear();
            }
            else {
                date.setUTCFullYear(year);
                if (month !== void 0) {
                    date.setUTCMonth(month);
                }
                if (day !== void 0) {
                    date.setUTCDate(day);
                }
                if (hour !== void 0) {
                    date.setUTCHours(hour);
                }
                if (minute !== void 0) {
                    date.setUTCMinutes(minute);
                }
                if (second !== void 0) {
                    date.setUTCSeconds(second);
                }
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.month = function (month, day, hour, minute, second, millisecond) {
            var date = this.toUTCLocalDate();
            if (month === void 0) {
                return date.getUTCMonth();
            }
            else {
                date.setUTCMonth(month);
                if (day !== void 0) {
                    date.setUTCDate(day);
                }
                if (hour !== void 0) {
                    date.setUTCHours(hour);
                }
                if (minute !== void 0) {
                    date.setUTCMinutes(minute);
                }
                if (second !== void 0) {
                    date.setUTCSeconds(second);
                }
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.day = function (day, hour, minute, second, millisecond) {
            var date = this.toUTCLocalDate();
            if (day === void 0) {
                return date.getUTCDate();
            }
            else {
                date.setUTCDate(day);
                if (hour !== void 0) {
                    date.setUTCHours(hour);
                }
                if (minute !== void 0) {
                    date.setUTCMinutes(minute);
                }
                if (second !== void 0) {
                    date.setUTCSeconds(second);
                }
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.hour = function (hour, minute, second, millisecond) {
            var date = this.toUTCLocalDate();
            if (hour === void 0) {
                return date.getUTCHours();
            }
            else {
                date.setUTCHours(hour);
                if (minute !== void 0) {
                    date.setUTCMinutes(minute);
                }
                if (second !== void 0) {
                    date.setUTCSeconds(second);
                }
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.minute = function (minute, second, millisecond) {
            var date = this.toUTCLocalDate();
            if (minute === void 0) {
                return date.getUTCMinutes();
            }
            else {
                date.setUTCMinutes(minute);
                if (second !== void 0) {
                    date.setUTCSeconds(second);
                }
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.second = function (second, millisecond) {
            var date = this.toUTCLocalDate();
            if (second === void 0) {
                return date.getUTCSeconds();
            }
            else {
                date.setUTCSeconds(second);
                if (millisecond !== void 0) {
                    date.setUTCMilliseconds(millisecond);
                }
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.millisecond = function (millisecond) {
            var date = this.toUTCLocalDate();
            if (millisecond === void 0) {
                return date.getUTCMilliseconds();
            }
            else {
                date.setUTCMilliseconds(millisecond);
                return DateTime.fromUTCLocalDate(date, this._zone);
            }
        };
        DateTime.prototype.weekday = function () {
            return this.toUTCLocalDate().getUTCDay();
        };
        DateTime.prototype.toUTCLocalDate = function () {
            return new Date(this._time + 60000 * this._zone._offset);
        };
        DateTime.prototype.toDate = function () {
            return new Date(this._time);
        };
        DateTime.prototype.valueOf = function () {
            return this._time;
        };
        DateTime.prototype.compareTo = function (that) {
            var x = this._time;
            var y = DateTime.time(that);
            return x < y ? -1 : x > y ? 1 : x === y ? 0 : NaN;
        };
        DateTime.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof DateTime) {
                return this._time === that._time && this._zone.equals(that._zone);
            }
            return false;
        };
        DateTime.prototype.hashCode = function () {
            if (DateTime._hashSeed === void 0) {
                DateTime._hashSeed = Murmur3.seed(DateTime);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(DateTime._hashSeed, Murmur3.hash(this._time)), this._zone.hashCode()));
        };
        DateTime.prototype.display = function (output, format) {
            if (format === void 0) { format = DateTime.Format.iso8601(); }
            format.writeDate(this, output);
        };
        DateTime.prototype.toString = function (format) {
            if (format === void 0) { format = DateTime.Format.iso8601(); }
            return format.format(this);
        };
        DateTime.current = function (zone) {
            zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.local();
            return new DateTime(Date.now(), zone);
        };
        DateTime.fromUTCLocalDate = function (date, zone) {
            return new DateTime(date.getTime() - 60000 * zone._offset, zone);
        };
        DateTime.from = function (init, zone) {
            var time = Date.UTC(init.year !== void 0 ? init.year : 1970, init.month !== void 0 ? init.month : 0, init.day !== void 0 ? init.day : 1, init.hour !== void 0 ? init.hour : 0, init.minute !== void 0 ? init.minute : 0, init.second !== void 0 ? init.second : 0, init.millisecond !== void 0 ? init.millisecond : 0);
            if (init.zone !== void 0) {
                zone = TimeZone.fromAny(init.zone);
            }
            if (zone !== void 0) {
                zone = TimeZone.fromAny(zone);
                time += 60000 * zone._offset;
            }
            else {
                zone = TimeZone.utc();
            }
            return new DateTime(time, zone);
        };
        DateTime.fromAny = function (date, zone) {
            if (date instanceof DateTime) {
                return date;
            }
            else if (date instanceof Date) {
                zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.utc();
                return new DateTime(date.getTime(), zone);
            }
            else if (typeof date === "number") {
                zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.utc();
                return new DateTime(date, zone);
            }
            else if (typeof date === "string") {
                return DateTime.parse(date, zone);
            }
            else if (date && typeof date === "object") {
                return DateTime.from(date, zone);
            }
            throw new TypeError("" + date);
        };
        DateTime.fromValue = function (value) {
            var positional;
            var header = value.header("date");
            if (header.isDefined()) {
                value = header;
                positional = true;
            }
            else {
                positional = false;
            }
            var init = {};
            value.forEach(function (item, index) {
                var key = item.key.stringValue(void 0);
                if (key !== void 0) {
                    if (key === "year") {
                        init.year = item.toValue().numberValue(init.year);
                    }
                    else if (key === "month") {
                        init.month = item.toValue().numberValue(init.month);
                    }
                    else if (key === "day") {
                        init.day = item.toValue().numberValue(init.day);
                    }
                    else if (key === "hour") {
                        init.hour = item.toValue().numberValue(init.hour);
                    }
                    else if (key === "minute") {
                        init.minute = item.toValue().numberValue(init.minute);
                    }
                    else if (key === "second") {
                        init.second = item.toValue().numberValue(init.second);
                    }
                    else if (key === "millisecond") {
                        init.millisecond = item.toValue().numberValue(init.millisecond);
                    }
                    else if (key === "zone") {
                        init.zone = item.toValue().cast(TimeZone.form(), init.zone);
                    }
                }
                else if (item instanceof Value && positional) {
                    if (index === 0) {
                        init.year = item.numberValue(init.year);
                    }
                    else if (index === 1) {
                        init.month = item.numberValue(init.month);
                    }
                    else if (index === 2) {
                        init.day = item.numberValue(init.day);
                    }
                    else if (index === 3) {
                        init.hour = item.numberValue(init.hour);
                    }
                    else if (index === 4) {
                        init.minute = item.numberValue(init.minute);
                    }
                    else if (index === 5) {
                        init.second = item.numberValue(init.second);
                    }
                    else if (index === 6) {
                        init.millisecond = item.numberValue(init.millisecond);
                    }
                    else if (index === 7) {
                        init.zone = item.cast(TimeZone.form(), init.zone);
                    }
                }
            });
            if (DateTime.isInit(init)) {
                return DateTime.from(init);
            }
            return void 0;
        };
        DateTime.parse = function (date, zone) {
            return DateTime.Format.iso8601().parse(date);
        };
        DateTime.time = function (date) {
            if (date instanceof DateTime) {
                return date._time;
            }
            else if (date instanceof Date) {
                return date.getTime();
            }
            else if (typeof date === "number") {
                return date;
            }
            else if (typeof date === "string") {
                return DateTime.parse(date).time();
            }
            else if (date && typeof date === "object") {
                return DateTime.from(date).time();
            }
            throw new TypeError("" + date);
        };
        DateTime.zone = function (date) {
            if (date instanceof DateTime) {
                return date._zone;
            }
            else {
                return TimeZone.utc();
            }
        };
        DateTime.isInit = function (value) {
            if (value && typeof value === "object") {
                var init = value;
                return init.year !== void 0 || init.month !== void 0 || init.day !== void 0
                    || init.hour !== void 0 || init.minute !== void 0 || init.second !== void 0
                    || init.millisecond !== void 0;
            }
            return false;
        };
        DateTime.form = function (unit) {
            if (unit !== void 0) {
                unit = DateTime.fromAny(unit);
            }
            if (unit !== void 0) {
                return new DateTime.Form(unit);
            }
            else {
                if (!DateTime._form) {
                    DateTime._form = new DateTime.Form();
                }
                return DateTime._form;
            }
        };
        return DateTime;
    }());

    var DateTimeParser = (function (_super) {
        __extends(DateTimeParser, _super);
        function DateTimeParser(dateParser) {
            var _this = _super.call(this) || this;
            _this.dateParser = dateParser;
            return _this;
        }
        DateTimeParser.prototype.feed = function (input) {
            return DateTimeParser.parse(input, this.dateParser);
        };
        DateTimeParser.parse = function (input, dateParser) {
            dateParser = dateParser.feed(input);
            if (dateParser.isDone()) {
                return Parser.done(DateTime.fromAny(dateParser.bind()));
            }
            else if (dateParser.isError()) {
                return dateParser.asError();
            }
            return new DateTimeParser(dateParser);
        };
        return DateTimeParser;
    }(Parser));
    DateTime.Parser = DateTimeParser;

    var DateTimeForm = (function (_super) {
        __extends(DateTimeForm, _super);
        function DateTimeForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        DateTimeForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit !== void 0 ? this._unit : new DateTime(0);
            }
            else {
                return new DateTimeForm(unit);
            }
        };
        DateTimeForm.prototype.mold = function (date) {
            date = DateTime.fromAny(date);
            return Text.from(date.toString());
        };
        DateTimeForm.prototype.cast = function (value) {
            var date;
            try {
                date = DateTime.fromValue(value);
                if (!date) {
                    var millis = value.numberValue(void 0);
                    if (millis !== void 0) {
                        date = new DateTime(millis);
                    }
                    else {
                        var string = value.stringValue(void 0);
                        if (string !== void 0) {
                            date = DateTime.parse(string);
                        }
                    }
                }
            }
            catch (e) {
            }
            return date;
        };
        return DateTimeForm;
    }(Form));
    DateTime.Form = DateTimeForm;

    var DateTimeSpecifiers = {
        _standard: void 0,
        standard: function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            var specifiers;
            if (locale === DateTimeLocale.standard()) {
                specifiers = DateTimeSpecifiers._standard;
            }
            if (!specifiers) {
                specifiers = {
                    Y: DateTimeFormat.year(),
                    m: DateTimeFormat.monthOfYear(),
                    B: DateTimeFormat.month(locale),
                    b: DateTimeFormat.shortMonth(locale),
                    d: DateTimeFormat.dayOfMonth(),
                    A: DateTimeFormat.weekday(locale),
                    a: DateTimeFormat.shortWeekday(locale),
                    H: DateTimeFormat.hour24(),
                    I: DateTimeFormat.hour12(),
                    p: DateTimeFormat.period(locale),
                    M: DateTimeFormat.minute(),
                    S: DateTimeFormat.second(),
                    L: DateTimeFormat.millisecond(),
                };
                if (locale === DateTimeLocale.standard()) {
                    DateTimeSpecifiers._standard = specifiers;
                }
            }
            return specifiers;
        },
    };

    var DateTimeFormat = (function () {
        function DateTimeFormat() {
        }
        DateTimeFormat.prototype.format = function (date) {
            date = DateTime.fromAny(date);
            var output = Unicode.stringOutput();
            this.writeDate(date, output);
            return output.bind();
        };
        DateTimeFormat.prototype.parse = function (input) {
            if (typeof input === "string") {
                input = Unicode.stringInput(input);
            }
            while (input.isCont() && Unicode.isSpace(input.head())) {
                input = input.step();
            }
            var parser = this.parseDate(input, {});
            if (parser.isDone()) {
                while (input.isCont() && Unicode.isSpace(input.head())) {
                    input = input.step();
                }
            }
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        DateTimeFormat.prototype.parseDate = function (input, date) {
            var dateParser = this.parseDateTime(input, date);
            if (dateParser.isDone()) {
                return Parser.done(DateTime.fromAny(dateParser.bind()));
            }
            else if (dateParser.isError()) {
                return dateParser.asError();
            }
            return new DateTime.Parser(dateParser);
        };
        DateTimeFormat.year = function () {
            if (!DateTimeFormat._year) {
                DateTimeFormat._year = new DateTimeFormat.Year();
            }
            return DateTimeFormat._year;
        };
        DateTimeFormat.monthOfYear = function () {
            if (!DateTimeFormat._monthOfYear) {
                DateTimeFormat._monthOfYear = new DateTimeFormat.MonthOfYear();
            }
            return DateTimeFormat._monthOfYear;
        };
        DateTimeFormat.month = function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            if (locale !== DateTimeLocale.standard()) {
                return new DateTimeFormat.Month(locale);
            }
            else {
                if (!DateTimeFormat._month) {
                    DateTimeFormat._month = new DateTimeFormat.Month(locale);
                }
                return DateTimeFormat._month;
            }
        };
        DateTimeFormat.shortMonth = function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            if (locale !== DateTimeLocale.standard()) {
                return new DateTimeFormat.ShortMonth(locale);
            }
            else {
                if (!DateTimeFormat._shortMonth) {
                    DateTimeFormat._shortMonth = new DateTimeFormat.ShortMonth(locale);
                }
                return DateTimeFormat._shortMonth;
            }
        };
        DateTimeFormat.dayOfMonth = function () {
            if (!DateTimeFormat._dayOfMonth) {
                DateTimeFormat._dayOfMonth = new DateTimeFormat.DayOfMonth();
            }
            return DateTimeFormat._dayOfMonth;
        };
        DateTimeFormat.weekday = function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            if (locale !== DateTimeLocale.standard()) {
                return new DateTimeFormat.Weekday(locale);
            }
            else {
                if (!DateTimeFormat._weekday) {
                    DateTimeFormat._weekday = new DateTimeFormat.Weekday(locale);
                }
                return DateTimeFormat._weekday;
            }
        };
        DateTimeFormat.shortWeekday = function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            if (locale !== DateTimeLocale.standard()) {
                return new DateTimeFormat.ShortWeekday(locale);
            }
            else {
                if (!DateTimeFormat._shortWeekday) {
                    DateTimeFormat._shortWeekday = new DateTimeFormat.ShortWeekday(locale);
                }
                return DateTimeFormat._shortWeekday;
            }
        };
        DateTimeFormat.hour24 = function () {
            if (!DateTimeFormat._hour24) {
                DateTimeFormat._hour24 = new DateTimeFormat.Hour24();
            }
            return DateTimeFormat._hour24;
        };
        DateTimeFormat.hour12 = function () {
            if (!DateTimeFormat._hour12) {
                DateTimeFormat._hour12 = new DateTimeFormat.Hour12();
            }
            return DateTimeFormat._hour12;
        };
        DateTimeFormat.period = function (locale) {
            if (locale === void 0) { locale = DateTimeLocale.standard(); }
            if (locale !== DateTimeLocale.standard()) {
                return new DateTimeFormat.Period(locale);
            }
            else {
                if (!DateTimeFormat._period) {
                    DateTimeFormat._period = new DateTimeFormat.Period(locale);
                }
                return DateTimeFormat._period;
            }
        };
        DateTimeFormat.minute = function () {
            if (!DateTimeFormat._minute) {
                DateTimeFormat._minute = new DateTimeFormat.Minute();
            }
            return DateTimeFormat._minute;
        };
        DateTimeFormat.second = function () {
            if (!DateTimeFormat._second) {
                DateTimeFormat._second = new DateTimeFormat.Second();
            }
            return DateTimeFormat._second;
        };
        DateTimeFormat.millisecond = function () {
            if (!DateTimeFormat._millisecond) {
                DateTimeFormat._millisecond = new DateTimeFormat.Millisecond();
            }
            return DateTimeFormat._millisecond;
        };
        DateTimeFormat.pattern = function (pattern, specifiers) {
            if (!specifiers || specifiers instanceof DateTimeLocale) {
                specifiers = DateTimeSpecifiers.standard(specifiers);
            }
            return new DateTimeFormat.Pattern(pattern, specifiers);
        };
        DateTimeFormat.iso8601 = function () {
            if (!DateTimeFormat._iso8601) {
                DateTimeFormat._iso8601 = new DateTimeFormat.Pattern("%Y-%m-%dT%H:%M:%S.%LZ", DateTimeSpecifiers.standard());
            }
            return DateTimeFormat._iso8601;
        };
        DateTimeFormat.parseDateNumber = function (input, factory, desc, minDigits, maxDigits, date, value, step) {
            if (value === void 0) { value = 0; }
            if (step === void 0) { step = 0; }
            var c = 0;
            while (step < maxDigits) {
                if (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
                    input.step();
                    value = 10 * value + Base10.decodeDigit(c);
                    step += 1;
                    continue;
                }
                break;
            }
            if (!input.isEmpty()) {
                if (step >= minDigits) {
                    return factory.bind(value, date || {}, input);
                }
                else {
                    return Parser.error(Diagnostic.expected(desc, input));
                }
            }
            return factory.cont(date || {}, value, step, input);
        };
        DateTimeFormat.parseDateString = function (input, factory, locale, date, output) {
            var c = 0;
            output = output || Unicode.stringOutput();
            do {
                if (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
                    input.step();
                    output.write(c);
                    continue;
                }
                else if (!input.isEmpty()) {
                    return factory.bind(locale, output.bind(), date || {}, input);
                }
                break;
            } while (true);
            return factory.cont(locale, date || {}, output, input);
        };
        DateTimeFormat.writeDateNumber2 = function (value, output) {
            var c1 = 48 + value % 10;
            value /= 10;
            var c0 = 48 + value % 10;
            output = output.write(c0).write(c1);
        };
        DateTimeFormat.writeDateNumber3 = function (value, output) {
            var c2 = 48 + value % 10;
            value /= 10;
            var c1 = 48 + value % 10;
            value /= 10;
            var c0 = 48 + value % 10;
            output = output.write(c0).write(c1).write(c2);
        };
        DateTimeFormat.writeDateNumber4 = function (value, output) {
            var c3 = 48 + value % 10;
            value /= 10;
            var c2 = 48 + value % 10;
            value /= 10;
            var c1 = 48 + value % 10;
            value /= 10;
            var c0 = 48 + value % 10;
            output = output.write(c0).write(c1).write(c2).write(c3);
        };
        return DateTimeFormat;
    }());
    DateTime.Format = DateTimeFormat;

    var YearFormat = (function (_super) {
        __extends(YearFormat, _super);
        function YearFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        YearFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber4(date.year(), output);
        };
        YearFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.YearParser.parse(input, date);
        };
        return YearFormat;
    }(DateTimeFormat));
    DateTimeFormat.Year = YearFormat;

    var MonthOfYearFormat = (function (_super) {
        __extends(MonthOfYearFormat, _super);
        function MonthOfYearFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MonthOfYearFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.month() + 1, output);
        };
        MonthOfYearFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.MonthOfYearParser.parse(input, date);
        };
        return MonthOfYearFormat;
    }(DateTimeFormat));
    DateTimeFormat.MonthOfYear = MonthOfYearFormat;

    var MonthFormat = (function (_super) {
        __extends(MonthFormat, _super);
        function MonthFormat(locale) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            return _this;
        }
        MonthFormat.prototype.writeDate = function (date, output) {
            output.write(this.locale.months[date.month()]);
        };
        MonthFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.MonthParser.parse(input, this.locale, date);
        };
        return MonthFormat;
    }(DateTimeFormat));
    DateTimeFormat.Month = MonthFormat;

    var ShortMonthFormat = (function (_super) {
        __extends(ShortMonthFormat, _super);
        function ShortMonthFormat(locale) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            return _this;
        }
        ShortMonthFormat.prototype.writeDate = function (date, output) {
            output.write(this.locale.shortMonths[date.month()]);
        };
        ShortMonthFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.ShortMonthParser.parse(input, this.locale, date);
        };
        return ShortMonthFormat;
    }(DateTimeFormat));
    DateTimeFormat.ShortMonth = ShortMonthFormat;

    var DayOfMonthFormat = (function (_super) {
        __extends(DayOfMonthFormat, _super);
        function DayOfMonthFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DayOfMonthFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.day(), output);
        };
        DayOfMonthFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.DayOfMonthParser.parse(input, date);
        };
        return DayOfMonthFormat;
    }(DateTimeFormat));
    DateTimeFormat.DayOfMonth = DayOfMonthFormat;

    var WeekdayFormat = (function (_super) {
        __extends(WeekdayFormat, _super);
        function WeekdayFormat(locale) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            return _this;
        }
        WeekdayFormat.prototype.writeDate = function (date, output) {
            output.write(this.locale.weekdays[date.weekday()]);
        };
        WeekdayFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.WeekdayParser.parse(input, this.locale, date);
        };
        return WeekdayFormat;
    }(DateTimeFormat));
    DateTimeFormat.Weekday = WeekdayFormat;

    var ShortWeekdayFormat = (function (_super) {
        __extends(ShortWeekdayFormat, _super);
        function ShortWeekdayFormat(locale) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            return _this;
        }
        ShortWeekdayFormat.prototype.writeDate = function (date, output) {
            output.write(this.locale.shortWeekdays[date.weekday()]);
        };
        ShortWeekdayFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.ShortWeekdayParser.parse(input, this.locale, date);
        };
        return ShortWeekdayFormat;
    }(DateTimeFormat));
    DateTimeFormat.ShortWeekday = ShortWeekdayFormat;

    var Hour24Format = (function (_super) {
        __extends(Hour24Format, _super);
        function Hour24Format() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Hour24Format.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.hour(), output);
        };
        Hour24Format.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.Hour24Parser.parse(input, date);
        };
        return Hour24Format;
    }(DateTimeFormat));
    DateTimeFormat.Hour24 = Hour24Format;

    var Hour12Format = (function (_super) {
        __extends(Hour12Format, _super);
        function Hour12Format() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Hour12Format.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.hour() % 12 || 12, output);
        };
        Hour12Format.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.Hour12Parser.parse(input, date);
        };
        return Hour12Format;
    }(DateTimeFormat));
    DateTimeFormat.Hour12 = Hour12Format;

    var PeriodFormat = (function (_super) {
        __extends(PeriodFormat, _super);
        function PeriodFormat(locale) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            return _this;
        }
        PeriodFormat.prototype.writeDate = function (date, output) {
            output.write(this.locale.periods[+(date.hour() >= 12)]);
        };
        PeriodFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.PeriodParser.parse(input, this.locale, date);
        };
        return PeriodFormat;
    }(DateTimeFormat));
    DateTimeFormat.Period = PeriodFormat;

    var MinuteFormat = (function (_super) {
        __extends(MinuteFormat, _super);
        function MinuteFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MinuteFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.minute(), output);
        };
        MinuteFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.MinuteParser.parse(input, date);
        };
        return MinuteFormat;
    }(DateTimeFormat));
    DateTimeFormat.Minute = MinuteFormat;

    var SecondFormat = (function (_super) {
        __extends(SecondFormat, _super);
        function SecondFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SecondFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber2(date.second(), output);
        };
        SecondFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.SecondParser.parse(input, date);
        };
        return SecondFormat;
    }(DateTimeFormat));
    DateTimeFormat.Second = SecondFormat;

    var MillisecondFormat = (function (_super) {
        __extends(MillisecondFormat, _super);
        function MillisecondFormat() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MillisecondFormat.prototype.writeDate = function (date, output) {
            DateTimeFormat.writeDateNumber3(date.millisecond(), output);
        };
        MillisecondFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.MillisecondParser.parse(input, date);
        };
        return MillisecondFormat;
    }(DateTimeFormat));
    DateTimeFormat.Millisecond = MillisecondFormat;

    var PatternFormat = (function (_super) {
        __extends(PatternFormat, _super);
        function PatternFormat(pattern, specifiers) {
            var _this = _super.call(this) || this;
            _this.pattern = pattern;
            _this.specifiers = specifiers;
            return _this;
        }
        PatternFormat.prototype.writeDate = function (date, output) {
            var pattern = this.pattern;
            var specifiers = this.specifiers;
            var i = 0;
            var j = 0;
            var n = pattern.length;
            while (j < n) {
                if (pattern.charCodeAt(j) === 37) {
                    if (i !== j) {
                        output.write(pattern.slice(i, j));
                    }
                    var s = pattern.charAt(j + 1);
                    var f = specifiers[s];
                    if (f) {
                        f.writeDate(date, output);
                    }
                    j += 2;
                    i = j;
                }
                else {
                    j += 1;
                }
            }
            if (i !== j) {
                output.write(pattern.slice(i, j));
            }
        };
        PatternFormat.prototype.parseDateTime = function (input, date) {
            return DateTimeFormat.PatternParser.parse(input, this.pattern, this.specifiers, date);
        };
        return PatternFormat;
    }(DateTimeFormat));
    DateTimeFormat.Pattern = PatternFormat;

    var YearParser = (function (_super) {
        __extends(YearParser, _super);
        function YearParser(date, year, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.year = year;
            _this.step = step;
            return _this;
        }
        YearParser.prototype.feed = function (input) {
            return YearParser.parse(input, this.date, this.year, this.step);
        };
        YearParser.parse = function (input, date, year, step) {
            return DateTimeFormat.parseDateNumber(input, YearParser, "full year", 4, 4, date, year, step);
        };
        YearParser.bind = function (year, date) {
            date.year = year;
            return Parser.done(date);
        };
        YearParser.cont = function (date, year, step) {
            return new YearParser(date, year, step);
        };
        return YearParser;
    }(Parser));
    DateTimeFormat.YearParser = YearParser;

    var MonthOfYearParser = (function (_super) {
        __extends(MonthOfYearParser, _super);
        function MonthOfYearParser(date, month, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.month = month;
            _this.step = step;
            return _this;
        }
        MonthOfYearParser.prototype.feed = function (input) {
            return MonthOfYearParser.parse(input, this.date, this.month, this.step);
        };
        MonthOfYearParser.parse = function (input, date, month, step) {
            return DateTimeFormat.parseDateNumber(input, MonthOfYearParser, "month number", 2, 2, date, month, step);
        };
        MonthOfYearParser.bind = function (month, date) {
            date.month = month - 1;
            return Parser.done(date);
        };
        MonthOfYearParser.cont = function (date, month, step) {
            return new MonthOfYearParser(date, month, step);
        };
        return MonthOfYearParser;
    }(Parser));
    DateTimeFormat.MonthOfYearParser = MonthOfYearParser;

    var MonthParser = (function (_super) {
        __extends(MonthParser, _super);
        function MonthParser(locale, date, output) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.date = date;
            _this.output = output;
            return _this;
        }
        MonthParser.prototype.feed = function (input) {
            return MonthParser.parse(input, this.locale, this.date, this.output);
        };
        MonthParser.parse = function (input, locale, date, output) {
            return DateTimeFormat.parseDateString(input, MonthParser, locale, date, output);
        };
        MonthParser.bind = function (locale, value, date, input) {
            var month = locale.months.indexOf(value);
            if (month >= 0) {
                date.month = month;
                return Parser.done(date);
            }
            else {
                return Parser.error(Diagnostic.message("expected month, but found " + value, input));
            }
        };
        MonthParser.cont = function (locale, date, output) {
            return new MonthParser(locale, date, output);
        };
        return MonthParser;
    }(Parser));
    DateTimeFormat.MonthParser = MonthParser;

    var ShortMonthParser = (function (_super) {
        __extends(ShortMonthParser, _super);
        function ShortMonthParser(locale, date, output) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.date = date;
            _this.output = output;
            return _this;
        }
        ShortMonthParser.prototype.feed = function (input) {
            return ShortMonthParser.parse(input, this.locale, this.date, this.output);
        };
        ShortMonthParser.parse = function (input, locale, date, output) {
            return DateTimeFormat.parseDateString(input, ShortMonthParser, locale, date, output);
        };
        ShortMonthParser.bind = function (locale, value, date, input) {
            var month = locale.shortMonths.indexOf(value);
            if (month >= 0) {
                date.month = month;
                return Parser.done(date);
            }
            else {
                return Parser.error(Diagnostic.message("expected short month, but found " + value, input));
            }
        };
        ShortMonthParser.cont = function (locale, date, output) {
            return new ShortMonthParser(locale, date, output);
        };
        return ShortMonthParser;
    }(Parser));
    DateTimeFormat.ShortMonthParser = ShortMonthParser;

    var DayOfMonthParser = (function (_super) {
        __extends(DayOfMonthParser, _super);
        function DayOfMonthParser(date, day, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.day = day;
            _this.step = step;
            return _this;
        }
        DayOfMonthParser.prototype.feed = function (input) {
            return DayOfMonthParser.parse(input, this.date, this.day, this.step);
        };
        DayOfMonthParser.parse = function (input, date, day, step) {
            return DateTimeFormat.parseDateNumber(input, DayOfMonthParser, "day of month", 2, 2, date, day, step);
        };
        DayOfMonthParser.bind = function (day, date) {
            date.day = day;
            return Parser.done(date);
        };
        DayOfMonthParser.cont = function (date, month, step) {
            return new DayOfMonthParser(date, month, step);
        };
        return DayOfMonthParser;
    }(Parser));
    DateTimeFormat.DayOfMonthParser = DayOfMonthParser;

    var WeekdayParser = (function (_super) {
        __extends(WeekdayParser, _super);
        function WeekdayParser(locale, date, output) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.date = date;
            _this.output = output;
            return _this;
        }
        WeekdayParser.prototype.feed = function (input) {
            return WeekdayParser.parse(input, this.locale, this.date, this.output);
        };
        WeekdayParser.parse = function (input, locale, date, output) {
            return DateTimeFormat.parseDateString(input, WeekdayParser, locale, date, output);
        };
        WeekdayParser.bind = function (locale, value, date, input) {
            var day = locale.weekdays.indexOf(value);
            if (day >= 0) {
                return Parser.done(date);
            }
            else {
                return Parser.error(Diagnostic.message("expected weekday, but found " + value, input));
            }
        };
        WeekdayParser.cont = function (locale, date, output) {
            return new WeekdayParser(locale, date, output);
        };
        return WeekdayParser;
    }(Parser));
    DateTimeFormat.WeekdayParser = WeekdayParser;

    var ShortWeekdayParser = (function (_super) {
        __extends(ShortWeekdayParser, _super);
        function ShortWeekdayParser(locale, date, output) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.date = date;
            _this.output = output;
            return _this;
        }
        ShortWeekdayParser.prototype.feed = function (input) {
            return ShortWeekdayParser.parse(input, this.locale, this.date, this.output);
        };
        ShortWeekdayParser.parse = function (input, locale, date, output) {
            return DateTimeFormat.parseDateString(input, ShortWeekdayParser, locale, date, output);
        };
        ShortWeekdayParser.bind = function (locale, value, date, input) {
            var day = locale.shortWeekdays.indexOf(value);
            if (day >= 0) {
                return Parser.done(date);
            }
            else {
                return Parser.error(Diagnostic.message("expected short weekday, but found " + value, input));
            }
        };
        ShortWeekdayParser.cont = function (locale, date, output) {
            return new ShortWeekdayParser(locale, date, output);
        };
        return ShortWeekdayParser;
    }(Parser));
    DateTimeFormat.ShortWeekdayParser = ShortWeekdayParser;

    var Hour24Parser = (function (_super) {
        __extends(Hour24Parser, _super);
        function Hour24Parser(date, hour, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.hour = hour;
            _this.step = step;
            return _this;
        }
        Hour24Parser.prototype.feed = function (input) {
            return Hour24Parser.parse(input, this.date, this.hour, this.step);
        };
        Hour24Parser.parse = function (input, date, hour, step) {
            return DateTimeFormat.parseDateNumber(input, Hour24Parser, "hour (24)", 2, 2, date, hour, step);
        };
        Hour24Parser.bind = function (hour, date) {
            date.hour = hour;
            return Parser.done(date);
        };
        Hour24Parser.cont = function (date, hour, step) {
            return new Hour24Parser(date, hour, step);
        };
        return Hour24Parser;
    }(Parser));
    DateTimeFormat.Hour24Parser = Hour24Parser;

    var Hour12Parser = (function (_super) {
        __extends(Hour12Parser, _super);
        function Hour12Parser(date, hour, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.hour = hour;
            _this.step = step;
            return _this;
        }
        Hour12Parser.prototype.feed = function (input) {
            return Hour12Parser.parse(input, this.date, this.hour, this.step);
        };
        Hour12Parser.parse = function (input, date, hour, step) {
            return DateTimeFormat.parseDateNumber(input, Hour12Parser, "hour (12)", 2, 2, date, hour, step);
        };
        Hour12Parser.bind = function (hour, date) {
            date.hour = (date.hour || 0) + hour;
            return Parser.done(date);
        };
        Hour12Parser.cont = function (date, hour, step) {
            return new Hour12Parser(date, hour, step);
        };
        return Hour12Parser;
    }(Parser));
    DateTimeFormat.Hour12Parser = Hour12Parser;

    var PeriodParser = (function (_super) {
        __extends(PeriodParser, _super);
        function PeriodParser(locale, date, output) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.date = date;
            _this.output = output;
            return _this;
        }
        PeriodParser.prototype.feed = function (input) {
            return PeriodParser.parse(input, this.locale, this.date, this.output);
        };
        PeriodParser.parse = function (input, locale, date, output) {
            return DateTimeFormat.parseDateString(input, PeriodParser, locale, date, output);
        };
        PeriodParser.bind = function (locale, value, date, input) {
            var period = locale.months.indexOf(value);
            if (period >= 0) {
                date.hour = (date.hour || 0) + 12 * period;
                return Parser.done(date);
            }
            else {
                return Parser.error(Diagnostic.message("expected period of day, but found " + value, input));
            }
        };
        PeriodParser.cont = function (locale, date, output) {
            return new PeriodParser(locale, date, output);
        };
        return PeriodParser;
    }(Parser));
    DateTimeFormat.PeriodParser = PeriodParser;

    var MinuteParser = (function (_super) {
        __extends(MinuteParser, _super);
        function MinuteParser(date, minute, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.minute = minute;
            _this.step = step;
            return _this;
        }
        MinuteParser.prototype.feed = function (input) {
            return MinuteParser.parse(input, this.date, this.minute, this.step);
        };
        MinuteParser.parse = function (input, date, minute, step) {
            return DateTimeFormat.parseDateNumber(input, MinuteParser, "minute", 2, 2, date, minute, step);
        };
        MinuteParser.bind = function (minute, date) {
            date.minute = minute;
            return Parser.done(date);
        };
        MinuteParser.cont = function (date, minute, step) {
            return new MinuteParser(date, minute, step);
        };
        return MinuteParser;
    }(Parser));
    DateTimeFormat.MinuteParser = MinuteParser;

    var SecondParser = (function (_super) {
        __extends(SecondParser, _super);
        function SecondParser(date, second, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.second = second;
            _this.step = step;
            return _this;
        }
        SecondParser.prototype.feed = function (input) {
            return SecondParser.parse(input, this.date, this.second, this.step);
        };
        SecondParser.parse = function (input, date, second, step) {
            return DateTimeFormat.parseDateNumber(input, SecondParser, "second", 2, 2, date, second, step);
        };
        SecondParser.bind = function (second, date) {
            date.second = second;
            return Parser.done(date);
        };
        SecondParser.cont = function (date, second, step) {
            return new SecondParser(date, second, step);
        };
        return SecondParser;
    }(Parser));
    DateTimeFormat.SecondParser = SecondParser;

    var MillisecondParser = (function (_super) {
        __extends(MillisecondParser, _super);
        function MillisecondParser(date, millisecond, step) {
            var _this = _super.call(this) || this;
            _this.date = date;
            _this.millisecond = millisecond;
            _this.step = step;
            return _this;
        }
        MillisecondParser.prototype.feed = function (input) {
            return MillisecondParser.parse(input, this.date, this.millisecond, this.step);
        };
        MillisecondParser.parse = function (input, date, millisecond, step) {
            return DateTimeFormat.parseDateNumber(input, MillisecondParser, "millisecond", 1, 3, date, millisecond, step);
        };
        MillisecondParser.bind = function (millisecond, date) {
            date.millisecond = millisecond;
            return Parser.done(date);
        };
        MillisecondParser.cont = function (date, millisecond, step) {
            return new MillisecondParser(date, millisecond, step);
        };
        return MillisecondParser;
    }(Parser));
    DateTimeFormat.MillisecondParser = MillisecondParser;

    var PatternParser = (function (_super) {
        __extends(PatternParser, _super);
        function PatternParser(pattern, specifiers, date, dateParser, step) {
            var _this = _super.call(this) || this;
            _this.pattern = pattern;
            _this.specifiers = specifiers;
            _this.date = date;
            _this.dateParser = dateParser;
            _this.step = step;
            return _this;
        }
        PatternParser.prototype.feed = function (input) {
            return PatternParser.parse(input, this.pattern, this.specifiers, this.date, this.dateParser, this.step);
        };
        PatternParser.parse = function (input, pattern, specifiers, date, dateParser, step) {
            if (date === void 0) { date = {}; }
            if (step === void 0) { step = 0; }
            var c = 0;
            var n = pattern.length;
            while (step < n) {
                var p = pattern.charCodeAt(step);
                if (p === 37) {
                    if (!dateParser) {
                        var s = pattern.charAt(step + 1);
                        var format = specifiers[s];
                        if (format) {
                            dateParser = format.parseDateTime(input, date);
                        }
                        else {
                            return Parser.error(Diagnostic.message("unknown format specifier: " + s, input));
                        }
                    }
                    else {
                        dateParser = dateParser.feed(input);
                    }
                    if (dateParser.isDone()) {
                        date = dateParser.bind();
                        dateParser = void 0;
                        step += 2;
                        continue;
                    }
                    else if (dateParser.isError()) {
                        return dateParser.asError();
                    }
                }
                else if (input.isCont()) {
                    c = input.head();
                    if (c === p) {
                        input.step();
                        step += 1;
                        continue;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(p, input));
                    }
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.unexpected(input));
                }
                break;
            }
            if (step === n) {
                return Parser.done(date);
            }
            return new PatternParser(pattern, specifiers, date, dateParser, step);
        };
        return PatternParser;
    }(Parser));
    DateTimeFormat.PatternParser = PatternParser;

    var MILLIS_PER_SECOND = 1000;
    var MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;
    var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
    var TimeInterval = (function () {
        function TimeInterval() {
        }
        TimeInterval.prototype.next = function (d, k) {
            return this.floor(this.offset(d, k));
        };
        TimeInterval.prototype.ceil = function (d) {
            if (d instanceof DateTime) {
                d = d.time(d.time() - 1);
            }
            else {
                d = DateTime.time(d) - 1;
            }
            return this.next(this.floor(d), 1);
        };
        TimeInterval.prototype.round = function (d) {
            d = DateTime.fromAny(d);
            var d0 = this.floor(d);
            var d1 = this.ceil(d);
            return d.time() - d0.time() < d1.time() - d.time() ? d0 : d1;
        };
        TimeInterval.prototype.range = function (d0, d1, step) {
            d0 = this.ceil(d0);
            d1 = DateTime.time(d1);
            var ds = [];
            step = typeof step === "number" ? Math.floor(step) : 1;
            if (step > 0) {
                while (d0.time() < d1) {
                    ds.push(d0);
                    d0 = this.next(d0, step);
                }
            }
            return ds;
        };
        TimeInterval.prototype.filter = function (predicate) {
            return new TimeInterval.Filter(this, predicate);
        };
        TimeInterval.year = function (k) {
            if (!TimeInterval._year) {
                TimeInterval._year = new TimeInterval.Year();
            }
            if (k === void 0) {
                return TimeInterval._year;
            }
            else {
                return TimeInterval._year.every(k);
            }
        };
        TimeInterval.month = function (k) {
            if (!TimeInterval._month) {
                TimeInterval._month = new TimeInterval.Month();
            }
            if (k === void 0) {
                return TimeInterval._month;
            }
            else {
                return TimeInterval._month.every(k);
            }
        };
        TimeInterval.week = function () {
            if (!TimeInterval._week) {
                TimeInterval._week = new TimeInterval.Week();
            }
            return TimeInterval._week;
        };
        TimeInterval.day = function (k) {
            if (!TimeInterval._day) {
                TimeInterval._day = new TimeInterval.Day();
            }
            if (k === void 0) {
                return TimeInterval._day;
            }
            else {
                return TimeInterval._day.every(k);
            }
        };
        TimeInterval.hour = function (k) {
            if (!TimeInterval._hour) {
                TimeInterval._hour = new TimeInterval.Hour();
            }
            if (k === void 0) {
                return TimeInterval._hour;
            }
            else {
                return TimeInterval._hour.every(k);
            }
        };
        TimeInterval.minute = function (k) {
            if (!TimeInterval._minute) {
                TimeInterval._minute = new TimeInterval.Minute();
            }
            if (k === void 0) {
                return TimeInterval._minute;
            }
            else {
                return TimeInterval._minute.every(k);
            }
        };
        TimeInterval.second = function (k) {
            if (!TimeInterval._second) {
                TimeInterval._second = new TimeInterval.Second();
            }
            if (k === void 0) {
                return TimeInterval._second;
            }
            else {
                return TimeInterval._second.every(k);
            }
        };
        TimeInterval.millisecond = function (k) {
            if (!TimeInterval._millisecond) {
                TimeInterval._millisecond = new TimeInterval.Millisecond();
            }
            if (k === void 0) {
                return TimeInterval._millisecond;
            }
            else {
                return TimeInterval._millisecond.every(k);
            }
        };
        TimeInterval.years = function (d0, d1, step) {
            return TimeInterval.year().range(d0, d1, step);
        };
        TimeInterval.months = function (d0, d1, step) {
            return TimeInterval.month().range(d0, d1, step);
        };
        TimeInterval.weeks = function (d0, d1, step) {
            return TimeInterval.week().range(d0, d1, step);
        };
        TimeInterval.days = function (d0, d1, step) {
            return TimeInterval.day().range(d0, d1, step);
        };
        TimeInterval.hours = function (d0, d1, step) {
            return TimeInterval.hour().range(d0, d1, step);
        };
        TimeInterval.minutes = function (d0, d1, step) {
            return TimeInterval.minute().range(d0, d1, step);
        };
        TimeInterval.seconds = function (d0, d1, step) {
            return TimeInterval.second().range(d0, d1, step);
        };
        TimeInterval.milliseconds = function (d0, d1, step) {
            return TimeInterval.millisecond().range(d0, d1, step);
        };
        return TimeInterval;
    }());
    var UnitTimeInterval = (function (_super) {
        __extends(UnitTimeInterval, _super);
        function UnitTimeInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UnitTimeInterval;
    }(TimeInterval));

    var FilterInterval = (function (_super) {
        __extends(FilterInterval, _super);
        function FilterInterval(unit, predicate) {
            var _this = _super.call(this) || this;
            _this.unit = unit;
            _this.predicate = predicate;
            return _this;
        }
        FilterInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            while (k < 0) {
                do {
                    d = this.unit.offset(d, -1);
                } while (!this.predicate(d));
                k += 1;
            }
            while (k > 0) {
                do {
                    d = this.unit.offset(d, 1);
                } while (!this.predicate(d));
                k -= 1;
            }
            return d;
        };
        FilterInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            while (d = this.unit.floor(d), !this.predicate(d)) {
                d = d.time(d.time() - 1);
            }
            return d;
        };
        return FilterInterval;
    }(TimeInterval));
    TimeInterval.Filter = FilterInterval;

    var YearInterval = (function (_super) {
        __extends(YearInterval, _super);
        function YearInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        YearInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = d.year(d.year() + k);
            return d;
        };
        YearInterval.prototype.next = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            return d.year(d.year() + k).month(0, 1).hour(0, 0, 0, 0);
        };
        YearInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            return d.month(0, 1).hour(0, 0, 0, 0);
        };
        YearInterval.prototype.ceil = function (d) {
            d = DateTime.fromAny(d);
            d = d.time(d.time() - 1);
            d = d.month(0, 1).hour(0, 0, 0, 0);
            d = d.year(d.year() + 1);
            return d.month(0, 1).hour(0, 0, 0, 0);
        };
        YearInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Years(k);
            }
            else {
                throw new Error("" + k);
            }
        };
        return YearInterval;
    }(UnitTimeInterval));
    TimeInterval.Year = YearInterval;

    var YearsInterval = (function (_super) {
        __extends(YearsInterval, _super);
        function YearsInterval(stride) {
            var _this = _super.call(this) || this;
            _this.stride = stride || 1;
            return _this;
        }
        YearsInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            return d.year(d.year() + k * this.stride);
        };
        YearsInterval.prototype.next = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = d.year(Math.floor((d.year() + k * this.stride) / this.stride) * this.stride);
            return d.month(0, 1).hour(0, 0, 0, 0);
        };
        YearsInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            d = d.year(Math.floor(d.year() / this.stride) * this.stride);
            return d.month(0, 1).hour(0, 0, 0, 0);
        };
        YearsInterval.prototype.ceil = function (d) {
            d = DateTime.fromAny(d);
            d = d.time(d.time() - 1);
            d = d.year(Math.floor(d.year() / this.stride) * this.stride);
            d = d.month(0, 1).hour(0, 0, 0, 0);
            d = d.year(Math.floor((d.year() + this.stride) / this.stride) * this.stride);
            return d.month(0, 1).hour(0, 0, 0, 0);
        };
        return YearsInterval;
    }(TimeInterval));
    TimeInterval.Years = YearsInterval;

    var MonthInterval = (function (_super) {
        __extends(MonthInterval, _super);
        function MonthInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MonthInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            return d.month(d.month() + k);
        };
        MonthInterval.prototype.next = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = d.month(d.month() + k);
            return d.day(1).hour(0, 0, 0, 0);
        };
        MonthInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            return d.day(1).hour(0, 0, 0, 0);
        };
        MonthInterval.prototype.ceil = function (d) {
            d = DateTime.fromAny(d);
            d = d.time(d.time() - 1);
            d = d.day(1).hour(0, 0, 0, 0);
            d = d.month(d.month() + 1);
            return d.day(1).hour(0, 0, 0, 0);
        };
        MonthInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Filter(this, MonthInterval.modulo.bind(void 0, k));
            }
            else {
                throw new Error("" + k);
            }
        };
        MonthInterval.modulo = function (k, d) {
            return d.month() % k === 0;
        };
        return MonthInterval;
    }(UnitTimeInterval));
    TimeInterval.Month = MonthInterval;

    var WeekInterval = (function (_super) {
        __extends(WeekInterval, _super);
        function WeekInterval(day) {
            if (day === void 0) { day = 0; }
            var _this = _super.call(this) || this;
            _this.day = day;
            return _this;
        }
        WeekInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            return d.day(d.day() + 7 * k);
        };
        WeekInterval.prototype.next = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = d.day(d.day() + 7 * k);
            d = d.day(d.day() - (d.weekday() + 7 - this.day) % 7);
            return d.hour(0, 0, 0, 0);
        };
        WeekInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            d = d.day(d.day() - (d.weekday() + 7 - this.day) % 7);
            return d.hour(0, 0, 0, 0);
        };
        WeekInterval.prototype.ceil = function (d) {
            d = DateTime.fromAny(d);
            d = d.time(d.time() - 1);
            d = d.day(d.day() - (d.weekday() + 7 - this.day) % 7);
            d = d.hour(0, 0, 0, 0);
            d = d.day(d.day() + 7);
            return d.hour(0, 0, 0, 0);
        };
        return WeekInterval;
    }(TimeInterval));
    TimeInterval.Week = WeekInterval;

    var DayInterval = (function (_super) {
        __extends(DayInterval, _super);
        function DayInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DayInterval.prototype.offset = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            return d.day(d.day() + k);
        };
        DayInterval.prototype.next = function (d, k) {
            d = DateTime.fromAny(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = d.day(d.day() + k);
            return d.hour(0, 0, 0, 0);
        };
        DayInterval.prototype.floor = function (d) {
            d = DateTime.fromAny(d);
            return d.hour(0, 0, 0, 0);
        };
        DayInterval.prototype.ceil = function (d) {
            d = DateTime.fromAny(d);
            d = d.time(d.time() - 1);
            d = d.hour(0, 0, 0, 0);
            d = d.day(d.day() + 1);
            return d.hour(0, 0, 0, 0);
        };
        DayInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Filter(this, DayInterval.modulo.bind(void 0, k));
            }
            else {
                throw new Error("" + k);
            }
        };
        DayInterval.modulo = function (k, d) {
            return d.day() % k === 0;
        };
        return DayInterval;
    }(UnitTimeInterval));
    TimeInterval.Day = DayInterval;

    var HourInterval = (function (_super) {
        __extends(HourInterval, _super);
        function HourInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HourInterval.prototype.offset = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * MILLIS_PER_HOUR;
            return new DateTime(d, z);
        };
        HourInterval.prototype.next = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * MILLIS_PER_HOUR;
            var dtz = z.offset() * MILLIS_PER_MINUTE % MILLIS_PER_HOUR;
            if (dtz < 0) {
                dtz += MILLIS_PER_HOUR;
            }
            d = Math.floor((d - dtz) / MILLIS_PER_HOUR) * MILLIS_PER_HOUR + dtz;
            return new DateTime(d, z);
        };
        HourInterval.prototype.floor = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            var dtz = z.offset() * MILLIS_PER_MINUTE % MILLIS_PER_HOUR;
            if (dtz < 0) {
                dtz += MILLIS_PER_HOUR;
            }
            d = Math.floor((d - dtz) / MILLIS_PER_HOUR) * MILLIS_PER_HOUR + dtz;
            return new DateTime(d, z);
        };
        HourInterval.prototype.ceil = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            d -= 1;
            var dtz = z.offset() * MILLIS_PER_MINUTE % MILLIS_PER_HOUR;
            if (dtz < 0) {
                dtz += MILLIS_PER_HOUR;
            }
            d = (Math.floor((d - dtz) / MILLIS_PER_HOUR) * MILLIS_PER_HOUR + dtz) + MILLIS_PER_HOUR;
            d = Math.floor((d - dtz) / MILLIS_PER_HOUR) * MILLIS_PER_HOUR + dtz;
            return new DateTime(d, z);
        };
        HourInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Filter(this, HourInterval.modulo.bind(void 0, k));
            }
            else {
                throw new Error("" + k);
            }
        };
        HourInterval.modulo = function (k, d) {
            return d.hour() % k === 0;
        };
        return HourInterval;
    }(UnitTimeInterval));
    TimeInterval.Hour = HourInterval;

    var MinuteInterval = (function (_super) {
        __extends(MinuteInterval, _super);
        function MinuteInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MinuteInterval.prototype.offset = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * MILLIS_PER_MINUTE;
            return new DateTime(d, z);
        };
        MinuteInterval.prototype.next = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d = Math.floor((d + k * MILLIS_PER_MINUTE) / MILLIS_PER_MINUTE) * MILLIS_PER_MINUTE;
            return new DateTime(d, z);
        };
        MinuteInterval.prototype.floor = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            d = Math.floor(d / MILLIS_PER_MINUTE) * MILLIS_PER_MINUTE;
            return new DateTime(d, z);
        };
        MinuteInterval.prototype.ceil = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            d = Math.floor(((Math.floor((d - 1) / MILLIS_PER_MINUTE) * MILLIS_PER_MINUTE) + MILLIS_PER_MINUTE) / MILLIS_PER_MINUTE) * MILLIS_PER_MINUTE;
            return new DateTime(d, z);
        };
        MinuteInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Filter(this, MinuteInterval.modulo.bind(void 0, k));
            }
            else {
                throw new Error("" + k);
            }
        };
        MinuteInterval.modulo = function (k, d) {
            return d.minute() % k === 0;
        };
        return MinuteInterval;
    }(UnitTimeInterval));
    TimeInterval.Minute = MinuteInterval;

    var SecondInterval = (function (_super) {
        __extends(SecondInterval, _super);
        function SecondInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SecondInterval.prototype.offset = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * MILLIS_PER_SECOND;
            return new DateTime(d, z);
        };
        SecondInterval.prototype.next = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * MILLIS_PER_SECOND;
            d = Math.floor(d / MILLIS_PER_SECOND) * MILLIS_PER_SECOND;
            return new DateTime(d, z);
        };
        SecondInterval.prototype.floor = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            d = Math.floor(d / MILLIS_PER_SECOND) * MILLIS_PER_SECOND;
            return new DateTime(d, z);
        };
        SecondInterval.prototype.ceil = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            d = Math.floor(((Math.floor((d - 1) / MILLIS_PER_SECOND) * MILLIS_PER_SECOND) + MILLIS_PER_SECOND) / MILLIS_PER_SECOND) * MILLIS_PER_SECOND;
            return new DateTime(d, z);
        };
        SecondInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Filter(this, SecondInterval.modulo.bind(void 0, k));
            }
            else {
                throw new Error('' + k);
            }
        };
        SecondInterval.modulo = function (k, d) {
            return d.second() % k === 0;
        };
        return SecondInterval;
    }(UnitTimeInterval));
    TimeInterval.Second = SecondInterval;

    var MillisecondInterval = (function (_super) {
        __extends(MillisecondInterval, _super);
        function MillisecondInterval() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MillisecondInterval.prototype.offset = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k;
            return new DateTime(d, z);
        };
        MillisecondInterval.prototype.next = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k;
            return new DateTime(d, z);
        };
        MillisecondInterval.prototype.floor = function (d) {
            return DateTime.fromAny(d);
        };
        MillisecondInterval.prototype.ceil = function (d) {
            return DateTime.fromAny(d);
        };
        MillisecondInterval.prototype.every = function (k) {
            if (k === 1) {
                return this;
            }
            else if (isFinite(k) && k >= 1) {
                return new TimeInterval.Milliseconds(k);
            }
            else {
                throw new Error("" + k);
            }
        };
        return MillisecondInterval;
    }(UnitTimeInterval));
    TimeInterval.Millisecond = MillisecondInterval;

    var MillisecondsInterval = (function (_super) {
        __extends(MillisecondsInterval, _super);
        function MillisecondsInterval(stride) {
            var _this = _super.call(this) || this;
            if (typeof stride !== "number" || !isFinite(stride) || isNaN(stride)) {
                stride = 1;
            }
            _this.stride = stride;
            return _this;
        }
        MillisecondsInterval.prototype.offset = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            d += k * this.stride;
            return new DateTime(d, z);
        };
        MillisecondsInterval.prototype.next = function (d, k) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
            var stride = this.stride;
            d = Math.floor((d + k * stride) / stride) * stride;
            return new DateTime(d, z);
        };
        MillisecondsInterval.prototype.floor = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            var stride = this.stride;
            d = Math.floor(d / stride) * stride;
            return new DateTime(d, z);
        };
        MillisecondsInterval.prototype.ceil = function (d) {
            var z = DateTime.zone(d);
            d = DateTime.time(d);
            var stride = this.stride;
            d = Math.floor(((Math.floor((d - 1) / stride) * stride) + stride) / stride) * stride;
            return new DateTime(d, z);
        };
        return MillisecondsInterval;
    }(TimeInterval));
    TimeInterval.Milliseconds = MillisecondsInterval;

    var UriException = (function (_super) {
        __extends(UriException, _super);
        function UriException(message) {
            var _this = _super.call(this, message instanceof Diagnostic ? message.message() || void 0 : message) || this;
            if (message instanceof Diagnostic) {
                _this.diagnostic = message;
            }
            _this.__proto__ = UriException.prototype;
            return _this;
        }
        UriException.prototype.toString = function () {
            if (this.diagnostic) {
                return this.diagnostic.toString();
            }
            else {
                return _super.prototype.toString.call(this);
            }
        };
        return UriException;
    }(Error));

    var Uri = (function () {
        function Uri(scheme, authority, path, query, fragment) {
            this._scheme = scheme;
            this._authority = authority;
            this._path = path;
            this._query = query;
            this._fragment = fragment;
        }
        Uri.prototype.isDefined = function () {
            return this._scheme.isDefined() || this._authority.isDefined() || this._path.isDefined()
                || this._query.isDefined() || this._fragment.isDefined();
        };
        Uri.prototype.isEmpty = function () {
            return !this._scheme.isDefined() && !this._authority.isDefined() && this._path.isEmpty()
                && !this._query.isDefined() && !this._fragment.isDefined();
        };
        Uri.prototype.scheme = function (scheme) {
            if (scheme === void 0) {
                return this._scheme;
            }
            else {
                scheme = Uri.Scheme.fromAny(scheme);
                if (scheme !== this._scheme) {
                    return this.copy(scheme, this._authority, this._path, this._query, this._fragment);
                }
                else {
                    return this;
                }
            }
        };
        Uri.prototype.schemePart = function (scheme) {
            if (scheme === void 0) {
                return this._scheme.toString();
            }
            else {
                return this.scheme(Uri.Scheme.parse(scheme));
            }
        };
        Uri.prototype.schemeName = function (scheme) {
            if (scheme === void 0) {
                return this._scheme.name();
            }
            else {
                return this.scheme(Uri.Scheme.from(scheme));
            }
        };
        Uri.prototype.authority = function (authority) {
            if (authority === void 0) {
                return this._authority;
            }
            else {
                authority = Uri.Authority.fromAny(authority);
                if (authority !== this._authority) {
                    return this.copy(this._scheme, authority, this._path, this._query, this._fragment);
                }
                else {
                    return this;
                }
            }
        };
        Uri.prototype.authorityPart = function (authority) {
            if (authority === void 0) {
                return this._authority.toString();
            }
            else {
                return this.authority(Uri.Authority.parse(authority));
            }
        };
        Uri.prototype.user = function (user) {
            if (user === void 0) {
                return this._authority.user();
            }
            else {
                return this.authority(this._authority.user(user));
            }
        };
        Uri.prototype.userPart = function (user) {
            if (user === void 0) {
                return this._authority.userPart();
            }
            else {
                return this.authority(this._authority.userPart(user));
            }
        };
        Uri.prototype.username = function (username, password) {
            if (username === void 0) {
                return this._authority.username();
            }
            else {
                return this.authority(this._authority.username(username, password));
            }
        };
        Uri.prototype.password = function (password) {
            if (password === void 0) {
                return this._authority.password();
            }
            else {
                return this.authority(this._authority.password(password));
            }
        };
        Uri.prototype.host = function (host) {
            if (host === void 0) {
                return this._authority.host();
            }
            else {
                return this.authority(this._authority.host(host));
            }
        };
        Uri.prototype.hostPart = function (host) {
            if (host === void 0) {
                return this._authority.hostPart();
            }
            else {
                return this.authority(this._authority.hostPart(host));
            }
        };
        Uri.prototype.hostAddress = function () {
            return this._authority.hostAddress();
        };
        Uri.prototype.hostName = function (address) {
            if (address === void 0) {
                return this._authority.hostName();
            }
            else {
                return this.authority(this._authority.hostName(address));
            }
        };
        Uri.prototype.hostIPv4 = function (address) {
            if (address === void 0) {
                return this._authority.hostIPv4();
            }
            else {
                return this.authority(this._authority.hostIPv4(address));
            }
        };
        Uri.prototype.hostIPv6 = function (address) {
            if (address === void 0) {
                return this._authority.hostIPv6();
            }
            else {
                return this.authority(this._authority.hostIPv6(address));
            }
        };
        Uri.prototype.port = function (port) {
            if (port === void 0) {
                return this._authority.port();
            }
            else {
                return this.authority(this._authority.port(port));
            }
        };
        Uri.prototype.portPart = function (port) {
            if (port === void 0) {
                return this._authority.portPart();
            }
            else {
                return this.authority(this._authority.portPart(port));
            }
        };
        Uri.prototype.portNumber = function (port) {
            if (port === void 0) {
                return this._authority.portNumber();
            }
            else {
                return this.authority(this._authority.portNumber(port));
            }
        };
        Uri.prototype.path = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (arguments.length === 0) {
                return this._path;
            }
            else {
                var path = Uri.Path.from.apply(void 0, components);
                if (path !== this._path) {
                    return this.copy(this._scheme, this._authority, path, this._query, this._fragment);
                }
                else {
                    return this;
                }
            }
        };
        Uri.prototype.pathPart = function (path) {
            if (path === void 0) {
                return this._path.toString();
            }
            else {
                return this.path(Uri.Path.parse(path));
            }
        };
        Uri.prototype.pathName = function (name) {
            if (name === void 0) {
                return this._path.name();
            }
            else {
                return this.path(this._path.name(name));
            }
        };
        Uri.prototype.parentPath = function () {
            return this._path.parent();
        };
        Uri.prototype.basePath = function () {
            return this._path.base();
        };
        Uri.prototype.parent = function () {
            return Uri.from(this._scheme, this._authority, this._path.parent());
        };
        Uri.prototype.base = function () {
            return Uri.from(this._scheme, this._authority, this._path.base());
        };
        Uri.prototype.appendedPath = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            return this.path(this._path.appended.apply(this._path, arguments));
        };
        Uri.prototype.appendedSlash = function () {
            return this.path(this._path.appendedSlash());
        };
        Uri.prototype.appendedSegment = function (segment) {
            return this.path(this._path.appendedSegment(segment));
        };
        Uri.prototype.prependedPath = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            return this.path(this._path.prepended.apply(this._path, arguments));
        };
        Uri.prototype.prependedSlash = function () {
            return this.path(this._path.prependedSlash());
        };
        Uri.prototype.prependedSegment = function (segment) {
            return this.path(this._path.prependedSegment(segment));
        };
        Uri.prototype.query = function (query) {
            if (query === void 0) {
                return this._query;
            }
            else {
                query = Uri.Query.fromAny(query);
                if (query !== this._query) {
                    return this.copy(this._scheme, this._authority, this._path, query, this._fragment);
                }
                else {
                    return this;
                }
            }
        };
        Uri.prototype.queryPart = function (query) {
            if (query === void 0) {
                return this._query.toString();
            }
            else {
                return this.query(Uri.Query.parse(query));
            }
        };
        Uri.prototype.updatedQuery = function (key, value) {
            return this.query(this._query.updated(key, value));
        };
        Uri.prototype.removedQuery = function (key) {
            return this.query(this._query.removed(key));
        };
        Uri.prototype.appendedQuery = function (key, value) {
            return this.query(this._query.appended(key, value));
        };
        Uri.prototype.prependedQuery = function (key, value) {
            return this.query(this._query.prepended(key, value));
        };
        Uri.prototype.fragment = function (fragment) {
            if (fragment === void 0) {
                return this._fragment;
            }
            else {
                fragment = Uri.Fragment.fromAny(fragment);
                if (fragment !== this._fragment) {
                    return Uri.from(this._scheme, this._authority, this._path, this._query, fragment);
                }
                else {
                    return this;
                }
            }
        };
        Uri.prototype.fragmentPart = function (fragment) {
            if (fragment === void 0) {
                return this._fragment.toString();
            }
            else {
                return this.fragment(Uri.Fragment.parse(fragment));
            }
        };
        Uri.prototype.fragmentIdentifier = function (identifier) {
            if (identifier === void 0) {
                return this._fragment.identifier();
            }
            else {
                return this.fragment(Uri.Fragment.from(identifier));
            }
        };
        Uri.prototype.endpoint = function () {
            if (this._path.isDefined() || this._query.isDefined() || this._fragment.isDefined()) {
                return Uri.from(this._scheme, this._authority);
            }
            else {
                return this;
            }
        };
        Uri.prototype.resolve = function (relative) {
            relative = Uri.fromAny(relative);
            if (relative._scheme.isDefined()) {
                return this.copy(relative._scheme, relative._authority, relative._path.removeDotSegments(), relative._query, relative._fragment);
            }
            else if (relative._authority.isDefined()) {
                return this.copy(this._scheme, relative._authority, relative._path.removeDotSegments(), relative._query, relative._fragment);
            }
            else if (relative._path.isEmpty()) {
                return this.copy(this._scheme, this._authority, this._path, relative._query.isDefined() ? relative._query : this._query, relative._fragment);
            }
            else if (relative._path.isAbsolute()) {
                return this.copy(this._scheme, this._authority, relative._path.removeDotSegments(), relative._query, relative._fragment);
            }
            else {
                return this.copy(this._scheme, this._authority, this.merge(relative._path).removeDotSegments(), relative._query, relative._fragment);
            }
        };
        Uri.prototype.merge = function (relative) {
            if (this._authority.isDefined() && this._path.isEmpty()) {
                return relative.prependedSlash();
            }
            else if (this._path.isEmpty()) {
                return relative;
            }
            else {
                return this._path.merge(relative);
            }
        };
        Uri.prototype.unresolve = function (absolute) {
            absolute = Uri.fromAny(absolute);
            if (!this._scheme.equals(absolute._scheme) || !this._authority.equals(absolute._authority)) {
                return absolute;
            }
            else {
                return Uri.from(Uri.Scheme.undefined(), Uri.Authority.undefined(), this._path.unmerge(absolute._path), absolute._query, absolute._fragment);
            }
        };
        Uri.prototype.copy = function (scheme, authority, path, query, fragment) {
            return Uri.from(scheme, authority, path, query, fragment);
        };
        Uri.prototype.toAny = function () {
            var uri = {};
            uri.scheme = this._scheme.toAny();
            this._authority.toAny(uri);
            uri.path = this._path.toAny();
            uri.query = this._query.toAny();
            uri.fragment = this._fragment.toAny();
            return uri;
        };
        Uri.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        Uri.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Uri) {
                return this.toString() === that.toString();
            }
            return false;
        };
        Uri.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this.toString());
            }
            return this._hashCode;
        };
        Uri.prototype.debug = function (output) {
            output = output.write("Uri").write(46);
            if (this.isDefined()) {
                output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
            }
            else {
                output = output.write("empty").write(40).write(41);
            }
        };
        Uri.prototype.display = function (output) {
            if (this._string != null) {
                output = output.write(this._string);
            }
            else {
                if (this._scheme.isDefined()) {
                    output.display(this._scheme).write(58);
                }
                if (this._authority.isDefined()) {
                    output = output.write(47).write(47).display(this._authority);
                }
                output.display(this._path);
                if (this._query.isDefined()) {
                    output = output.write(63).display(this._query);
                }
                if (this._fragment.isDefined()) {
                    output = output.write(35).display(this._fragment);
                }
            }
        };
        Uri.prototype.toString = function () {
            if (this._string === void 0) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        Uri.empty = function () {
            if (Uri._empty === void 0) {
                Uri._empty = new Uri(Uri.Scheme.undefined(), Uri.Authority.undefined(), Uri.Path.empty(), Uri.Query.undefined(), Uri.Fragment.undefined());
            }
            return Uri._empty;
        };
        Uri.from = function (scheme, authority, path, query, fragment) {
            if (scheme === void 0) { scheme = Uri.Scheme.undefined(); }
            if (authority === void 0) { authority = Uri.Authority.undefined(); }
            if (path === void 0) { path = Uri.Path.empty(); }
            if (query === void 0) { query = Uri.Query.undefined(); }
            if (fragment === void 0) { fragment = Uri.Fragment.undefined(); }
            if (scheme.isDefined() || authority.isDefined() || path.isDefined()
                || query.isDefined() || fragment.isDefined()) {
                return new Uri(scheme, authority, path, query, fragment);
            }
            else {
                return Uri.empty();
            }
        };
        Uri.fromAny = function (uri) {
            if (uri === null || uri === void 0) {
                return Uri.empty();
            }
            else if (uri instanceof Uri) {
                return uri;
            }
            else if (typeof uri === "object") {
                var scheme = Uri.Scheme.fromAny(uri.scheme);
                var authority = Uri.Authority.fromAny(uri.authority || uri);
                var path = Uri.Path.fromAny(uri.path);
                var query = Uri.Query.fromAny(uri.query);
                var fragment = Uri.Fragment.fromAny(uri.fragment);
                if (scheme.isDefined() || authority.isDefined() || path.isDefined()
                    || query.isDefined() || fragment.isDefined()) {
                    return new Uri(scheme, authority, path, query, fragment);
                }
                else {
                    return Uri.empty();
                }
            }
            else if (typeof uri === "string") {
                return Uri.parse(uri);
            }
            else {
                throw new TypeError("" + uri);
            }
        };
        Uri.scheme = function (scheme) {
            scheme = Uri.Scheme.fromAny(scheme);
            return Uri.from(scheme, void 0, void 0, void 0, void 0);
        };
        Uri.schemePart = function (part) {
            var scheme = Uri.Scheme.parse(part);
            return Uri.from(scheme, void 0, void 0, void 0, void 0);
        };
        Uri.schemeName = function (name) {
            var scheme = Uri.Scheme.from(name);
            return Uri.from(scheme, void 0, void 0, void 0, void 0);
        };
        Uri.authority = function (authority) {
            authority = Uri.Authority.fromAny(authority);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.authorityPart = function (part) {
            var authority = Uri.Authority.parse(part);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.user = function (user) {
            var authority = Uri.Authority.user(user);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.userPart = function (part) {
            var authority = Uri.Authority.userPart(part);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.username = function (username, password) {
            var authority = Uri.Authority.username(username, password);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.password = function (password) {
            var authority = Uri.Authority.password(password);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.host = function (host) {
            var authority = Uri.Authority.host(host);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.hostPart = function (part) {
            var authority = Uri.Authority.hostPart(part);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.hostName = function (address) {
            var authority = Uri.Authority.hostName(address);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.hostIPv4 = function (address) {
            var authority = Uri.Authority.hostIPv4(address);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.hostIPv6 = function (address) {
            var authority = Uri.Authority.hostIPv6(address);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.port = function (port) {
            var authority = Uri.Authority.port(port);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.portPart = function (part) {
            var authority = Uri.Authority.portPart(part);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.portNumber = function (number) {
            var authority = Uri.Authority.portNumber(number);
            return Uri.from(void 0, authority, void 0, void 0, void 0);
        };
        Uri.path = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            var path = Uri.Path.from.apply(void 0, components);
            return Uri.from(void 0, void 0, path, void 0, void 0);
        };
        Uri.pathPart = function (part) {
            var path = Uri.Path.parse(part);
            return Uri.from(void 0, void 0, path, void 0, void 0);
        };
        Uri.query = function (query) {
            query = Uri.Query.fromAny(query);
            return Uri.from(void 0, void 0, void 0, query, void 0);
        };
        Uri.queryPart = function (part) {
            var query = Uri.Query.parse(part);
            return Uri.from(void 0, void 0, void 0, query, void 0);
        };
        Uri.fragment = function (fragment) {
            fragment = Uri.Fragment.fromAny(fragment);
            return Uri.from(void 0, void 0, void 0, void 0, fragment);
        };
        Uri.fragmentPart = function (part) {
            var fragment = Uri.Fragment.parse(part);
            return Uri.from(void 0, void 0, void 0, void 0, fragment);
        };
        Uri.fragmentIdentifier = function (identifier) {
            var fragment = Uri.Fragment.from(identifier);
            return Uri.from(void 0, void 0, void 0, void 0, fragment);
        };
        Uri.standardParser = function () {
            if (!this._standardParser) {
                this._standardParser = new Uri.Parser();
            }
            return this._standardParser;
        };
        Uri.parse = function (string) {
            return Uri.standardParser().parseAbsoluteString(string);
        };
        Uri.isUnreservedChar = function (c) {
            return c >= 65 && c <= 90
                || c >= 97 && c <= 122
                || c >= 48 && c <= 57
                || c === 45 || c === 46
                || c === 95 || c === 126;
        };
        Uri.isSubDelimChar = function (c) {
            return c === 33 || c === 36
                || c === 38 || c === 40
                || c === 41 || c === 42
                || c === 43 || c === 44
                || c === 59 || c === 61
                || c === 39;
        };
        Uri.isSchemeChar = function (c) {
            return c >= 65 && c <= 90
                || c >= 97 && c <= 122
                || c >= 48 && c <= 57
                || c === 43 || c === 45
                || c === 46;
        };
        Uri.isUserInfoChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c)
                || c === 58;
        };
        Uri.isUserChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c);
        };
        Uri.isHostChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c);
        };
        Uri.isPathChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c)
                || c === 58 || c === 64;
        };
        Uri.isQueryChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c)
                || c === 47 || c === 58
                || c === 63 || c === 64;
        };
        Uri.isParamChar = function (c) {
            return Uri.isUnreservedChar(c)
                || c === 33 || c === 36
                || c === 40 || c === 41
                || c === 42 || c === 43
                || c === 44 || c === 47
                || c === 58 || c === 59
                || c === 63 || c === 64
                || c === 39;
        };
        Uri.isFragmentChar = function (c) {
            return Uri.isUnreservedChar(c)
                || Uri.isSubDelimChar(c)
                || c === 47 || c === 58
                || c === 63 || c === 64;
        };
        Uri.isAlpha = function (c) {
            return c >= 65 && c <= 90
                || c >= 97 && c <= 122;
        };
        Uri.toLowerCase = function (c) {
            if (c >= 65 && c <= 90) {
                return c + (97 - 65);
            }
            else {
                return c;
            }
        };
        Uri.writeScheme = function (scheme, output) {
            for (var i = 0, n = scheme.length; i < n; i += 1) {
                var c = scheme.charCodeAt(i);
                if (i > 0 && Uri.isSchemeChar(c) || i === 0 && Uri.isAlpha(c)) {
                    output = output.write(c);
                }
                else {
                    throw new UriException("Invalid scheme: " + scheme);
                }
            }
        };
        Uri.writeUserInfo = function (userInfo, output) {
            for (var i = 0, n = userInfo.length; i < n; i += 1) {
                var c = userInfo.charCodeAt(i);
                if (Uri.isUserInfoChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeUser = function (user, output) {
            for (var i = 0, n = user.length; i < n; i += 1) {
                var c = user.charCodeAt(i);
                if (Uri.isUserChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeHost = function (address, output) {
            for (var i = 0, n = address.length; i < n; i += 1) {
                var c = address.charCodeAt(i);
                if (Uri.isHostChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeHostLiteral = function (address, output) {
            for (var i = 0, n = address.length; i < n; i += 1) {
                var c = address.charCodeAt(i);
                if (Uri.isHostChar(c) || c === 58) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writePathSegment = function (segment, output) {
            for (var i = 0, n = segment.length; i < n; i += 1) {
                var c = segment.charCodeAt(i);
                if (Uri.isPathChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeQuery = function (query, output) {
            for (var i = 0, n = query.length; i < n; i += 1) {
                var c = query.charCodeAt(i);
                if (Uri.isQueryChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeParam = function (param, output) {
            for (var i = 0, n = param.length; i < n; i += 1) {
                var c = param.charCodeAt(i);
                if (Uri.isParamChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeFragment = function (fragment, output) {
            for (var i = 0, n = fragment.length; i < n; i += 1) {
                var c = fragment.charCodeAt(i);
                if (Uri.isFragmentChar(c)) {
                    output = output.write(c);
                }
                else {
                    Uri.writeEncoded(c, output);
                }
            }
        };
        Uri.writeEncoded = function (c, output) {
            if (c === 0x00) {
                Uri.writePctEncoded(0xC0, output);
                Uri.writePctEncoded(0x80, output);
            }
            else if (c >= 0x00 && c <= 0x7F) {
                Uri.writePctEncoded(c, output);
            }
            else if (c >= 0x80 && c <= 0x07FF) {
                Uri.writePctEncoded(0xC0 | (c >>> 6), output);
                Uri.writePctEncoded(0x80 | (c & 0x3F), output);
            }
            else if (c >= 0x0800 && c <= 0xFFFF
                || c >= 0xE000 && c <= 0xFFFF) {
                Uri.writePctEncoded(0xE0 | (c >>> 12), output);
                Uri.writePctEncoded(0x80 | (c >>> 6 & 0x3F), output);
                Uri.writePctEncoded(0x80 | (c & 0x3F), output);
            }
            else if (c >= 0x10000 && c <= 0x10FFFF) {
                Uri.writePctEncoded(0xF0 | (c >>> 18), output);
                Uri.writePctEncoded(0x80 | (c >>> 12 & 0x3F), output);
                Uri.writePctEncoded(0x80 | (c >>> 6 & 0x3F), output);
                Uri.writePctEncoded(0x80 | (c & 0x3F), output);
            }
            else {
                Uri.writePctEncoded(0xEF, output);
                Uri.writePctEncoded(0xBF, output);
                Uri.writePctEncoded(0xBD, output);
            }
        };
        Uri.writePctEncoded = function (c, output) {
            output = output.write(37)
                .write(Base16.lowercase().encodeDigit(c >>> 4 & 0xF))
                .write(Base16.lowercase().encodeDigit(c & 0xF));
        };
        Uri.form = function () {
            if (!Uri._form) {
                Uri._form = new Uri.Form(Uri.empty());
            }
            return Uri._form;
        };
        return Uri;
    }());

    var UriScheme = (function () {
        function UriScheme(name) {
            this._name = name;
        }
        UriScheme.prototype.isDefined = function () {
            return this._name.length !== 0;
        };
        UriScheme.prototype.name = function () {
            return this._name;
        };
        UriScheme.prototype.toAny = function () {
            return this._name.length !== 0 ? this._name : void 0;
        };
        UriScheme.prototype.compareTo = function (that) {
            var order = this._name.localeCompare(that._name);
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriScheme.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriScheme) {
                return this._name === that._name;
            }
            return false;
        };
        UriScheme.prototype.hashCode = function () {
            return Murmur3.hash(this._name);
        };
        UriScheme.prototype.debug = function (output) {
            output = output.write("UriScheme").write(46);
            if (this.isDefined()) {
                output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
            }
            else {
                output = output.write("undefined").write(40).write(41);
            }
        };
        UriScheme.prototype.display = function (output) {
            Uri.writeScheme(this._name, output);
        };
        UriScheme.prototype.toString = function () {
            return this._name;
        };
        UriScheme.undefined = function () {
            if (UriScheme._undefined === void 0) {
                UriScheme._undefined = new UriScheme("");
            }
            return UriScheme._undefined;
        };
        UriScheme.from = function (name) {
            var cache = UriScheme.cache();
            var scheme = cache.get(name);
            if (scheme) {
                return scheme;
            }
            else {
                return cache.put(name, new UriScheme(name));
            }
        };
        UriScheme.fromAny = function (scheme) {
            if (scheme === null || scheme === void 0) {
                return UriScheme.undefined();
            }
            else if (scheme instanceof UriScheme) {
                return scheme;
            }
            else if (typeof scheme === "string") {
                return UriScheme.parse(scheme);
            }
            else {
                throw new TypeError("" + scheme);
            }
        };
        UriScheme.parse = function (string) {
            return Uri.standardParser().parseSchemeString(string);
        };
        UriScheme.cache = function () {
            if (UriScheme._cache === void 0) {
                var cacheSize = 4;
                UriScheme._cache = new HashGenCacheMap(cacheSize);
            }
            return UriScheme._cache;
        };
        return UriScheme;
    }());
    Uri.Scheme = UriScheme;

    var UriAuthority = (function () {
        function UriAuthority(user, host, port) {
            this._user = user;
            this._host = host;
            this._port = port;
        }
        UriAuthority.prototype.isDefined = function () {
            return this._user.isDefined() || this._host.isDefined() || this._port.isDefined();
        };
        UriAuthority.prototype.user = function (user) {
            if (user === void 0) {
                return this._user;
            }
            else {
                user = Uri.User.fromAny(user);
                if (user !== this._user) {
                    return this.copy(user, this._host, this._port);
                }
                else {
                    return this;
                }
            }
        };
        UriAuthority.prototype.userPart = function (user) {
            if (user === void 0) {
                return this._user.toString();
            }
            else {
                return this.user(Uri.User.parse(user));
            }
        };
        UriAuthority.prototype.username = function (username, password) {
            if (username === void 0) {
                return this._user._username || "";
            }
            else if (password === void 0) {
                return this.user(this._user.username(username));
            }
            else {
                return this.user(Uri.User.from(username, password));
            }
        };
        UriAuthority.prototype.password = function (password) {
            if (password === void 0) {
                return this._user.password();
            }
            else {
                return this.user(this._user.password(password));
            }
        };
        UriAuthority.prototype.host = function (host) {
            if (host === void 0) {
                return this._host;
            }
            else {
                host = Uri.Host.fromAny(host);
                if (host !== this._host) {
                    return this.copy(this._user, host, this._port);
                }
                else {
                    return this;
                }
            }
        };
        UriAuthority.prototype.hostPart = function (host) {
            if (host === void 0) {
                return this._host.toString();
            }
            else {
                return this.host(Uri.Host.parse(host));
            }
        };
        UriAuthority.prototype.hostAddress = function () {
            return this._host.address();
        };
        UriAuthority.prototype.hostName = function (address) {
            if (address === void 0) {
                return this._host.name();
            }
            else {
                return this.host(Uri.Host.from(address));
            }
        };
        UriAuthority.prototype.hostIPv4 = function (address) {
            if (address === void 0) {
                return this._host.ipv4();
            }
            else {
                return this.host(Uri.Host.ipv4(address));
            }
        };
        UriAuthority.prototype.hostIPv6 = function (address) {
            if (address === void 0) {
                return this._host.ipv6();
            }
            else {
                return this.host(Uri.Host.ipv6(address));
            }
        };
        UriAuthority.prototype.port = function (port) {
            if (port === void 0) {
                return this._port;
            }
            else {
                port = Uri.Port.fromAny(port);
                if (port !== this._port) {
                    return this.copy(this._user, this._host, port);
                }
                else {
                    return this;
                }
            }
        };
        UriAuthority.prototype.portPart = function (port) {
            if (port === void 0) {
                return this._port.toString();
            }
            else {
                return this.port(Uri.Port.parse(port));
            }
        };
        UriAuthority.prototype.portNumber = function (port) {
            if (port === void 0) {
                return this._port.number();
            }
            else {
                return this.port(Uri.Port.from(port));
            }
        };
        UriAuthority.prototype.copy = function (user, host, port) {
            return UriAuthority.from(user, host, port);
        };
        UriAuthority.prototype.toAny = function (authority) {
            if (this.isDefined()) {
                authority = authority || {};
                this._user.toAny(authority);
                if (this._host.isDefined()) {
                    authority.host = this._host.toAny();
                }
                if (this._port.isDefined()) {
                    authority.port = this._port.toAny();
                }
            }
            return authority;
        };
        UriAuthority.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriAuthority.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriAuthority) {
                return this.toString() === that.toString();
            }
            return false;
        };
        UriAuthority.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this.toString());
            }
            return this._hashCode;
        };
        UriAuthority.prototype.debug = function (output) {
            output = output.write("UriAuthority").write(46);
            if (this.isDefined()) {
                output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
            }
            else {
                output = output.write("undefined").write(40).write(41);
            }
        };
        UriAuthority.prototype.display = function (output) {
            if (this._string !== void 0) {
                output = output.write(this._string);
            }
            else {
                if (this._user.isDefined()) {
                    output.display(this._user).write(64);
                }
                output.display(this._host);
                if (this._port.isDefined()) {
                    output = output.write(58).display(this._port);
                }
            }
        };
        UriAuthority.prototype.toString = function () {
            if (this._string === void 0) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        UriAuthority.undefined = function () {
            if (UriAuthority._undefined === void 0) {
                UriAuthority._undefined = new UriAuthority(Uri.User.undefined(), Uri.Host.undefined(), Uri.Port.undefined());
            }
            return UriAuthority._undefined;
        };
        UriAuthority.from = function (user, host, port) {
            if (user === void 0) { user = Uri.User.undefined(); }
            if (host === void 0) { host = Uri.Host.undefined(); }
            if (port === void 0) { port = Uri.Port.undefined(); }
            if (user.isDefined() || host.isDefined() || port.isDefined()) {
                return new UriAuthority(user, host, port);
            }
            else {
                return UriAuthority.undefined();
            }
        };
        UriAuthority.fromAny = function (authority) {
            if (authority === null || authority === void 0) {
                return UriAuthority.undefined();
            }
            else if (authority instanceof UriAuthority) {
                return authority;
            }
            else if (typeof authority === "object") {
                var user = Uri.User.fromAny(authority.user || authority);
                var host = Uri.Host.fromAny(authority.host);
                var port = Uri.Port.fromAny(authority.port);
                return UriAuthority.from(user, host, port);
            }
            else if (typeof authority === "string") {
                return UriAuthority.parse(authority);
            }
            else {
                throw new TypeError("" + authority);
            }
        };
        UriAuthority.user = function (user) {
            user = Uri.User.fromAny(user);
            return UriAuthority.from(user, void 0, void 0);
        };
        UriAuthority.userPart = function (part) {
            var user = Uri.User.parse(part);
            return UriAuthority.from(user, void 0, void 0);
        };
        UriAuthority.username = function (username, password) {
            var user = Uri.User.from(username, password);
            return UriAuthority.from(user, void 0, void 0);
        };
        UriAuthority.password = function (password) {
            var user = Uri.User.from("", password);
            return UriAuthority.from(user, void 0, void 0);
        };
        UriAuthority.host = function (host) {
            host = Uri.Host.fromAny(host);
            return UriAuthority.from(void 0, host, void 0);
        };
        UriAuthority.hostPart = function (part) {
            var host = Uri.Host.parse(part);
            return UriAuthority.from(void 0, host, void 0);
        };
        UriAuthority.hostName = function (address) {
            var host = Uri.Host.from(address);
            return UriAuthority.from(void 0, host, void 0);
        };
        UriAuthority.hostIPv4 = function (address) {
            var host = Uri.Host.ipv4(address);
            return UriAuthority.from(void 0, host, void 0);
        };
        UriAuthority.hostIPv6 = function (address) {
            var host = Uri.Host.ipv6(address);
            return UriAuthority.from(void 0, host, void 0);
        };
        UriAuthority.port = function (port) {
            port = Uri.Port.fromAny(port);
            return UriAuthority.from(void 0, void 0, port);
        };
        UriAuthority.portPart = function (part) {
            var port = Uri.Port.parse(part);
            return UriAuthority.from(void 0, void 0, port);
        };
        UriAuthority.portNumber = function (number) {
            var port = Uri.Port.from(number);
            return UriAuthority.from(void 0, void 0, port);
        };
        UriAuthority.parse = function (string) {
            return Uri.standardParser().parseAuthorityString(string);
        };
        return UriAuthority;
    }());
    Uri.Authority = UriAuthority;

    var UriUser = (function () {
        function UriUser(username, password) {
            this._username = username;
            this._password = password;
        }
        UriUser.prototype.isDefined = function () {
            return this._username !== null;
        };
        UriUser.prototype.username = function (username) {
            if (username === void 0) {
                return this._username || "";
            }
            else {
                if (username !== this._username) {
                    return this.copy(username, this._password);
                }
                else {
                    return this;
                }
            }
        };
        UriUser.prototype.password = function (password) {
            if (password === void 0) {
                return this._password;
            }
            else {
                if (password !== this._password) {
                    return this.copy(this._username, password);
                }
                else {
                    return this;
                }
            }
        };
        UriUser.prototype.copy = function (username, password) {
            return UriUser.from(username, password);
        };
        UriUser.prototype.toAny = function (user) {
            if (this._username !== null) {
                user = user || {};
                user.username = this._username;
                if (this._password !== null) {
                    user.password = this._password;
                }
            }
            return user;
        };
        UriUser.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriUser) {
                return this._username === that._username && this._password === that._password;
            }
            return false;
        };
        UriUser.prototype.hashCode = function () {
            if (UriUser._hashSeed === void 0) {
                UriUser._hashSeed = Murmur3.seed(UriUser);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(UriUser._hashSeed, Murmur3.hash(this._username)), Murmur3.hash(this._password)));
        };
        UriUser.prototype.debug = function (output) {
            output = output.write("UriUser").write(46);
            if (this.isDefined()) {
                output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
            }
            else {
                output = output.write("undefined").write(40).write(41);
            }
        };
        UriUser.prototype.display = function (output) {
            if (this._username != null) {
                Uri.writeUser(this._username, output);
                if (this._password != null) {
                    output = output.write(58);
                    Uri.writeUser(this._password, output);
                }
            }
        };
        UriUser.prototype.toString = function () {
            return Format.display(this);
        };
        UriUser.undefined = function () {
            if (UriUser._undefined === void 0) {
                UriUser._undefined = new UriUser(null, null);
            }
            return UriUser._undefined;
        };
        UriUser.from = function (username, password) {
            if (password === void 0) { password = null; }
            if (username !== null || password !== null) {
                return new UriUser(username || "", password);
            }
            else {
                return UriUser.undefined();
            }
        };
        UriUser.fromAny = function (user) {
            if (user === null || user === void 0) {
                return UriUser.undefined();
            }
            else if (user instanceof UriUser) {
                return user;
            }
            else if (typeof user === "object") {
                var username = typeof user.username === "string" ? user.username : null;
                var password = typeof user.password === "string" ? user.password : null;
                return UriUser.from(username, password);
            }
            else if (typeof user === "string") {
                return UriUser.parse(user);
            }
            else {
                throw new TypeError("" + user);
            }
        };
        UriUser.parse = function (string) {
            return Uri.standardParser().parseUserString(string);
        };
        return UriUser;
    }());
    Uri.User = UriUser;

    var UriHost = (function () {
        function UriHost() {
        }
        UriHost.prototype.isDefined = function () {
            return true;
        };
        UriHost.prototype.name = function () {
            return null;
        };
        UriHost.prototype.ipv4 = function () {
            return null;
        };
        UriHost.prototype.ipv6 = function () {
            return null;
        };
        UriHost.prototype.toAny = function () {
            return this.toString();
        };
        UriHost.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriHost.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriHost) {
                return this.toString() === that.toString();
            }
            return false;
        };
        UriHost.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this.toString());
            }
            return this._hashCode;
        };
        UriHost.undefined = function () {
            if (UriHost._undefined === void 0) {
                UriHost._undefined = new Uri.HostUndefined();
            }
            return UriHost._undefined;
        };
        UriHost.from = function (address) {
            var cache = UriHost.cache();
            var host = cache.get(address);
            if (host instanceof Uri.HostName) {
                return host;
            }
            else {
                return cache.put(address, new Uri.HostName(address));
            }
        };
        UriHost.ipv4 = function (address) {
            var cache = UriHost.cache();
            var host = cache.get(address);
            if (host instanceof Uri.HostIPv4) {
                return host;
            }
            else {
                return cache.put(address, new Uri.HostIPv4(address));
            }
        };
        UriHost.ipv6 = function (address) {
            var cache = UriHost.cache();
            var host = cache.get(address);
            if (host instanceof Uri.HostIPv6) {
                return host;
            }
            else {
                return cache.put(address, new Uri.HostIPv6(address));
            }
        };
        UriHost.fromAny = function (host) {
            if (host === null || host === void 0) {
                return UriHost.undefined();
            }
            else if (host instanceof UriHost) {
                return host;
            }
            else if (typeof host === "string") {
                return UriHost.parse(host);
            }
            else {
                throw new TypeError("" + host);
            }
        };
        UriHost.parse = function (string) {
            return Uri.standardParser().parseHostString(string);
        };
        UriHost.cache = function () {
            if (UriHost._cache === void 0) {
                var cacheSize = 16;
                UriHost._cache = new HashGenCacheMap(cacheSize);
            }
            return UriHost._cache;
        };
        return UriHost;
    }());
    Uri.Host = UriHost;

    var UriHostName = (function (_super) {
        __extends(UriHostName, _super);
        function UriHostName(address) {
            var _this = _super.call(this) || this;
            _this._address = address;
            return _this;
        }
        UriHostName.prototype.address = function () {
            return this._address;
        };
        UriHostName.prototype.name = function () {
            return this._address;
        };
        UriHostName.prototype.debug = function (output) {
            output = output.write("UriHost").write(46).write("from")
                .write(40).debug(this._address).write(41);
        };
        UriHostName.prototype.display = function (output) {
            Uri.writeHost(this._address, output);
        };
        UriHostName.prototype.toString = function () {
            return this._address;
        };
        return UriHostName;
    }(UriHost));
    Uri.HostName = UriHostName;

    var UriHostIPv4 = (function (_super) {
        __extends(UriHostIPv4, _super);
        function UriHostIPv4(address) {
            var _this = _super.call(this) || this;
            _this._address = address;
            return _this;
        }
        UriHostIPv4.prototype.address = function () {
            return this._address;
        };
        UriHostIPv4.prototype.ipv4 = function () {
            return this._address;
        };
        UriHostIPv4.prototype.debug = function (output) {
            output = output.write("UriHost").write(46).write("ipv4")
                .write(40).debug(this._address).write(41);
        };
        UriHostIPv4.prototype.display = function (output) {
            Uri.writeHost(this._address, output);
        };
        UriHostIPv4.prototype.toString = function () {
            return this._address;
        };
        return UriHostIPv4;
    }(UriHost));
    Uri.HostIPv4 = UriHostIPv4;

    var UriHostIPv6 = (function (_super) {
        __extends(UriHostIPv6, _super);
        function UriHostIPv6(address) {
            var _this = _super.call(this) || this;
            _this._address = address;
            return _this;
        }
        UriHostIPv6.prototype.address = function () {
            return this._address;
        };
        UriHostIPv6.prototype.ipv6 = function () {
            return this._address;
        };
        UriHostIPv6.prototype.debug = function (output) {
            output = output.write("UriHost").write(46).write("ipv6")
                .write(40).debug(this._address).write(41);
        };
        UriHostIPv6.prototype.display = function (output) {
            if (this._string != null) {
                output = output.write(this._string);
            }
            else {
                output = output.write(91);
                Uri.writeHostLiteral(this._address, output);
                output = output.write(93);
            }
        };
        UriHostIPv6.prototype.toString = function () {
            if (this._string == null) {
                this._string = "[" + this.address + "]";
            }
            return this._string;
        };
        return UriHostIPv6;
    }(UriHost));
    Uri.HostIPv6 = UriHostIPv6;

    var UriHostUndefined = (function (_super) {
        __extends(UriHostUndefined, _super);
        function UriHostUndefined() {
            return _super.call(this) || this;
        }
        UriHostUndefined.prototype.isDefined = function () {
            return false;
        };
        UriHostUndefined.prototype.address = function () {
            return "";
        };
        UriHostUndefined.prototype.debug = function (output) {
            output = output.write("UriHost").write(46).write("undefined")
                .write(40).write(41);
        };
        UriHostUndefined.prototype.display = function (output) {
        };
        UriHostUndefined.prototype.toString = function () {
            return "";
        };
        return UriHostUndefined;
    }(UriHost));
    Uri.HostUndefined = UriHostUndefined;

    var UriPort = (function () {
        function UriPort(num) {
            this._number = num;
        }
        UriPort.prototype.isDefined = function () {
            return this._number !== 0;
        };
        UriPort.prototype.number = function () {
            return this._number;
        };
        UriPort.prototype.valueOf = function () {
            return this._number;
        };
        UriPort.prototype.toAny = function () {
            return this._number;
        };
        UriPort.prototype.compareTo = function (that) {
            return this._number < that._number ? -1 : this._number > that._number ? 1 : 0;
        };
        UriPort.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriPort) {
                return this._number === that._number;
            }
            return false;
        };
        UriPort.prototype.hashCode = function () {
            if (UriPort._hashSeed === void 0) {
                UriPort._hashSeed = Murmur3.seed(UriPort);
            }
            return Murmur3.mash(Murmur3.mix(UriPort._hashSeed, this._number));
        };
        UriPort.prototype.debug = function (output) {
            output = output.write("UriPort").write(46);
            if (this.isDefined()) {
                output = output.write("from").write(40);
                Format.displayNumber(this._number, output);
                output = output.write(41);
            }
            else {
                output = output.write("undefined").write(40).write(41);
            }
        };
        UriPort.prototype.display = function (output) {
            Format.displayNumber(this._number, output);
        };
        UriPort.prototype.toString = function () {
            return "" + this._number;
        };
        UriPort.undefined = function () {
            if (UriPort._undefined === void 0) {
                UriPort._undefined = new UriPort(0);
            }
            return UriPort._undefined;
        };
        UriPort.from = function (number) {
            if (number > 0) {
                var cache = UriPort.cache();
                var port = cache.get(number);
                if (port !== void 0) {
                    return port;
                }
                else {
                    return cache.put(number, new UriPort(number));
                }
            }
            else if (number === 0) {
                return UriPort.undefined();
            }
            else {
                throw new TypeError("" + number);
            }
        };
        UriPort.fromAny = function (port) {
            if (port === null || port === void 0) {
                return UriPort.undefined();
            }
            else if (port instanceof UriPort) {
                return port;
            }
            else if (typeof port === "number") {
                return UriPort.from(port);
            }
            else if (typeof port === "string") {
                return UriPort.parse(port);
            }
            else {
                throw new TypeError("" + port);
            }
        };
        UriPort.parse = function (string) {
            return Uri.standardParser().parsePortString(string);
        };
        UriPort.cache = function () {
            if (UriPort._cache === void 0) {
                var cacheSize = 4;
                UriPort._cache = new HashGenCacheMap(cacheSize);
            }
            return UriPort._cache;
        };
        return UriPort;
    }());
    Uri.Port = UriPort;

    var UriPath = (function () {
        function UriPath() {
        }
        Object.defineProperty(UriPath.prototype, "length", {
            get: function () {
                var n = 0;
                var path = this;
                while (!path.isEmpty()) {
                    n += 1;
                    path = path.tail();
                }
                return n;
            },
            enumerable: true,
            configurable: true
        });
        UriPath.prototype.get = function (index) {
            var i = 0;
            var path = this;
            while (!path.isEmpty()) {
                if (i < index) {
                    i += 1;
                    path = path.tail();
                }
                else {
                    return path.head();
                }
            }
            return void 0;
        };
        UriPath.prototype.name = function (name) {
            if (name === void 0) {
                if (this.isEmpty()) {
                    return "";
                }
                var path = this;
                do {
                    var tail = path.tail();
                    if (tail.isEmpty()) {
                        return path.isRelative() ? path.head() : "";
                    }
                    else {
                        path = tail;
                    }
                } while (true);
            }
            else {
                var builder = new Uri.PathBuilder();
                builder.addPath(this.base());
                builder.addSegment(name);
                return builder.bind();
            }
        };
        UriPath.prototype.foot = function () {
            if (this.isEmpty()) {
                return this;
            }
            var path = this;
            do {
                var tail = path.tail();
                if (tail.isEmpty()) {
                    return path;
                }
                else {
                    path = tail;
                }
            } while (true);
        };
        UriPath.prototype.isSubpathOf = function (b) {
            b = UriPath.fromAny(b);
            var a = this;
            while (!a.isEmpty() && !b.isEmpty()) {
                if (a.head() !== b.head()) {
                    return false;
                }
                a = a.tail();
                b = b.tail();
            }
            return b.isEmpty();
        };
        UriPath.prototype.appended = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (arguments.length > 0) {
                var builder = new Uri.PathBuilder();
                builder.addPath(this);
                builder.push.apply(builder, arguments);
                return builder.bind();
            }
            else {
                return this;
            }
        };
        UriPath.prototype.appendedSlash = function () {
            var builder = new Uri.PathBuilder();
            builder.addPath(this);
            builder.addSlash();
            return builder.bind();
        };
        UriPath.prototype.appendedSegment = function (segment) {
            var builder = new Uri.PathBuilder();
            builder.addPath(this);
            builder.addSegment(segment);
            return builder.bind();
        };
        UriPath.prototype.prepended = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            if (arguments.length > 0) {
                var builder = new Uri.PathBuilder();
                builder.push.apply(builder, arguments);
                builder.addPath(this);
                return builder.bind();
            }
            else {
                return this;
            }
        };
        UriPath.prototype.prependedSlash = function () {
            return UriPath.slash(this);
        };
        UriPath.prototype.prependedSegment = function (segment) {
            if (this.isEmpty() || this.isAbsolute()) {
                return UriPath.segment(segment, this);
            }
            else {
                return UriPath.segment(segment, UriPath.slash(this));
            }
        };
        UriPath.prototype.resolve = function (that) {
            if (that.isEmpty()) {
                return this;
            }
            else if (that.isAbsolute() || this.isEmpty()) {
                return that.removeDotSegments();
            }
            else {
                return this.merge(that).removeDotSegments();
            }
        };
        UriPath.prototype.removeDotSegments = function () {
            var path = this;
            var builder = new Uri.PathBuilder();
            while (!path.isEmpty()) {
                var head = path.head();
                if (head === "." || head === "..") {
                    path = path.tail();
                    if (!path.isEmpty()) {
                        path = path.tail();
                    }
                }
                else if (path.isAbsolute()) {
                    var rest = path.tail();
                    if (!rest.isEmpty()) {
                        var next = rest.head();
                        if (next === ".") {
                            path = rest.tail();
                            if (path.isEmpty()) {
                                path = UriPath.slash();
                            }
                        }
                        else if (next === "..") {
                            path = rest.tail();
                            if (path.isEmpty()) {
                                path = UriPath.slash();
                            }
                            if (!builder.isEmpty() && !builder.pop().isAbsolute()) {
                                if (!builder.isEmpty()) {
                                    builder.pop();
                                }
                            }
                        }
                        else {
                            builder.push(head, next);
                            path = rest.tail();
                        }
                    }
                    else {
                        builder.push(path.head());
                        path = path.tail();
                    }
                }
                else {
                    builder.push(path.head());
                    path = path.tail();
                }
            }
            return builder.bind();
        };
        UriPath.prototype.merge = function (that) {
            if (!this.isEmpty()) {
                var builder = new Uri.PathBuilder();
                var prev = this;
                do {
                    var next = prev.tail();
                    if (!next.isEmpty()) {
                        if (prev.isAbsolute()) {
                            builder.addSlash();
                        }
                        else {
                            builder.addSegment(prev.head());
                        }
                        prev = next;
                    }
                    else {
                        if (prev.isAbsolute()) {
                            builder.addSlash();
                        }
                        break;
                    }
                } while (true);
                builder.addPath(that);
                return builder.bind();
            }
            else {
                return that;
            }
        };
        UriPath.prototype.unmerge = function (relative, root) {
            if (root === void 0) { root = relative; }
            var base = this;
            do {
                if (base.isEmpty()) {
                    if (!relative.isEmpty() && !relative.tail().isEmpty()) {
                        return relative.tail();
                    }
                    else {
                        return relative;
                    }
                }
                else if (base.isRelative()) {
                    return relative;
                }
                else if (relative.isRelative()) {
                    return UriPath.slash(relative);
                }
                else {
                    var a = base.tail();
                    var b = relative.tail();
                    if (!a.isEmpty() && b.isEmpty()) {
                        return UriPath.slash();
                    }
                    else if (a.isEmpty() || b.isEmpty() || a.head() !== b.head()) {
                        return b;
                    }
                    else {
                        a = a.tail();
                        b = b.tail();
                        if (!a.isEmpty() && b.isEmpty()) {
                            return root;
                        }
                        else {
                            base = a;
                            relative = b;
                        }
                    }
                }
            } while (true);
        };
        UriPath.prototype.toAny = function () {
            var components = [];
            var path = this;
            while (!path.isEmpty()) {
                components.push(path.head());
                path = path.tail();
            }
            return components;
        };
        UriPath.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriPath.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriPath) {
                return this.toString() === that.toString();
            }
            return false;
        };
        UriPath.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this.toString());
            }
            return this._hashCode;
        };
        UriPath.prototype.display = function (output) {
            var path = this;
            while (!path.isEmpty()) {
                if (path.isAbsolute()) {
                    output = output.write(47);
                }
                else {
                    Uri.writePathSegment(path.head(), output);
                }
                path = path.tail();
            }
        };
        UriPath.builder = function () {
            return new Uri.PathBuilder();
        };
        UriPath.empty = function () {
            if (UriPath._empty === void 0) {
                UriPath._empty = new Uri.PathEmpty();
            }
            return UriPath._empty;
        };
        UriPath.slash = function (tail) {
            if (tail === void 0) { tail = UriPath.empty(); }
            if (tail === UriPath.empty()) {
                if (UriPath._slash === void 0) {
                    UriPath._slash = new Uri.PathSlash(tail);
                }
                return UriPath._slash;
            }
            else {
                return new Uri.PathSlash(tail);
            }
        };
        UriPath.segment = function (segment, tail) {
            if (tail === void 0) { tail = UriPath.empty(); }
            segment = this.cacheSegment(segment);
            return new Uri.PathSegment(segment, tail);
        };
        UriPath.from = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            var builder = new Uri.PathBuilder();
            builder.push.apply(builder, arguments);
            return builder.bind();
        };
        UriPath.fromAny = function (path) {
            if (path === null || path === void 0) {
                return UriPath.empty();
            }
            else if (path instanceof UriPath) {
                return path;
            }
            else if (Array.isArray(path)) {
                return UriPath.from.apply(void 0, arguments);
            }
            else if (typeof path === "string") {
                return UriPath.parse(path);
            }
            else {
                throw new TypeError("" + path);
            }
        };
        UriPath.parse = function (string) {
            return Uri.standardParser().parsePathString(string);
        };
        UriPath.segmentCache = function () {
            if (UriPath._segmentCache === void 0) {
                var segmentCacheSize = 64;
                UriPath._segmentCache = new HashGenCacheSet(segmentCacheSize);
            }
            return UriPath._segmentCache;
        };
        UriPath.cacheSegment = function (segment) {
            if (segment.length <= 32) {
                return this.segmentCache().put(segment);
            }
            else {
                return segment;
            }
        };
        UriPath.pathForm = function () {
            if (!UriPath._pathForm) {
                UriPath._pathForm = new Uri.PathForm(UriPath.empty());
            }
            return UriPath._pathForm;
        };
        return UriPath;
    }());
    Uri.Path = UriPath;

    var UriPathSegment = (function (_super) {
        __extends(UriPathSegment, _super);
        function UriPathSegment(head, tail) {
            var _this = _super.call(this) || this;
            _this._head = head;
            _this._tail = tail;
            return _this;
        }
        UriPathSegment.prototype.isDefined = function () {
            return true;
        };
        UriPathSegment.prototype.isAbsolute = function () {
            return false;
        };
        UriPathSegment.prototype.isRelative = function () {
            return true;
        };
        UriPathSegment.prototype.isEmpty = function () {
            return false;
        };
        UriPathSegment.prototype.head = function () {
            return this._head;
        };
        UriPathSegment.prototype.tail = function () {
            return this._tail;
        };
        UriPathSegment.prototype.setTail = function (tail) {
            if (tail.isAbsolute()) {
                this._tail = tail;
            }
            else {
                this._tail = UriPath.slash(tail);
            }
        };
        UriPathSegment.prototype.dealias = function () {
            return new UriPathSegment(this._head, this._tail);
        };
        UriPathSegment.prototype.parent = function () {
            var tail = this._tail;
            if (tail.isEmpty()) {
                return UriPath.empty();
            }
            else {
                var next = tail.tail();
                if (next.isEmpty()) {
                    return UriPath.empty();
                }
                else {
                    return new UriPathSegment(this._head, tail.parent());
                }
            }
        };
        UriPathSegment.prototype.base = function () {
            var tail = this._tail;
            if (tail.isEmpty()) {
                return UriPath.empty();
            }
            else {
                return new UriPathSegment(this._head, tail.base());
            }
        };
        UriPathSegment.prototype.prependedSegment = function (segment) {
            return UriPath.segment(segment, UriPath.slash(this));
        };
        UriPathSegment.prototype.debug = function (output) {
            output = output.write("UriPath").write(46).write("parse")
                .write(40).write(34).display(this).write(34).write(41);
        };
        UriPathSegment.prototype.display = function (output) {
            if (this._string !== void 0) {
                output = output.write(this._string);
            }
            else {
                _super.prototype.display.call(this, output);
            }
        };
        UriPathSegment.prototype.toString = function () {
            if (this._string === void 0) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        return UriPathSegment;
    }(UriPath));
    Uri.PathSegment = UriPathSegment;

    var UriPathSlash = (function (_super) {
        __extends(UriPathSlash, _super);
        function UriPathSlash(tail) {
            var _this = _super.call(this) || this;
            _this._tail = tail;
            return _this;
        }
        UriPathSlash.prototype.isDefined = function () {
            return true;
        };
        UriPathSlash.prototype.isAbsolute = function () {
            return true;
        };
        UriPathSlash.prototype.isRelative = function () {
            return false;
        };
        UriPathSlash.prototype.isEmpty = function () {
            return false;
        };
        UriPathSlash.prototype.head = function () {
            return "/";
        };
        UriPathSlash.prototype.tail = function () {
            return this._tail;
        };
        UriPathSlash.prototype.setTail = function (tail) {
            this._tail = tail;
        };
        UriPathSlash.prototype.dealias = function () {
            return new UriPathSlash(this._tail);
        };
        UriPathSlash.prototype.parent = function () {
            var tail = this._tail;
            if (tail.isEmpty()) {
                return UriPath.empty();
            }
            else {
                var next = tail.tail();
                if (next.isEmpty()) {
                    return UriPath.slash();
                }
                else {
                    return new UriPathSlash(tail.parent());
                }
            }
        };
        UriPathSlash.prototype.base = function () {
            var tail = this._tail;
            if (tail.isEmpty()) {
                return this;
            }
            else {
                return new UriPathSlash(tail.base());
            }
        };
        UriPathSlash.prototype.prependedSegment = function (segment) {
            return UriPath.segment(segment, this);
        };
        UriPathSlash.prototype.debug = function (output) {
            output = output.write("UriPath").write(46).write("parse")
                .write(40).write(34).display(this).write(34).write(41);
        };
        UriPathSlash.prototype.display = function (output) {
            if (this._string !== void 0) {
                output = output.write(this._string);
            }
            else {
                _super.prototype.display.call(this, output);
            }
        };
        UriPathSlash.prototype.toString = function () {
            if (this._string === void 0) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        return UriPathSlash;
    }(UriPath));
    Uri.PathSlash = UriPathSlash;

    var UriPathEmpty = (function (_super) {
        __extends(UriPathEmpty, _super);
        function UriPathEmpty() {
            return _super.call(this) || this;
        }
        UriPathEmpty.prototype.isDefined = function () {
            return false;
        };
        UriPathEmpty.prototype.isAbsolute = function () {
            return false;
        };
        UriPathEmpty.prototype.isRelative = function () {
            return true;
        };
        UriPathEmpty.prototype.isEmpty = function () {
            return true;
        };
        UriPathEmpty.prototype.head = function () {
            throw new Error("Empty UriPath");
        };
        UriPathEmpty.prototype.tail = function () {
            throw new Error("Empty UriPath");
        };
        UriPathEmpty.prototype.setTail = function (tail) {
            throw new Error("Empty UriPath");
        };
        UriPathEmpty.prototype.dealias = function () {
            return this;
        };
        UriPathEmpty.prototype.parent = function () {
            return this;
        };
        UriPathEmpty.prototype.base = function () {
            return this;
        };
        UriPathEmpty.prototype.appended = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            return UriPath.from.apply(void 0, arguments);
        };
        UriPathEmpty.prototype.appendedSlash = function () {
            return UriPath.slash();
        };
        UriPathEmpty.prototype.appendedSegment = function (segment) {
            return UriPath.segment(segment);
        };
        UriPathEmpty.prototype.prepended = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            return UriPath.from.apply(void 0, arguments);
        };
        UriPathEmpty.prototype.prependedSlash = function () {
            return UriPath.slash();
        };
        UriPathEmpty.prototype.prependedSegment = function (segment) {
            return UriPath.segment(segment);
        };
        UriPathEmpty.prototype.merge = function (that) {
            return that;
        };
        UriPathEmpty.prototype.debug = function (output) {
            output = output.write("UriPath").write(46).write("empty")
                .write(40).write(41);
        };
        UriPathEmpty.prototype.display = function (output) {
        };
        UriPathEmpty.prototype.toString = function () {
            return "";
        };
        return UriPathEmpty;
    }(UriPath));
    Uri.PathEmpty = UriPathEmpty;

    var UriPathBuilder = (function () {
        function UriPathBuilder() {
            this._first = Uri.Path.empty();
            this._last = null;
            this._size = 0;
            this._aliased = 0;
        }
        UriPathBuilder.prototype.isEmpty = function () {
            return this._size === 0;
        };
        UriPathBuilder.prototype.push = function () {
            var components = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                components[_i] = arguments[_i];
            }
            for (var i = 0; i < components.length; i += 1) {
                var component = components[i];
                if (component instanceof Uri.Path) {
                    this.addPath(component);
                }
                else if (Array.isArray(component)) {
                    this.push.apply(this, component);
                }
                else if (component === "/") {
                    this.addSlash();
                }
                else {
                    this.addSegment(component);
                }
            }
        };
        UriPathBuilder.prototype.bind = function () {
            this._aliased = 0;
            return this._first;
        };
        UriPathBuilder.prototype.addSlash = function () {
            var tail = Uri.Path.slash().dealias();
            var size = this._size;
            if (size === 0) {
                this._first = tail;
            }
            else {
                this.dealias(size - 1).setTail(tail);
            }
            this._last = tail;
            this._size = size + 1;
            this._aliased += 1;
        };
        UriPathBuilder.prototype.addSegment = function (segment) {
            var tail = Uri.Path.segment(segment, Uri.Path.empty());
            var size = this._size;
            if (size === 0) {
                this._first = tail;
            }
            else {
                this.dealias(size - 1).setTail(tail);
            }
            this._last = tail;
            this._size = size + 1;
            this._aliased += 1;
        };
        UriPathBuilder.prototype.addPath = function (path) {
            if (!path.isEmpty()) {
                var size = this._size;
                if (size === 0) {
                    this._first = path;
                }
                else {
                    this.dealias(size - 1).setTail(path);
                }
                size += 1;
                do {
                    var tail = path.tail();
                    if (!tail.isEmpty()) {
                        path = tail;
                        size += 1;
                    }
                    else {
                        break;
                    }
                } while (true);
                this._last = path;
                this._size = size;
            }
        };
        UriPathBuilder.prototype.pop = function () {
            var size = this._size;
            var aliased = this._aliased;
            if (size === 0) {
                throw new Error("Empty UriPath");
            }
            else if (size === 1) {
                var first = this._first;
                this._first = first.tail();
                if (first.tail().isEmpty()) {
                    this._last = null;
                }
                this._size = size - 1;
                if (aliased > 0) {
                    this._aliased = aliased - 1;
                }
                return first;
            }
            else {
                var last = this.dealias(size - 2);
                last.setTail(Uri.Path.empty());
                this._last = last;
                this._size = size - 1;
                this._aliased = aliased - 1;
                return last.tail();
            }
        };
        UriPathBuilder.prototype.dealias = function (n) {
            var i = 0;
            var xi = null;
            var xs = this._first;
            if (this._aliased <= n) {
                while (i < this._aliased) {
                    xi = xs;
                    xs = xs.tail();
                    i += 1;
                }
                while (i <= n) {
                    var xn = xs.dealias();
                    if (i === 0) {
                        this._first = xn;
                    }
                    else {
                        xi.setTail(xn);
                    }
                    xi = xn;
                    xs = xs.tail();
                    i += 1;
                }
                if (i === this._size) {
                    this._last = xi;
                }
                this._aliased = i;
            }
            else if (n === 0) {
                xi = this._first;
            }
            else if (n === this._size - 1) {
                xi = this._last;
            }
            else {
                while (i <= n) {
                    xi = xs;
                    xs = xs.tail();
                    i += 1;
                }
            }
            return xi;
        };
        return UriPathBuilder;
    }());
    Uri.PathBuilder = UriPathBuilder;

    var UriQuery = (function () {
        function UriQuery() {
        }
        Object.defineProperty(UriQuery.prototype, "length", {
            get: function () {
                var n = 0;
                var query = this;
                while (!query.isEmpty()) {
                    n += 1;
                    query = query.tail();
                }
                return n;
            },
            enumerable: true,
            configurable: true
        });
        UriQuery.prototype.has = function (key) {
            var query = this;
            while (!query.isEmpty()) {
                if (key === query.key()) {
                    return true;
                }
                query = query.tail();
            }
            return false;
        };
        UriQuery.prototype.get = function (key) {
            var query = this;
            while (!query.isEmpty()) {
                if (key === query.key()) {
                    return query.value();
                }
                query = query.tail();
            }
            return void 0;
        };
        UriQuery.prototype.updated = function (key, value) {
            var query = this;
            var builder = new Uri.QueryBuilder();
            var updated = false;
            while (!query.isEmpty()) {
                if (key === query.key()) {
                    builder.addParam(key, value);
                    updated = true;
                }
                else {
                    builder.addParam(query.key(), query.value());
                }
                query = query.tail();
            }
            if (!updated) {
                builder.addParam(key, value);
            }
            return builder.bind();
        };
        UriQuery.prototype.removed = function (key) {
            var query = this;
            var builder = new Uri.QueryBuilder();
            var updated = false;
            while (!query.isEmpty()) {
                if (key === query.key()) {
                    updated = true;
                }
                else {
                    builder.addParam(query.key(), query.value());
                }
                query = query.tail();
            }
            if (updated) {
                return builder.bind();
            }
            else {
                return this;
            }
        };
        UriQuery.prototype.appended = function (key, value) {
            var builder = new Uri.QueryBuilder();
            builder.addQuery(this);
            builder.add(key, value);
            return builder.bind();
        };
        UriQuery.prototype.prepended = function (key, value) {
            var builder = new Uri.QueryBuilder();
            builder.add(key, value);
            builder.addQuery(this);
            return builder.bind();
        };
        UriQuery.prototype.toAny = function (params) {
            if (this.isDefined()) {
                params = params || {};
                var query = this;
                var i = 0;
                while (!query.isEmpty()) {
                    var key = query.key();
                    if (key !== null) {
                        params[key] = query.value();
                    }
                    else {
                        params["$" + i] = query.value();
                    }
                    query = query.tail();
                    i += 1;
                }
            }
            return params;
        };
        UriQuery.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriQuery.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriQuery) {
                return this.toString() === that.toString();
            }
            return false;
        };
        UriQuery.prototype.hashCode = function () {
            if (this._hashCode === void 0) {
                this._hashCode = Murmur3.hash(this.toString());
            }
            return this._hashCode;
        };
        UriQuery.prototype.display = function (output) {
            var query = this;
            var first = true;
            while (!query.isEmpty()) {
                if (!first) {
                    output = output.write(38);
                }
                else {
                    first = false;
                }
                var key = query.key();
                if (key !== null) {
                    Uri.writeParam(key, output);
                    output = output.write(61);
                }
                Uri.writeQuery(query.value(), output);
                query = query.tail();
            }
        };
        UriQuery.builder = function () {
            return new Uri.QueryBuilder();
        };
        UriQuery.undefined = function () {
            if (UriQuery._undefined === void 0) {
                UriQuery._undefined = new Uri.QueryUndefined();
            }
            return UriQuery._undefined;
        };
        UriQuery.param = function (key, value, tail) {
            if (tail === void 0) {
                tail = value;
                value = key;
                key = null;
            }
            else if (key !== null) {
                key = this.cacheKey(key);
            }
            if (tail === void 0) {
                tail = UriQuery.undefined();
            }
            return new Uri.QueryParam(key, value, tail);
        };
        UriQuery.from = function (key, value) {
            var builder = new Uri.QueryBuilder();
            builder.add(key, value);
            return builder.bind();
        };
        UriQuery.fromAny = function (query) {
            if (query === null || query === void 0) {
                return UriQuery.undefined();
            }
            else if (query instanceof UriQuery) {
                return query;
            }
            else if (typeof query === "object") {
                var builder = new Uri.QueryBuilder();
                builder.add(query);
                return builder.bind();
            }
            else if (typeof query === "string") {
                return UriQuery.parse(query);
            }
            else {
                throw new TypeError("" + query);
            }
        };
        UriQuery.parse = function (string) {
            return Uri.standardParser().parseQueryString(string);
        };
        UriQuery.keyCache = function () {
            if (UriQuery._keyCache === void 0) {
                var keyCacheSize = 64;
                UriQuery._keyCache = new HashGenCacheSet(keyCacheSize);
            }
            return UriQuery._keyCache;
        };
        UriQuery.cacheKey = function (key) {
            if (key.length <= 32) {
                return UriQuery.keyCache().put(key);
            }
            else {
                return key;
            }
        };
        return UriQuery;
    }());
    Uri.Query = UriQuery;

    var UriQueryParam = (function (_super) {
        __extends(UriQueryParam, _super);
        function UriQueryParam(key, value, tail) {
            var _this = _super.call(this) || this;
            _this._key = key;
            _this._value = value;
            _this._tail = tail;
            return _this;
        }
        UriQueryParam.prototype.isDefined = function () {
            return true;
        };
        UriQueryParam.prototype.isEmpty = function () {
            return false;
        };
        UriQueryParam.prototype.head = function () {
            return [this._key, this._value];
        };
        UriQueryParam.prototype.key = function () {
            return this._key;
        };
        UriQueryParam.prototype.value = function () {
            return this._value;
        };
        UriQueryParam.prototype.tail = function () {
            return this._tail;
        };
        UriQueryParam.prototype.setTail = function (tail) {
            this._tail = tail;
        };
        UriQueryParam.prototype.dealias = function () {
            return new UriQueryParam(this._key, this._value, this._tail);
        };
        UriQueryParam.prototype.debug = function (output) {
            output = output.write("UriQuery").write(46).write("parse")
                .write(40).write(34).display(this).write(34).write(41);
        };
        UriQueryParam.prototype.display = function (output) {
            if (this._string !== void 0) {
                output = output.write(this._string);
            }
            else {
                _super.prototype.display.call(this, output);
            }
        };
        UriQueryParam.prototype.toString = function () {
            if (this._string === void 0) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        return UriQueryParam;
    }(UriQuery));
    Uri.QueryParam = UriQueryParam;

    var UriQueryUndefined = (function (_super) {
        __extends(UriQueryUndefined, _super);
        function UriQueryUndefined() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UriQueryUndefined.prototype.isDefined = function () {
            return false;
        };
        UriQueryUndefined.prototype.isEmpty = function () {
            return true;
        };
        UriQueryUndefined.prototype.head = function () {
            throw new Error("Undefined Query");
        };
        UriQueryUndefined.prototype.key = function () {
            throw new Error("Undefined Query");
        };
        UriQueryUndefined.prototype.value = function () {
            throw new Error("Undefined Query");
        };
        UriQueryUndefined.prototype.tail = function () {
            throw new Error("Undefined Query");
        };
        UriQueryUndefined.prototype.setTail = function (tail) {
            throw new Error("Undefined Query");
        };
        UriQueryUndefined.prototype.dealias = function () {
            return this;
        };
        UriQueryUndefined.prototype.updated = function (key, value) {
            return UriQuery.param(key, value, this);
        };
        UriQueryUndefined.prototype.removed = function (key) {
            return this;
        };
        UriQueryUndefined.prototype.appended = function (key, value) {
            return UriQuery.from(key, value);
        };
        UriQueryUndefined.prototype.prepended = function (key, value) {
            return UriQuery.from(key, value);
        };
        UriQueryUndefined.prototype.debug = function (output) {
            output = output.write("UriQuery").write(46).write("undefined")
                .write(40).write(41);
        };
        UriQueryUndefined.prototype.display = function (output) {
        };
        UriQueryUndefined.prototype.toString = function () {
            return "";
        };
        return UriQueryUndefined;
    }(UriQuery));
    Uri.QueryUndefined = UriQueryUndefined;

    var UriQueryBuilder = (function () {
        function UriQueryBuilder() {
            this._first = Uri.Query.undefined();
            this._last = null;
            this._size = 0;
            this._aliased = 0;
        }
        UriQueryBuilder.prototype.isEmpty = function () {
            return this._size === 0;
        };
        UriQueryBuilder.prototype.add = function (key, value) {
            if (value !== void 0) {
                this.addParam(key, value);
            }
            else if (typeof key === "string") {
                this.addParam(null, key);
            }
            else if (key instanceof Uri.Query) {
                this.addQuery(key);
            }
            else {
                var params = key;
                for (var k in params) {
                    var key_1 = k;
                    var value_1 = params[k];
                    if (k.charCodeAt(0) === 36) {
                        key_1 = null;
                    }
                    this.addParam(key_1, value_1);
                }
            }
        };
        UriQueryBuilder.prototype.bind = function () {
            this._aliased = 0;
            return this._first;
        };
        UriQueryBuilder.prototype.addParam = function (key, value) {
            if (value === void 0) {
                value = key;
                key = null;
            }
            var tail = Uri.Query.param(key, value, Uri.Query.undefined());
            var size = this._size;
            if (size === 0) {
                this._first = tail;
            }
            else {
                this.dealias(size - 1).setTail(tail);
            }
            this._last = tail;
            this._size = size + 1;
            this._aliased += 1;
        };
        UriQueryBuilder.prototype.addQuery = function (query) {
            if (!query.isEmpty()) {
                var size = this._size;
                if (size === 0) {
                    this._first = query;
                }
                else {
                    this.dealias(size - 1).setTail(query);
                }
                size += 1;
                do {
                    var tail = query.tail();
                    if (!tail.isEmpty()) {
                        query = tail;
                        size += 1;
                    }
                    else {
                        break;
                    }
                } while (true);
                this._last = query;
                this._size = size;
            }
        };
        UriQueryBuilder.prototype.dealias = function (n) {
            var i = 0;
            var xi = null;
            var xs = this._first;
            if (this._aliased <= n) {
                while (i < this._aliased) {
                    xi = xs;
                    xs = xs.tail();
                    i += 1;
                }
                while (i <= n) {
                    var xn = xs.dealias();
                    if (i === 0) {
                        this._first = xn;
                    }
                    else {
                        xi.setTail(xn);
                    }
                    xi = xn;
                    xs = xs.tail();
                    i += 1;
                }
                if (i === this._size) {
                    this._last = xi;
                }
                this._aliased = i;
            }
            else if (n === 0) {
                xi = this._first;
            }
            else if (n === this._size - 1) {
                xi = this._last;
            }
            else {
                while (i <= n) {
                    xi = xs;
                    xs = xs.tail();
                    i += 1;
                }
            }
            return xi;
        };
        return UriQueryBuilder;
    }());
    Uri.QueryBuilder = UriQueryBuilder;

    var UriFragment = (function () {
        function UriFragment(identifier) {
            this._identifier = identifier;
        }
        UriFragment.prototype.isDefined = function () {
            return this._identifier !== null;
        };
        UriFragment.prototype.identifier = function () {
            return this._identifier;
        };
        UriFragment.prototype.toAny = function () {
            return this._identifier !== null ? this._identifier : void 0;
        };
        UriFragment.prototype.compareTo = function (that) {
            var order = this.toString().localeCompare(that.toString());
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        };
        UriFragment.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof UriFragment) {
                return this._identifier === that._identifier;
            }
            return false;
        };
        UriFragment.prototype.hashCode = function () {
            return Murmur3.hash(this._identifier);
        };
        UriFragment.prototype.debug = function (output) {
            output = output.write("UriFragment").write(46);
            if (this.isDefined()) {
                output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
            }
            else {
                output = output.write("undefined").write(40).write(41);
            }
        };
        UriFragment.prototype.display = function (output) {
            if (this._string !== void 0) {
                output = output.write(this._string);
            }
            else if (this._identifier !== null) {
                Uri.writeFragment(this._identifier, output);
            }
        };
        UriFragment.prototype.toString = function () {
            if (this._string == null) {
                this._string = Format.display(this);
            }
            return this._string;
        };
        UriFragment.undefined = function () {
            if (UriFragment._undefined === void 0) {
                UriFragment._undefined = new UriFragment(null);
            }
            return UriFragment._undefined;
        };
        UriFragment.from = function (identifier) {
            if (identifier !== null) {
                var cache = UriFragment.cache();
                var fragment = cache.get(identifier);
                if (fragment) {
                    return fragment;
                }
                else {
                    return cache.put(identifier, new UriFragment(identifier));
                }
            }
            else {
                return UriFragment.undefined();
            }
        };
        UriFragment.fromAny = function (fragment) {
            if (fragment === null || fragment === void 0) {
                return UriFragment.undefined();
            }
            else if (fragment instanceof UriFragment) {
                return fragment;
            }
            else if (typeof fragment === "string") {
                return UriFragment.parse(fragment);
            }
            else {
                throw new TypeError("" + fragment);
            }
        };
        UriFragment.parse = function (string) {
            return Uri.standardParser().parseFragmentString(string);
        };
        UriFragment.cache = function () {
            if (UriFragment._cache === void 0) {
                var cacheSize = 32;
                UriFragment._cache = new HashGenCacheMap(cacheSize);
            }
            return UriFragment._cache;
        };
        return UriFragment;
    }());
    Uri.Fragment = UriFragment;

    var UriParser = (function () {
        function UriParser() {
        }
        UriParser.prototype.absolute = function (scheme, authority, path, query, fragment) {
            return Uri.from(scheme, authority, path, query, fragment);
        };
        UriParser.prototype.scheme = function (name) {
            return Uri.Scheme.from(name);
        };
        UriParser.prototype.authority = function (user, host, port) {
            return Uri.Authority.from(user, host, port);
        };
        UriParser.prototype.user = function (username, password) {
            return Uri.User.from(username, password);
        };
        UriParser.prototype.hostName = function (address) {
            return Uri.Host.from(address);
        };
        UriParser.prototype.hostIPv4 = function (address) {
            return Uri.Host.ipv4(address);
        };
        UriParser.prototype.hostIPv6 = function (address) {
            return Uri.Host.ipv6(address);
        };
        UriParser.prototype.port = function (number) {
            return Uri.Port.from(number);
        };
        UriParser.prototype.pathEmpty = function () {
            return Uri.Path.empty();
        };
        UriParser.prototype.pathBuilder = function () {
            return new Uri.PathBuilder();
        };
        UriParser.prototype.queryBuilder = function () {
            return new Uri.QueryBuilder();
        };
        UriParser.prototype.fragment = function (identifier) {
            return Uri.Fragment.from(identifier);
        };
        UriParser.prototype.absoluteParser = function () {
            return new UriParser.AbsoluteParser(this);
        };
        UriParser.prototype.parseAbsolute = function (input) {
            return UriParser.AbsoluteParser.parse(input, this);
        };
        UriParser.prototype.parseAbsoluteString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseAbsolute(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.schemeParser = function () {
            return new UriParser.SchemeParser(this);
        };
        UriParser.prototype.parseScheme = function (input) {
            return UriParser.SchemeParser.parse(input, this);
        };
        UriParser.prototype.parseSchemeString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseScheme(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.authorityParser = function () {
            return new UriParser.AuthorityParser(this);
        };
        UriParser.prototype.parseAuthority = function (input) {
            return UriParser.AuthorityParser.parse(input, this);
        };
        UriParser.prototype.parseAuthorityString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseAuthority(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.userParser = function () {
            return new UriParser.UserParser(this);
        };
        UriParser.prototype.parseUser = function (input) {
            return UriParser.UserParser.parse(input, this);
        };
        UriParser.prototype.parseUserString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseUser(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.hostParser = function () {
            return new UriParser.HostParser(this);
        };
        UriParser.prototype.parseHost = function (input) {
            return UriParser.HostParser.parse(input, this);
        };
        UriParser.prototype.parseHostString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseHost(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.hostAddressParser = function () {
            return new UriParser.HostAddressParser(this);
        };
        UriParser.prototype.parseHostAddress = function (input) {
            return UriParser.HostAddressParser.parse(input, this);
        };
        UriParser.prototype.hostLiteralParser = function () {
            return new UriParser.HostLiteralParser(this);
        };
        UriParser.prototype.parseHostLiteral = function (input) {
            return UriParser.HostLiteralParser.parse(input, this);
        };
        UriParser.prototype.portParser = function () {
            return new UriParser.PortParser(this);
        };
        UriParser.prototype.parsePort = function (input) {
            return UriParser.PortParser.parse(input, this);
        };
        UriParser.prototype.parsePortString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parsePort(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.pathParser = function (builder) {
            return new UriParser.PathParser(this, builder);
        };
        UriParser.prototype.parsePath = function (input, builder) {
            return UriParser.PathParser.parse(input, this, builder);
        };
        UriParser.prototype.parsePathString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parsePath(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.queryParser = function (builder) {
            return new UriParser.QueryParser(this, builder);
        };
        UriParser.prototype.parseQuery = function (input, builder) {
            return UriParser.QueryParser.parse(input, this, builder);
        };
        UriParser.prototype.parseQueryString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseQuery(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        UriParser.prototype.fragmentParser = function () {
            return new UriParser.FragmentParser(this);
        };
        UriParser.prototype.parseFragment = function (input) {
            return UriParser.FragmentParser.parse(input, this);
        };
        UriParser.prototype.parseFragmentString = function (string) {
            var input = Unicode.stringInput(string);
            var parser = this.parseFragment(input);
            if (input.isCont() && !parser.isError()) {
                parser = Parser.error(Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        return UriParser;
    }());
    Uri.Parser = UriParser;

    var UriAbsoluteParser = (function (_super) {
        __extends(UriAbsoluteParser, _super);
        function UriAbsoluteParser(uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.schemeParser = schemeParser;
            _this.authorityParser = authorityParser;
            _this.pathParser = pathParser;
            _this.queryParser = queryParser;
            _this.fragmentParser = fragmentParser;
            _this.step = step;
            return _this;
        }
        UriAbsoluteParser.prototype.feed = function (input) {
            return UriAbsoluteParser.parse(input, this.uri, this.schemeParser, this.authorityParser, this.pathParser, this.queryParser, this.fragmentParser, this.step);
        };
        UriAbsoluteParser.parse = function (input, uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    var look = input.clone();
                    while (look.isCont() && (c = look.head(), Uri.isSchemeChar(c))) {
                        look.step();
                    }
                    if (look.isCont() && c === 58) {
                        step = 2;
                    }
                    else {
                        step = 3;
                    }
                }
                else if (input.isDone()) {
                    step = 3;
                }
            }
            if (step === 2) {
                if (!schemeParser) {
                    schemeParser = uri.parseScheme(input);
                }
                else {
                    schemeParser = schemeParser.feed(input);
                }
                if (schemeParser.isDone()) {
                    if (input.isCont() && input.head() === 58) {
                        input = input.step();
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected(58, input));
                    }
                }
                else if (schemeParser.isError()) {
                    return schemeParser.asError();
                }
            }
            if (step === 3) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 47) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c === 63) {
                        input = input.step();
                        step = 7;
                    }
                    else if (c === 35) {
                        input = input.step();
                        step = 8;
                    }
                    else {
                        step = 6;
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(uri.absolute(schemeParser && schemeParser.bind()));
                }
            }
            if (step === 4) {
                if (input.isCont() && input.head() === 47) {
                    input = input.step();
                    step = 5;
                }
                else if (input.isCont()) {
                    var pathBuilder = uri.pathBuilder();
                    pathBuilder.addSlash();
                    pathParser = uri.parsePath(input, pathBuilder);
                    step = 6;
                }
                else if (input.isDone()) {
                    return Parser.done(uri.absolute(schemeParser && schemeParser.bind(), void 0, Uri.Path.slash()));
                }
            }
            if (step === 5) {
                if (!authorityParser) {
                    authorityParser = uri.parseAuthority(input);
                }
                else {
                    authorityParser = authorityParser.feed(input);
                }
                if (authorityParser.isDone()) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 63) {
                            input = input.step();
                            step = 7;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 8;
                        }
                        else {
                            step = 6;
                        }
                    }
                    else if (input.isDone()) {
                        return Parser.done(uri.absolute(schemeParser && schemeParser.bind(), authorityParser && authorityParser.bind()));
                    }
                }
                else if (authorityParser.isError()) {
                    return authorityParser.asError();
                }
            }
            if (step === 6) {
                if (!pathParser) {
                    pathParser = uri.parsePath(input);
                }
                else {
                    pathParser = pathParser.feed(input);
                }
                if (pathParser.isDone()) {
                    if (input.isCont() && input.head() === 63) {
                        input = input.step();
                        step = 7;
                    }
                    else if (input.isCont() && input.head() === 35) {
                        input = input.step();
                        step = 8;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.absolute(schemeParser && schemeParser.bind(), authorityParser && authorityParser.bind(), pathParser.bind()));
                    }
                }
                else if (pathParser.isError()) {
                    return pathParser.asError();
                }
            }
            if (step === 7) {
                if (!queryParser) {
                    queryParser = uri.parseQuery(input);
                }
                else {
                    queryParser = queryParser.feed(input);
                }
                if (queryParser.isDone()) {
                    if (input.isCont() && input.head() === 35) {
                        input = input.step();
                        step = 8;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.absolute(schemeParser && schemeParser.bind(), authorityParser && authorityParser.bind(), pathParser && pathParser.bind(), queryParser.bind()));
                    }
                }
                else if (queryParser.isError()) {
                    return queryParser.asError();
                }
            }
            if (step === 8) {
                if (!fragmentParser) {
                    fragmentParser = uri.parseFragment(input);
                }
                else {
                    fragmentParser = fragmentParser.feed(input);
                }
                if (fragmentParser.isDone()) {
                    return Parser.done(uri.absolute(schemeParser && schemeParser.bind(), authorityParser && authorityParser.bind(), pathParser && pathParser.bind(), queryParser && queryParser.bind(), fragmentParser.bind()));
                }
                else if (fragmentParser.isError()) {
                    return fragmentParser.asError();
                }
            }
            return new UriAbsoluteParser(uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step);
        };
        return UriAbsoluteParser;
    }(Parser));
    UriParser.AbsoluteParser = UriAbsoluteParser;

    var UriSchemeParser = (function (_super) {
        __extends(UriSchemeParser, _super);
        function UriSchemeParser(uri, output, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.output = output;
            _this.step = step;
            return _this;
        }
        UriSchemeParser.prototype.feed = function (input) {
            return UriSchemeParser.parse(input, this.uri, this.output, this.step);
        };
        UriSchemeParser.parse = function (input, uri, output, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont() && (c = input.head(), Uri.isAlpha(c))) {
                    input = input.step();
                    output = output || Utf8.decodedString();
                    output = output.write(Uri.toLowerCase(c));
                    step = 2;
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.expected("scheme", input));
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Uri.isSchemeChar(c))) {
                    input = input.step();
                    output.write(Uri.toLowerCase(c));
                }
                if (!input.isEmpty()) {
                    return Parser.done(uri.scheme(output.bind()));
                }
            }
            return new UriSchemeParser(uri, output, step);
        };
        return UriSchemeParser;
    }(Parser));
    UriParser.SchemeParser = UriSchemeParser;

    var UriAuthorityParser = (function (_super) {
        __extends(UriAuthorityParser, _super);
        function UriAuthorityParser(uri, userParser, hostParser, portParser, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.userParser = userParser;
            _this.hostParser = hostParser;
            _this.portParser = portParser;
            _this.step = step;
            return _this;
        }
        UriAuthorityParser.prototype.feed = function (input) {
            return UriAuthorityParser.parse(input, this.uri, this.userParser, this.hostParser, this.portParser, this.step);
        };
        UriAuthorityParser.parse = function (input, uri, userParser, hostParser, portParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    var look = input.clone();
                    while (look.isCont() && (c = look.head(), c !== 64 && c !== 47)) {
                        look.step();
                    }
                    if (look.isCont() && c === 64) {
                        step = 2;
                    }
                    else {
                        step = 3;
                    }
                }
                else if (input.isDone()) {
                    step = 3;
                }
            }
            if (step === 2) {
                if (!userParser) {
                    userParser = uri.parseUser(input);
                }
                else {
                    userParser = userParser.feed(input);
                }
                if (userParser.isDone()) {
                    if (input.isCont() && input.head() === 64) {
                        input = input.step();
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected(64, input));
                    }
                }
                else if (userParser.isError()) {
                    return userParser.asError();
                }
            }
            if (step === 3) {
                if (!hostParser) {
                    hostParser = uri.parseHost(input);
                }
                else {
                    hostParser = hostParser.feed(input);
                }
                if (hostParser.isDone()) {
                    if (input.isCont() && input.head() === 58) {
                        input = input.step();
                        step = 4;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.authority(userParser && userParser.bind(), hostParser.bind()));
                    }
                }
                else if (hostParser.isError()) {
                    return hostParser.asError();
                }
            }
            if (step === 4) {
                if (!portParser) {
                    portParser = uri.parsePort(input);
                }
                else {
                    portParser = portParser.feed(input);
                }
                if (portParser.isDone()) {
                    return Parser.done(uri.authority(userParser && userParser.bind(), hostParser.bind(), portParser.bind()));
                }
                else if (portParser.isError()) {
                    return portParser.asError();
                }
            }
            return new UriAuthorityParser(uri, userParser, hostParser, portParser, step);
        };
        return UriAuthorityParser;
    }(Parser));
    UriParser.AuthorityParser = UriAuthorityParser;

    var UriUserParser = (function (_super) {
        __extends(UriUserParser, _super);
        function UriUserParser(uri, usernameOutput, passwordOutput, c1, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.usernameOutput = usernameOutput;
            _this.passwordOutput = passwordOutput;
            _this.c1 = c1;
            _this.step = step;
            return _this;
        }
        UriUserParser.prototype.feed = function (input) {
            return UriUserParser.parse(input, this.uri, this.usernameOutput, this.passwordOutput, this.c1, this.step);
        };
        UriUserParser.parse = function (input, uri, usernameOutput, passwordOutput, c1, step) {
            if (c1 === void 0) { c1 = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    usernameOutput = usernameOutput || Utf8.decodedString();
                    while (input.isCont() && (c = input.head(), Uri.isUserChar(c))) {
                        input = input.step();
                        usernameOutput.write(c);
                    }
                    if (input.isCont() && c === 58) {
                        input = input.step();
                        step = 4;
                    }
                    else if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.user(usernameOutput.bind()));
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 3) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        usernameOutput.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 1;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 4) {
                    passwordOutput = passwordOutput || Utf8.decodedString();
                    while (input.isCont() && (c = input.head(), Uri.isUserInfoChar(c))) {
                        input = input.step();
                        passwordOutput.write(c);
                    }
                    if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 5;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.user(usernameOutput.bind(), passwordOutput.bind()));
                    }
                }
                if (step === 5) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 6;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 6) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        passwordOutput.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 4;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                break;
            } while (true);
            return new UriUserParser(uri, usernameOutput, passwordOutput, c1, step);
        };
        return UriUserParser;
    }(Parser));
    UriParser.UserParser = UriUserParser;

    var UriHostParser = (function (_super) {
        __extends(UriHostParser, _super);
        function UriHostParser(uri) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            return _this;
        }
        UriHostParser.prototype.feed = function (input) {
            return UriHostParser.parse(input, this.uri);
        };
        UriHostParser.parse = function (input, uri) {
            if (input.isCont()) {
                var c = input.head();
                if (c === 91) {
                    return uri.parseHostLiteral(input);
                }
                else {
                    return uri.parseHostAddress(input);
                }
            }
            else if (input.isDone()) {
                return Parser.done(uri.hostName(""));
            }
            return new UriHostParser(uri);
        };
        return UriHostParser;
    }(Parser));
    UriParser.HostParser = UriHostParser;

    var UriHostAddressParser = (function (_super) {
        __extends(UriHostAddressParser, _super);
        function UriHostAddressParser(uri, output, c1, x, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.output = output;
            _this.c1 = c1;
            _this.x = x;
            _this.step = step;
            return _this;
        }
        UriHostAddressParser.prototype.feed = function (input) {
            return UriHostAddressParser.parse(input, this.uri, this.output, this.c1, this.x, this.step);
        };
        UriHostAddressParser.parse = function (input, uri, output, c1, x, step) {
            if (c1 === void 0) { c1 = 0; }
            if (x === void 0) { x = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            output = output || Utf8.decodedString();
            while (step <= 4) {
                while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
                    input = input.step();
                    output = output.write(c);
                    x = 10 * x + Base10.decodeDigit(c);
                }
                if (input.isCont()) {
                    if (c === 46 && step < 4 && x <= 255) {
                        input = input.step();
                        output = output.write(c);
                        x = 0;
                        step += 1;
                    }
                    else if (!Uri.isHostChar(c) && c !== 37 && step === 4 && x <= 255) {
                        return Parser.done(uri.hostIPv4(output.bind()));
                    }
                    else {
                        x = 0;
                        step = 5;
                        break;
                    }
                }
                else if (!input.isEmpty()) {
                    if (step === 4 && x <= 255) {
                        return Parser.done(uri.hostIPv4(output.bind()));
                    }
                    else {
                        return Parser.done(uri.hostName(output.bind()));
                    }
                }
                else {
                    break;
                }
            }
            do {
                if (step === 5) {
                    while (input.isCont() && (c = input.head(), Uri.isHostChar(c))) {
                        input = input.step();
                        output.write(Uri.toLowerCase(c));
                    }
                    if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 6;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.hostName(output.bind()));
                    }
                }
                if (step === 6) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 7;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 7) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 5;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                break;
            } while (true);
            return new UriHostAddressParser(uri, output, c1, x, step);
        };
        return UriHostAddressParser;
    }(Parser));
    UriParser.HostAddressParser = UriHostAddressParser;

    var UriHostLiteralParser = (function (_super) {
        __extends(UriHostLiteralParser, _super);
        function UriHostLiteralParser(uri, output, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.output = output;
            _this.step = step;
            return _this;
        }
        UriHostLiteralParser.prototype.feed = function (input) {
            return UriHostLiteralParser.parse(input, this.uri, this.output, this.step);
        };
        UriHostLiteralParser.parse = function (input, uri, output, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont() && input.head() === 91) {
                    input = input.step();
                    step = 2;
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.expected(91, input));
                }
            }
            if (step === 2) {
                output = output || Utf8.decodedString();
                while (input.isCont() && (c = input.head(), Uri.isHostChar(c) || c === 58)) {
                    input = input.step();
                    output = output.write(Uri.toLowerCase(c));
                }
                if (input.isCont() && c === 93) {
                    input = input.step();
                    return Parser.done(uri.hostIPv6(output.bind()));
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.expected(93, input));
                }
            }
            return new UriHostLiteralParser(uri, output, step);
        };
        return UriHostLiteralParser;
    }(Parser));
    UriParser.HostLiteralParser = UriHostLiteralParser;

    var UriPortParser = (function (_super) {
        __extends(UriPortParser, _super);
        function UriPortParser(uri, number) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.number = number;
            return _this;
        }
        UriPortParser.prototype.feed = function (input) {
            return UriPortParser.parse(input, this.uri, this.number);
        };
        UriPortParser.parse = function (input, uri, number) {
            if (number === void 0) { number = 0; }
            var c = 0;
            while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
                input = input.step();
                number = 10 * number + Base10.decodeDigit(c);
            }
            if (!input.isEmpty()) {
                return Parser.done(uri.port(number));
            }
            return new UriPortParser(uri, number);
        };
        return UriPortParser;
    }(Parser));
    UriParser.PortParser = UriPortParser;

    var UriPathParser = (function (_super) {
        __extends(UriPathParser, _super);
        function UriPathParser(uri, builder, output, c1, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.builder = builder;
            _this.output = output;
            _this.c1 = c1;
            _this.step = step;
            return _this;
        }
        UriPathParser.prototype.feed = function (input) {
            return UriPathParser.parse(input, this.uri, this.builder, this.output, this.c1, this.step);
        };
        UriPathParser.parse = function (input, uri, builder, output, c1, step) {
            if (c1 === void 0) { c1 = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Uri.isPathChar(c))) {
                        output = output || Utf8.decodedString();
                        input = input.step();
                        output = output.write(c);
                    }
                    if (input.isCont() && c === 47) {
                        input = input.step();
                        builder = builder || uri.pathBuilder();
                        if (output) {
                            builder.addSegment(output.bind());
                            output = void 0;
                        }
                        builder.addSlash();
                        continue;
                    }
                    else if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        if (output) {
                            builder = builder || uri.pathBuilder();
                            builder.addSegment(output.bind());
                        }
                        if (builder) {
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.done(uri.pathEmpty());
                        }
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 3) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        output = output || Utf8.decodedString();
                        input = input.step();
                        output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 1;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                break;
            } while (true);
            return new UriPathParser(uri, builder, output, c1, step);
        };
        return UriPathParser;
    }(Parser));
    UriParser.PathParser = UriPathParser;

    var UriQueryParser = (function (_super) {
        __extends(UriQueryParser, _super);
        function UriQueryParser(uri, builder, keyOutput, valueOutput, c1, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.builder = builder;
            _this.keyOutput = keyOutput;
            _this.valueOutput = valueOutput;
            _this.c1 = c1;
            _this.step = step;
            return _this;
        }
        UriQueryParser.prototype.feed = function (input) {
            return UriQueryParser.parse(input, this.uri, this.builder, this.keyOutput, this.valueOutput, this.c1, this.step);
        };
        UriQueryParser.parse = function (input, uri, builder, keyOutput, valueOutput, c1, step) {
            if (c1 === void 0) { c1 = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    keyOutput = keyOutput || Utf8.decodedString();
                    while (input.isCont() && (c = input.head(), Uri.isParamChar(c))) {
                        input = input.step();
                        keyOutput.write(c);
                    }
                    if (input.isCont() && c === 61) {
                        input = input.step();
                        step = 4;
                    }
                    else if (input.isCont() && c === 38) {
                        input = input.step();
                        builder = builder || uri.queryBuilder();
                        builder.addParam(keyOutput.bind());
                        keyOutput = void 0;
                        continue;
                    }
                    else if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        builder = builder || uri.queryBuilder();
                        builder.addParam(keyOutput.bind());
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 3) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        keyOutput.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 1;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 4) {
                    valueOutput = valueOutput || Utf8.decodedString();
                    while (input.isCont() && (c = input.head(), Uri.isParamChar(c) || c === 61)) {
                        input = input.step();
                        valueOutput.write(c);
                    }
                    if (input.isCont() && c === 38) {
                        input = input.step();
                        builder = builder || uri.queryBuilder();
                        builder.addParam(keyOutput.bind(), valueOutput.bind());
                        keyOutput = void 0;
                        valueOutput = void 0;
                        step = 1;
                        continue;
                    }
                    else if (input.isCont() && c === 38) {
                        input = input.step();
                        step = 5;
                    }
                    else if (!input.isEmpty()) {
                        builder = builder || uri.queryBuilder();
                        builder.addParam(keyOutput.bind(), valueOutput.bind());
                        return Parser.done(builder.bind());
                    }
                }
                if (step === 5) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 6;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 6) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        valueOutput.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 4;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                break;
            } while (true);
            return new UriQueryParser(uri, builder, keyOutput, valueOutput, c1, step);
        };
        return UriQueryParser;
    }(Parser));
    UriParser.QueryParser = UriQueryParser;

    var UriFragmentParser = (function (_super) {
        __extends(UriFragmentParser, _super);
        function UriFragmentParser(uri, output, c1, step) {
            var _this = _super.call(this) || this;
            _this.uri = uri;
            _this.output = output;
            _this.c1 = c1;
            _this.step = step;
            return _this;
        }
        UriFragmentParser.prototype.feed = function (input) {
            return UriFragmentParser.parse(input, this.uri, this.output, this.c1, this.step);
        };
        UriFragmentParser.parse = function (input, uri, output, c1, step) {
            if (c1 === void 0) { c1 = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            output = output || Utf8.decodedString();
            do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Uri.isFragmentChar(c))) {
                        input = input.step();
                        output = output.write(c);
                    }
                    if (input.isCont() && c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.done(uri.fragment(output.bind()));
                    }
                }
                if (step === 2) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        c1 = c;
                        step = 3;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                if (step === 3) {
                    if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
                        input = input.step();
                        output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));
                        c1 = 0;
                        step = 1;
                        continue;
                    }
                    else if (!input.isEmpty()) {
                        return Parser.error(Diagnostic.expected("hex digit", input));
                    }
                }
                break;
            } while (true);
            return new UriFragmentParser(uri, output, c1, step);
        };
        return UriFragmentParser;
    }(Parser));
    UriParser.FragmentParser = UriFragmentParser;

    var UriForm = (function (_super) {
        __extends(UriForm, _super);
        function UriForm(unit) {
            var _this = _super.call(this) || this;
            _this._unit = unit;
            return _this;
        }
        UriForm.prototype.unit = function (unit) {
            if (arguments.length === 0) {
                return this._unit;
            }
            else {
                return new UriForm(unit);
            }
        };
        UriForm.prototype.mold = function (object, item) {
            if (item === void 0) {
                return Text.from(object.toString());
            }
            else {
                return item.concat(Text.from(object.toString()));
            }
        };
        UriForm.prototype.cast = function (item, object) {
            var value = item.target();
            try {
                var string = value.stringValue();
                if (typeof string === "string") {
                    return Uri.parse(string);
                }
            }
            catch (error) {
            }
            return void 0;
        };
        return UriForm;
    }(Form));
    Uri.Form = UriForm;

    var UriCache = (function () {
        function UriCache(base, size) {
            if (size === void 0) { size = 32; }
            this._base = base;
            this._resolveCache = new HashGenCacheMap(size);
            this._unresolveCache = new HashGenCacheMap(size);
        }
        UriCache.prototype.resolve = function (relative) {
            relative = Uri.fromAny(relative);
            var absolute = this._resolveCache.get(relative);
            if (absolute === undefined) {
                absolute = this._base.resolve(relative);
                this._resolveCache.put(relative, absolute);
            }
            return absolute;
        };
        UriCache.prototype.unresolve = function (absolute) {
            absolute = Uri.fromAny(absolute);
            var relative = this._unresolveCache.get(absolute);
            if (relative === undefined) {
                relative = this._base.unresolve(absolute);
                this._unresolveCache.put(absolute, relative);
            }
            return relative;
        };
        return UriCache;
    }());

    exports.Absent = Absent;
    exports.AbstractInlet = AbstractInlet;
    exports.AbstractInoutlet = AbstractInoutlet;
    exports.AbstractMapInlet = AbstractMapInlet;
    exports.AbstractMapInletMapOutlet = AbstractMapInletMapOutlet;
    exports.AbstractMapInletOutlet = AbstractMapInletOutlet;
    exports.AbstractMapInoutlet = AbstractMapInoutlet;
    exports.AbstractMapOutlet = AbstractMapOutlet;
    exports.AbstractOutlet = AbstractOutlet;
    exports.AbstractRecordOutlet = AbstractRecordOutlet;
    exports.AbstractRecordStreamlet = AbstractRecordStreamlet;
    exports.AbstractStreamlet = AbstractStreamlet;
    exports.AndOperator = AndOperator;
    exports.AndOutlet = AndOutlet;
    exports.AnyForm = AnyForm;
    exports.AssertException = AssertException;
    exports.Attr = Attr;
    exports.BTree = BTree;
    exports.BTreeContext = BTreeContext;
    exports.BTreeLeaf = BTreeLeaf;
    exports.BTreeNode = BTreeNode;
    exports.BTreeNodeCursor = BTreeNodeCursor;
    exports.BTreePage = BTreePage;
    exports.Base10 = Base10;
    exports.Base10IntegerWriter = Base10IntegerWriter;
    exports.Base10NumberParser = Base10NumberParser;
    exports.Base16 = Base16;
    exports.Base16IntegerWriter = Base16IntegerWriter;
    exports.Base16Parser = Base16Parser;
    exports.Base16Writer = Base16Writer;
    exports.Base64 = Base64;
    exports.Base64Parser = Base64Parser;
    exports.Base64Writer = Base64Writer;
    exports.Binary = Binary;
    exports.BinaryOperator = BinaryOperator;
    exports.BinaryOutlet = BinaryOutlet;
    exports.BitwiseAndOperator = BitwiseAndOperator;
    exports.BitwiseAndOutlet = BitwiseAndOutlet;
    exports.BitwiseNotOperator = BitwiseNotOperator;
    exports.BitwiseNotOutlet = BitwiseNotOutlet;
    exports.BitwiseOrOperator = BitwiseOrOperator;
    exports.BitwiseOrOutlet = BitwiseOrOutlet;
    exports.BitwiseXorOperator = BitwiseXorOperator;
    exports.BitwiseXorOutlet = BitwiseXorOutlet;
    exports.Bool = Bool;
    exports.BooleanForm = BooleanForm;
    exports.BoxR2 = BoxR2;
    exports.BridgeFunc = BridgeFunc;
    exports.ChildrenSelector = ChildrenSelector;
    exports.CircleR2 = CircleR2;
    exports.ConditionalOperator = ConditionalOperator;
    exports.ConditionalOutlet = ConditionalOutlet;
    exports.Cursor = Cursor;
    exports.CursorArray = CursorArray;
    exports.CursorEmpty = CursorEmpty;
    exports.CursorUnary = CursorUnary;
    exports.Data = Data;
    exports.Dataflow = Dataflow;
    exports.DateTime = DateTime;
    exports.DateTimeForm = DateTimeForm;
    exports.DateTimeFormat = DateTimeFormat;
    exports.DateTimeLocale = DateTimeLocale;
    exports.DateTimeParser = DateTimeParser;
    exports.DateTimeSpecifiers = DateTimeSpecifiers;
    exports.DayInterval = DayInterval;
    exports.DayOfMonthFormat = DayOfMonthFormat;
    exports.DayOfMonthParser = DayOfMonthParser;
    exports.DescendantsSelector = DescendantsSelector;
    exports.Diagnostic = Diagnostic;
    exports.DivideOperator = DivideOperator;
    exports.DivideOutlet = DivideOutlet;
    exports.EqOperator = EqOperator;
    exports.EqOutlet = EqOutlet;
    exports.Expression = Expression;
    exports.Extant = Extant;
    exports.Field = Field;
    exports.FilterFieldsCombinator = FilterFieldsCombinator;
    exports.FilterFieldsOperator = FilterFieldsOperator;
    exports.FilterInterval = FilterInterval;
    exports.FilterSelector = FilterSelector;
    exports.Form = Form;
    exports.FormException = FormException;
    exports.Format = Format;
    exports.FromAny = FromAny;
    exports.Func = Func;
    exports.GeOperator = GeOperator;
    exports.GeOutlet = GeOutlet;
    exports.GetAttrSelector = GetAttrSelector;
    exports.GetItemSelector = GetItemSelector;
    exports.GetOutlet = GetOutlet;
    exports.GetSelector = GetSelector;
    exports.GtOperator = GtOperator;
    exports.GtOutlet = GtOutlet;
    exports.HashGenCacheMap = HashGenCacheMap;
    exports.HashGenCacheSet = HashGenCacheSet;
    exports.Hour12Format = Hour12Format;
    exports.Hour12Parser = Hour12Parser;
    exports.Hour24Format = Hour24Format;
    exports.Hour24Parser = Hour24Parser;
    exports.HourInterval = HourInterval;
    exports.IdentitySelector = IdentitySelector;
    exports.In = In;
    exports.Inlet = Inlet;
    exports.InletDescriptor = InletDescriptor;
    exports.Inout = Inout;
    exports.Input = Input;
    exports.InputBuffer = InputBuffer;
    exports.InputException = InputException;
    exports.InputSettings = InputSettings;
    exports.Interpreter = Interpreter;
    exports.InterpreterException = InterpreterException;
    exports.InterpreterSettings = InterpreterSettings;
    exports.InvokeOperator = InvokeOperator;
    exports.InvokeOutlet = InvokeOutlet;
    exports.Item = Item;
    exports.ItemForm = ItemForm;
    exports.KeyOutlet = KeyOutlet;
    exports.KeysCursor = KeysCursor;
    exports.KeysSelector = KeysSelector;
    exports.LambdaFunc = LambdaFunc;
    exports.LeOperator = LeOperator;
    exports.LeOutlet = LeOutlet;
    exports.LiteralSelector = LiteralSelector;
    exports.LtOperator = LtOperator;
    exports.LtOutlet = LtOutlet;
    exports.MapFieldValuesCombinator = MapFieldValuesCombinator;
    exports.MapFieldValuesOperator = MapFieldValuesOperator;
    exports.MapInlet = MapInlet;
    exports.MapInput = MapInput;
    exports.MapOutlet = MapOutlet;
    exports.MapOutput = MapOutput;
    exports.MapValueCombinator = MapValueCombinator;
    exports.MapValueOperator = MapValueOperator;
    exports.Mark = Mark;
    exports.MathModule = MathModule;
    exports.MemoizeMapCombinator = MemoizeMapCombinator;
    exports.MemoizeValueCombinator = MemoizeValueCombinator;
    exports.MillisecondFormat = MillisecondFormat;
    exports.MillisecondInterval = MillisecondInterval;
    exports.MillisecondParser = MillisecondParser;
    exports.MillisecondsInterval = MillisecondsInterval;
    exports.MinusOperator = MinusOperator;
    exports.MinusOutlet = MinusOutlet;
    exports.MinuteFormat = MinuteFormat;
    exports.MinuteInterval = MinuteInterval;
    exports.MinuteParser = MinuteParser;
    exports.ModuloOperator = ModuloOperator;
    exports.ModuloOutlet = ModuloOutlet;
    exports.MonthFormat = MonthFormat;
    exports.MonthInterval = MonthInterval;
    exports.MonthOfYearFormat = MonthOfYearFormat;
    exports.MonthOfYearParser = MonthOfYearParser;
    exports.MonthParser = MonthParser;
    exports.Murmur3 = Murmur3;
    exports.NativeOrder = NativeOrder;
    exports.NeOperator = NeOperator;
    exports.NeOutlet = NeOutlet;
    exports.NegativeOperator = NegativeOperator;
    exports.NegativeOutlet = NegativeOutlet;
    exports.NodeCursor = NodeCursor;
    exports.NotOperator = NotOperator;
    exports.NotOutlet = NotOutlet;
    exports.Num = Num;
    exports.NumberForm = NumberForm;
    exports.Objects = Objects;
    exports.Operator = Operator;
    exports.OrOperator = OrOperator;
    exports.OrOutlet = OrOutlet;
    exports.Out = Out;
    exports.Outlet = Outlet;
    exports.OutletDescriptor = OutletDescriptor;
    exports.OutletInlet = OutletInlet;
    exports.OutletMapInlet = OutletMapInlet;
    exports.Output = Output;
    exports.OutputBuffer = OutputBuffer;
    exports.OutputException = OutputException;
    exports.OutputSettings = OutputSettings;
    exports.OutputStyle = OutputStyle;
    exports.Parser = Parser;
    exports.ParserException = ParserException;
    exports.PatternFormat = PatternFormat;
    exports.PatternParser = PatternParser;
    exports.PeriodFormat = PeriodFormat;
    exports.PeriodParser = PeriodParser;
    exports.PlusOperator = PlusOperator;
    exports.PlusOutlet = PlusOutlet;
    exports.PointR2 = PointR2;
    exports.PositiveOperator = PositiveOperator;
    exports.PositiveOutlet = PositiveOutlet;
    exports.R2Shape = R2Shape;
    exports.Random = Random;
    exports.Recon = Recon;
    exports.ReconParser = ReconParser;
    exports.ReconStructureParser = ReconStructureParser;
    exports.ReconStructureWriter = ReconStructureWriter;
    exports.ReconWriter = ReconWriter;
    exports.Record = Record;
    exports.RecordFieldUpdater = RecordFieldUpdater;
    exports.RecordMap = RecordMap;
    exports.RecordMapView = RecordMapView;
    exports.RecordModel = RecordModel;
    exports.RecordOutlet = RecordOutlet;
    exports.RecordScope = RecordScope;
    exports.RecordStreamlet = RecordStreamlet;
    exports.ReduceFieldsCombinator = ReduceFieldsCombinator;
    exports.ReduceFieldsOperator = ReduceFieldsOperator;
    exports.STree = STree;
    exports.STreeContext = STreeContext;
    exports.STreeLeaf = STreeLeaf;
    exports.STreeNode = STreeNode;
    exports.STreeNodeCursor = STreeNodeCursor;
    exports.STreePage = STreePage;
    exports.SecondFormat = SecondFormat;
    exports.SecondInterval = SecondInterval;
    exports.SecondParser = SecondParser;
    exports.SegmentR2 = SegmentR2;
    exports.Selector = Selector;
    exports.Severity = Severity;
    exports.Shape = Shape;
    exports.ShortMonthFormat = ShortMonthFormat;
    exports.ShortMonthParser = ShortMonthParser;
    exports.ShortWeekdayFormat = ShortWeekdayFormat;
    exports.ShortWeekdayParser = ShortWeekdayParser;
    exports.Slot = Slot;
    exports.Span = Span;
    exports.Streamlet = Streamlet;
    exports.StreamletException = StreamletException;
    exports.StreamletInlet = StreamletInlet;
    exports.StreamletInoutlet = StreamletInoutlet;
    exports.StreamletOutlet = StreamletOutlet;
    exports.StreamletScope = StreamletScope;
    exports.StringForm = StringForm;
    exports.Tag = Tag;
    exports.TagForm = TagForm;
    exports.Text = Text;
    exports.TimeInterval = TimeInterval;
    exports.TimeZone = TimeZone;
    exports.TimeZoneForm = TimeZoneForm;
    exports.TimesOperator = TimesOperator;
    exports.TimesOutlet = TimesOutlet;
    exports.ToAny = ToAny;
    exports.Transmuter = Transmuter;
    exports.UnaryOperator = UnaryOperator;
    exports.UnaryOutlet = UnaryOutlet;
    exports.Unicode = Unicode;
    exports.UnitForm = UnitForm;
    exports.UnitTimeInterval = UnitTimeInterval;
    exports.Uri = Uri;
    exports.UriAbsoluteParser = UriAbsoluteParser;
    exports.UriAuthority = UriAuthority;
    exports.UriAuthorityParser = UriAuthorityParser;
    exports.UriCache = UriCache;
    exports.UriException = UriException;
    exports.UriForm = UriForm;
    exports.UriFragment = UriFragment;
    exports.UriFragmentParser = UriFragmentParser;
    exports.UriHost = UriHost;
    exports.UriHostAddressParser = UriHostAddressParser;
    exports.UriHostIPv4 = UriHostIPv4;
    exports.UriHostIPv6 = UriHostIPv6;
    exports.UriHostLiteralParser = UriHostLiteralParser;
    exports.UriHostName = UriHostName;
    exports.UriHostParser = UriHostParser;
    exports.UriHostUndefined = UriHostUndefined;
    exports.UriParser = UriParser;
    exports.UriPath = UriPath;
    exports.UriPathBuilder = UriPathBuilder;
    exports.UriPathEmpty = UriPathEmpty;
    exports.UriPathParser = UriPathParser;
    exports.UriPathSegment = UriPathSegment;
    exports.UriPathSlash = UriPathSlash;
    exports.UriPort = UriPort;
    exports.UriPortParser = UriPortParser;
    exports.UriQuery = UriQuery;
    exports.UriQueryBuilder = UriQueryBuilder;
    exports.UriQueryParam = UriQueryParam;
    exports.UriQueryParser = UriQueryParser;
    exports.UriQueryUndefined = UriQueryUndefined;
    exports.UriScheme = UriScheme;
    exports.UriSchemeParser = UriSchemeParser;
    exports.UriUser = UriUser;
    exports.UriUserParser = UriUserParser;
    exports.Utf8 = Utf8;
    exports.UtfErrorMode = UtfErrorMode;
    exports.Value = Value;
    exports.ValueBuilder = ValueBuilder;
    exports.ValueCursor = ValueCursor;
    exports.ValueEntryCursor = ValueEntryCursor;
    exports.ValueForm = ValueForm;
    exports.ValueInput = ValueInput;
    exports.ValueOutput = ValueOutput;
    exports.ValuesCursor = ValuesCursor;
    exports.ValuesSelector = ValuesSelector;
    exports.VectorR2 = VectorR2;
    exports.WatchFieldsCombinator = WatchFieldsCombinator;
    exports.WatchFieldsOperator = WatchFieldsOperator;
    exports.WatchValueCombinator = WatchValueCombinator;
    exports.WatchValueOperator = WatchValueOperator;
    exports.WeekInterval = WeekInterval;
    exports.WeekdayFormat = WeekdayFormat;
    exports.WeekdayParser = WeekdayParser;
    exports.Writer = Writer;
    exports.WriterException = WriterException;
    exports.YearFormat = YearFormat;
    exports.YearInterval = YearInterval;
    exports.YearParser = YearParser;
    exports.YearsInterval = YearsInterval;
    exports.assert = assert;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=swim-core.js.map